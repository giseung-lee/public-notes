<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      알고리즘 - 위상정렬(Topological Sort) &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Algorithm">Algorithm</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Java">Java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Spring">Spring</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Data_Structure">Data_Structure</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Network">Network</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">알고리즘 - 위상정렬(Topological Sort)</h1>
  <span class="post-date">15 Jun 2020</span>
  
<h2 id="위상정렬---순서-있는-노드-방문">위상정렬 - 순서 있는 노드 방문</h2>

<hr />

<p> 위상 정렬 문제는 위상 정렬을 알고 있다면 비교적 수월하게 진행 할 수 있지만(문제에서 위상 정렬을 캐치하기 쉬우므로), 위상 정렬을 모르고 있다면 꽤나 애를 먹을 수 있는 문제입니다.</p>

<p> 위상 정렬은 쉽게 말해 <strong>방향 그래프에서의 순서 있는 노드 방문</strong>입니다. RPG게임에서 흔히 볼 수 있는 스킬 트리나 대학에서의 선수 과목과 같이 노드들 간에 순서가 있는 그래프에서 사용됩니다.</p>

<p><img src="/public/image/Algorithm/Topological_Sort1.png" alt="Topological_Sort1.png" /></p>

<p> 위와 같은 학습 로드맵이 있다고 가정합시다. 과목간의 우선순위를 지키면서 위의 모든 수업을 들을 수 있는 경우의 수는 아래와 같이 다섯 가지입니다. (아래와 같이 위상정렬로 방문한 노드의 순서를 위상 순서(Topology Order)라고 합니다.)</p>

<ul>
  <li>Java - Spring - Oracle - JPA - Spring JPA</li>
  <li>Java - Oracle - JPA - Spring - Spring JPA</li>
  <li>Java - Oracle - Spring - JPA - Spring JPA</li>
  <li>Oracle - Java - Spring - JPA - Spring JPA</li>
  <li>Oracle - Java - JPA - Spring - Spring JPA</li>
</ul>

<p> 이렇게 단순한 위상정렬은 많은 가짓수가 나올 수 있습니다. 쉽게 문제를 낸다면  <a href="https://www.acmicpc.net/problem/2252">https://www.acmicpc.net/problem/2252</a> 문제처럼 아무 위상 순서 중 하나를 구하라고 할 수도 있지만, 대부분의 문제는 추가 조건을 붙여 여러 위상 순서 중 한 가지의 위상 순서만을 요구합니다.</p>

<p> <a href="https://www.acmicpc.net/problem/1766">https://www.acmicpc.net/problem/1766</a> 이 문제는 위상 순서들 중 노드 번호가 사전순으로 앞서는 위상 순서를 요구합니다. <a href="https://www.acmicpc.net/problem/2056">https://www.acmicpc.net/problem/2056</a> 이 문제는 노드를 하나의 작업으로 보고, 작업에 걸리는 시간을 배정했습니다. 공정의 공기를 계산하듯이 선행 관계가 없는 작업들은 동시에 진행할 수 있을 때, 최단 시간이 걸리는 위상 순서를 구하는 문제입니다.(구현이 점점 까다로워집니다.. 😥😥)</p>

<h2 id="작동-방식">작동 방식</h2>

<hr />

<p> 위상 정렬 문제는 문제의 세부 조건에 따라 구현 로직이 꽤 크게 달라집니다. 하지만 모든 위상 정렬의 세부 로직은 아래와 같은 큰 로직 안에서 이루어집니다.</p>

<ul>
  <li>각 노드 별로 진입 차수(선행 해야 하는 노드 수)를 구합니다.</li>
  <li>모든 노드를 방문할 때 까지 반복합니다.
    <ul>
      <li>진입 차수가 0인 노드(선행 할 것이 없는 노드)를 방문합니다.</li>
      <li>방문한 노드를 선행 노드로 가지고 있는 노드들의 진입 차수를 1 깎습니다.</li>
    </ul>
  </li>
</ul>

<p> 위의 예시를 보며 설명드리겠습니다.</p>

<p><img src="/public/image/Algorithm/Topological_Sort2.png" alt="Topological_Sort2.png" /></p>

<p> 각 노드의 초기 진입 차수를 기록하고 진입차수가 0인 Java부터 시작합니다.</p>

<p><img src="/public/image/Algorithm/Topological_Sort3.png" alt="Topological_Sort3.png" /></p>

<p> Java를 선행 과목으로 가지고 있던 JPA와 Spring의 진입 차수를 감소 시키고 다음 진입차수가 0인 Oracle을 방문합니다.(물론, Spring 부터 방문할 수도 있습니다.)</p>

<p><img src="/public/image/Algorithm/Topological_Sort4.png" alt="Topological_Sort4.png" /></p>

<p> Oracle을 선행 과목으로 가지고 있던 JPA와 Spring JPA의 진입차수를 감소시킵니다. 다음으론 JPA를 방문합니다.</p>

<p><img src="/public/image/Algorithm/Topological_Sort5.png" alt="Topological_Sort5.png" /></p>

<p> Spring JPA의 진입차수를 감소시키고 Spring에 방문합니다.</p>

<p><img src="/public/image/Algorithm/Topological_Sort6.png" alt="Topological_Sort6.png" /></p>

<p> 마지막으로 Spring JPA에 방문합니다.</p>

<p><img src="/public/image/Algorithm/Topological_Sort7.png" alt="Topological_Sort7.png" /></p>

<p> 우선 순위를 지키며 모든 노드에 방문했습니다.</p>

<h2 id="예제1---dfs를-이용한-구현">예제1 - DFS를 이용한 구현</h2>

<hr />

<p> 위상 정렬의 경우 앞서 말했다싶이 문제의 세부 조건에 따라 다양하게 구현이 가능합니다.</p>

<p> 가장 간단한 방법으론 DFS를 이용하는 것입니다. 앞서 말한 기본 동작과정과는 조금 다른 것 같지만 본질적으론 동일합니다. <a href="https://www.cs.usfca.edu/~galles/visualization/TopoSortDFS.html">https://www.cs.usfca.edu/~galles/visualization/TopoSortDFS.html</a> 를 보시면 DFS를 이용한 동작 과정을 애니메이션으로 볼 수 있습니다.  가장 간단한 방법인 DFS는 진입 차수를 크게 활용하지도 않습니다.(아예 없이 수행할 수도 있습니다.)</p>

<p> 진입 차수가 0인 노드부터 DFS를 수행 하되, 해당 노드에 연결된 후행 노드부터 방문하고 후행 노드들을 모두 방문한 뒤에 해당 노드를 방문합니다. 위의 예시를 보시겠습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5 6
Java Oracle Spring JPA SpringJPA
Oracle SpringJPA
Java JPA
Spring SpringJPA
Oracle JPA
Java Spring
JPA SpringJPA
</code></pre></div></div>

<p> 위와 같은 입력을 줍니다. 첫 줄의 n, m은 노드 수, 간선 수입니다. 다음 줄은 노드 n개의 이름입니다. 다음부터 m개의 줄은 {선행, 후행} 노드입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 노드 갯수, 간선 갯수 입력
</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="c1"># 노드 입력
</span><span class="n">subjects</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>

<span class="c1"># 진입 차수 기록 dictionary
</span><span class="n">indegree</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1"># 간선 기록 dictionary
</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1"># 진입 차수 및 간선 초기화
</span><span class="k">for</span> <span class="n">subject</span> <span class="ow">in</span> <span class="n">subjects</span><span class="p">:</span>
    <span class="n">indegree</span><span class="p">[</span><span class="n">subject</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">edges</span><span class="p">[</span><span class="n">subject</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 간선 입력
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">before</span><span class="p">,</span> <span class="n">after</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
    <span class="n">indegree</span><span class="p">[</span><span class="n">after</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">edges</span><span class="p">[</span><span class="n">before</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>
</code></pre></div></div>

<p> 데이터를 입력받고 진입차수와 간선을 초기화하고, 간선을 입력 받습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># dfs
</span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
        <span class="c1"># 연결된 후행 노드부터 방문
</span>        <span class="k">for</span> <span class="n">next_</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">next_</span><span class="p">]:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">next_</span><span class="p">)</span>
        <span class="c1"># 후행 노드를 모드 방문 후 현재 노드 기록
</span>        <span class="n">visited</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span><span class="p">;</span>
        <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div></div>

<p> DFS는 위와 같은 재귀함수를 이용해 수행합니다. 후행 노드들로 먼저 DFS 재귀 함수를 호출하고, 모든 후행 노드들의 DFS가 끝나면 현재 노드를 위상 순서를 담을 result 배열에 추가합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 방문 노드 기록할 딕셔너리(보통은 배열을 사용하나 노드를 index가 아니라 String으로 받는 바람에..)
</span><span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">subject</span> <span class="ow">in</span> <span class="n">subjects</span><span class="p">:</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">subject</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
    
<span class="c1"># 결과를 담을 배열
</span><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 진입 차수가 0인 노드를 넣어 DFS 수행
</span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">indegree</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
</code></pre></div></div>

<p> 방문 노드를 기록할 딕셔너리를 만듭니다.(보통 탐색에선 배열을 쓰는데 예시에서 노드를 index번호가 아니라 String으로 써버려서…) 결과를 담을 result 배열을 선언해주고 진입 차수가 0인 노드들을 넣어 DFS를 수행해줍니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 결과 출력
</span><span class="n">result</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="c1"># &gt;&gt; ['Oracle', 'Java', 'Spring', 'JPA', 'SpringJPA']
</span></code></pre></div></div>

<p> result 배열엔 가장 깊은 depth부터 들어가 있습니다. 뒤집어주면 위상 순서를 확인할 수 있습니다.</p>

<h2 id="예제2---진입차수-배열-이용">예제2 - 진입차수 배열 이용</h2>

<hr />

<p> 이번엔 처음 살펴본 동작 과정과 더 닮아 있는 구현입니다. 진입차수 배열과 다음에 방문할 노드를 관리할 큐를 사용하는 방법입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 노드 갯수, 간선 갯수 입력
</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">())</span>
<span class="c1"># 노드 입력
</span><span class="n">subjects</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">split</span><span class="p">()))</span>

<span class="c1"># 진입 차수 기록 dictionary
</span><span class="n">indegree</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1"># 간선 기록 dictionary
</span><span class="n">edges</span> <span class="o">=</span> <span class="p">{};</span>
<span class="c1"># 진입 차수 및 간선 초기화
</span><span class="k">for</span> <span class="n">subject</span> <span class="ow">in</span> <span class="n">subjects</span><span class="p">:</span>
    <span class="n">indegree</span><span class="p">[</span><span class="n">subject</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">edges</span><span class="p">[</span><span class="n">subject</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div></div>

<p> 똑같이 입력을 받습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 진입 차수 0인 노드를 관리할 큐
</span><span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="n">indegree_zero_queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
<span class="c1"># 큐에 초기 진입차수 0짜리 입력
</span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">indegree</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">indegree_zero_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div></div>

<p> 방문할 노드를 관리할 큐를 초기화합니다. 해당 큐엔 진입차수가 0인 노드만 들어갈 것입니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 진입차수와 큐를 이용한 위상정렬 수행
</span><span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="n">indegree_zero_queue</span><span class="p">:</span>
    <span class="c1"># 현재 노드를 위상 순서에 추가
</span>    <span class="n">now</span> <span class="o">=</span> <span class="n">indegree_zero_queue</span><span class="p">.</span><span class="n">popleft</span><span class="p">()</span>
    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">now</span><span class="p">)</span>
    <span class="c1"># 현재 노드의 후행 노드를 탐색
</span>    <span class="k">for</span> <span class="n">next_</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">[</span><span class="n">now</span><span class="p">]:</span>
        <span class="c1"># 진입 차수를 1 감소 시키고, 감소된 진입 차수가 0이면 큐에 삽입
</span>        <span class="n">indegree</span><span class="p">[</span><span class="n">next_</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">indegree</span><span class="p">[</span><span class="n">next_</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">indegree_zero_queue</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_</span><span class="p">)</span>
</code></pre></div></div>

<p> 큐에 남은 노드가 없을 때까지(더 이상 방문해야할 노드가 없을 때까지) while문을 수행합니다. 노드 하나를 꺼내 해당 노드를 위상 순서에 추가합니다. 그 후, 해당 노드의 후행 노드들의 진입 차수를 깎고, 깎인 결과 진입차수가 0이 되었으면 방문예정 큐에 추가합니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="c1"># &gt;&gt; ['Java', 'Oracle', 'Spring', 'JPA', 'SpringJPA']
</span></code></pre></div></div>

<p> 결과를 출력합니다. 예제1과는 다른 순서가 나왔지만, 그래도 위상 순서 중 하나입니다.</p>

<p> DFS를 이용한 방법은 재귀적으로 DFS를 구현하기만 하면 되기 때문에 구현이 쉽습니다. 하지만 다양한 문제의 조건에 따라 변형하기엔 힘듭니다. 진입 차수 배열을 이용하는 방법이 문제의 다양한 조건에 대응하기 쉬운 것 같습니다.</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/posts/daily%20thoughts/etc1/">
            퇴사 후 지금까지 정리, L사 합격, 앞으로 블로그 구성 계획
            <small>27 Jun 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/daily%20thoughts/CodingTest-Review/">
            코딩테스트 하루 두 탕...
            <small>13 Jun 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/study/algorithm/Dijkstra/">
            알고리즘 - 다익스트라(Dijkstra) 알고리즘
            <small>12 Jun 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
