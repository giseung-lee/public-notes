<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      HTTP 10 - HTTP/2.0 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/About Me">About Me</a>
      
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Sagyo_Reboot">Sagyo_Reboot</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Twitch_Chat_Analysis">Twitch_Chat_Analysis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/java">java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/jekyll">jekyll</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/linux">linux</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">HTTP 10 - HTTP/2.0</h1>
  <span class="post-date">20 Mar 2020</span>
  
<h3 id="들어가며">들어가며</h3>

<p>HTTP는 계속 발전합니다. HTTP/1.1의 성능 문제를 개선하기 위해 HTTP/2.0이 만들어졌습니다. HTTP/1.1은 1997년 공식적으로 등장했습니다. HTTP/2는 2014년 12월 표준으로 제안되어 2015년 2월 17일 IESG에서 승인됐습니다. 그리고 <strong>2015년 5월 RFC 7540으로 공식적으로 공개</strong>됐습니다.</p>

<p>하지만 이 <strong>책이 서술하는 시점은 2013년 11월으로 HTTP/2.0의 8번째 초안에 대한 내용</strong>입니다.(이전 장에서 책이 처음 서술된건 2002년이라고 했는데, HTTP/2부분은 개정하면서 수정된 것 같습니다.) 따라서 책의 내용과 현재가 다를 수 있습니다.</p>

<hr />

<h3 id="101-http20의-등장배경">10.1. HTTP/2.0의 등장배경</h3>

<p>HTTP의 역사에 대해 알아봤을때 HTTP/1.1은 급하게 기능을 추가한 HTTP/1.0을 정리하는 역할이 컸다고 했습니다. 이렇게 HTTP/1.1은 구현의 단순성과 접근성에 주안점을 두었기 때문에 성능을 희생시킬 수 밖에 없었습니다.</p>

<p>HTTP/1.1에선 요청을 보냈을때 그에 대한 응답을 받아야만 그 다음 요청을 보낼 수 있기 때문에 회전 지연(latency)를 피할 수 없었습니다. 이를 해결하기 위해 병렬 커넥션이나 파이프라인 커넥션을 사용했지만 이는 미봉책이었을 뿐, 근본적인 해답은 되지 못했습니다.</p>

<p>이런 HTTP/1.1의 근본적인 한계를 알고있었는지, HTTP 작업 그룹은 HTTP/1.1이 발표되기도 전인 1997년 7월부터 이미 HTTP/1.1의 이후 버전을 위한 HTTP-NG 프로젝트를 시작했습니다. 그리고 HTTP/1.1의 개발자 중 하나인 로이 필딩(Roy Fielding)은 WAKA라는 프로토콜을 개발했습니다. 또, 마이크로소프트는 S+M(Speed+Mobility)라는 프로토콜을 개발하기 시작했습니다.</p>

<p>구글도 빠질 수 없겠죠. 구글은 2009년에 SPDY(speedy) 프로토콜을 개발해 발표했습니다. HTTP 속도를 개선하기 위해 헤더를 압축해 대역폭을 절약하고, 한 TCP 커넥션에서 응답을 받기 전에 여러 요청을 동시에 보내기도 하고, 요청이 없어도 서버쪽에서 능동적으로 리소스를 푸시할 수도 있습니다.</p>

<p>구글의 SPDY는 회전 지연(latency)를 줄이는데 효과적이었고, 2012년 10월 3일, HTTP 작업 그룹은 SPDY를 기반으로 HTTP/2.0을 공식적으로 설계하기 시작했습니다. HTTP작업 그룹은 SPDY 초안을 그대로 가져와 HTTP/2.0작업에 착수하기 시작했습니다.</p>

<hr />

<h3 id="102-개요">10.2. 개요</h3>

<p>HTTP/2.0 요청과 응답은 길이가 정의된(최대 16383 Byte) 한 개 이상의 프레임에 담깁니다.</p>

<p>프레임에 담긴 요청과 응답은 스트림을 통해 보내지는데, 한 개의 스트림은 한 쌍의 요청과 응답을 처리합니다. 그리고 하나의 TCP 커넥션 위에 여러개의 스트림이 동시에 만들어질 수 있습니다. 즉, 여러 스트림을 사용하면 요청과 응답을 동시에 처리할 수 있게 됩니다.</p>

<p>또한 HTTP/2.0은 이 스트림들에 대한 흐름제어, 우선순위 부여가 가능합니다.</p>

<p>HTTP/2.0엔 기존의 요청-응답이 아닌 ‘서버 푸시’라는 새로운 모델이 등장합니다. 하나의 요청이 있었다면 다음 요청이 없더라도 서버가 추가적으로 리소스를 푸시할 수 있습니다.</p>

<p>물론 HTTP/2.0은 HTTP/1.1과 호환이 될 수 있도록 노력하고 있습니다. 다만, 헤더들의 표현 문법이 조금 달라졌습니다. (ex - Content-Length -&gt; :content-length)</p>

<hr />

<h3 id="103-http11과의-차이점">10.3. HTTP/1.1과의 차이점</h3>

<h4 id="1031-프레임">10.3.1. 프레임</h4>

<p><img src="/public/image/Http The Definitive Guide/http2_frame.png" alt="http2_frame.png" /></p>

<p>https://queue.acm.org/detail.cfm?id=2555617</p>

<p>HTTP/2.0에서 모든 메세지는 위와 같은 프레임에 담겨 전송됩니다. 8바이트 크기의 헤더로 시작해 뒤에 최대 16838 바이트 크기의 페이로드가 옵니다. 프레임 헤더의 각 필드는 다음과 같습니다.(<strong>이 부분이 책과 조금 다른데, 이미지를 찾다 보니 책보다 이후에 업데이트 된 내용인것 같아 위 출처에서 구글링한 내용으로 대체합니다.</strong>)</p>

<ul>
  <li>길이 : 페이로드를 나타내는 16비트 unsigned integer. 이 길이에 프레임 헤더는 포함되지 않습니다.</li>
  <li>종류 : 길이 다음 오는 8비트로 표현된 프레임의 종류입니다.</li>
  <li>플래그 : 프레임의 종류에 따랑 의미가 달라지는 8비트의 플래그입니다.</li>
  <li>R : 예약된 1비트이며 의미가 정의되어있지 않습니다. 항상 0이어야 합니다.</li>
  <li>스트림 식별자 : 31비트의 스트림 식별자입니다. 0일 경우 커넥션 전체와 연관된 프레임임을 의미합니다.</li>
</ul>

<p>HTTP/2.0은 DATA, HEADERS, PRIORITY, RST_STREAM, SETTINGS, PUSH_PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION의 10가지 프레임을 정의하고 있습니다. 각 페이로드 형식이나 내용은 프레임에 따라 다릅니다.</p>

<h4 id="1032-스트림과-멀티플렉싱">10.3.2. 스트림과 멀티플렉싱</h4>

<p>스트림이란 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에 교환되는 프레임들의 양방향 흐름입니다.</p>

<p>한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어집니다. 요청시 새 스트림을 만들어 HTTP 요청을 보내며, 서버는 같은 스트림으로 응답을 보냅니다. 이후 해당 스트림은 닫히게 됩니다.</p>

<p>HTTP/1.1에선 기본적으로 한 TCP커넥션에선 요청을 보낸 후 응답을 받아야 다음 요청을 보낼 수 있었습니다. 한 웹 페이지를 띄우는데 요청이 많이 필요하지 않았던 과거엔 괜찮았습니다. 하지만 현대의 웹 페이지는 한 페이지를 띄우는 데만 해도 적게는 수십, 많게는 수백번의 요청을 주고받아야 합니다. 이는 심각한 회전  지연을 만듭니다.</p>

<p>HTTP/2.0에선 하나의 커넥션에 여러개의 스트림이 동시에 열릴 수 있습니다. 한 페이지를 띄우는데 필요한 여러개의 요청을 응답을 기다릴 필요 없이 동시에 여러 스트림을 열어 보낼 수 있는 것입니니다.</p>

<p>스트림은 우선순위를 가질 수 있습니다. 프레임의 전송이 느릴때, 웹 브라우저는 중요한 리소스를 요청하는 스트림에 우선순위를 부여해 요청할 수 있습니다. (물론, 이 우선순위대로 응답이 올거란 보장은 없습니다.)</p>

<p>모든 스트림은 위에서 몬것과 같이 31비트 고유한 식별자를 갖습니다. 클라이언트에 의해 초기화된 스트림은 이 식별자가 홀수여야 하며, 서버가 초기화한 스트림은 짝수여야 합니다. 그리고 새로 만들어진 스트림의 식별자는 해당 커넥션 안에서 이전에 만들어졌거나 예약된 스트림의 식별자보다 커야 합니다. 이 규칙을 어기는 식별자를 받았다면 PROTOCOL_ERROR 를 돌려줘야 합니다.</p>

<p>서버, 클라이언트 모두 이 스트림은 상대방의 동의 없이 일방적으로 만들 수 있습니다. TCP 커넥션을 여러개 만들때 연결 신호를 주고받느라 소비했던 지연들을 없앨 수 있습니다.</p>

<p>HTTP/2.0 커넥션에서 한 번 사용한 스트림 식별자는 다시 사용할 수 없습니다. 커넥션을 오래 유지하면 스트림의 31비트의 식별자를 모두 사용할 수 있는데, 이땐 커넥션을 다시 맺습니다.</p>

<p>여러개의 스트림을 사용시 스트림이 블록될 우려가 있는데, HTTP/2.0에선 WINDOW_UPDATE 프레임을 이요한 흐름 제어를 통해 스트림들이 서로 간섭해 망가지는 것을 막아줍니다.</p>

<h4 id="1033-헤더-압축">10.3.3. 헤더 압축</h4>

<p>HTTP/1.1은 헤더를 압축 없이 그냥 보냅니다. 따라서 실제 본문보다 헤더의 크기가 더 큰 경우도 허다합니다.</p>

<p>이를 개선하기 위해 HTTP/2.0에선 HTTP 헤더를 압축해 전송합니다. 헤더는 HPACK 명세에 정의된 방법으로 압축된 뒤, ‘헤더 블록 조각’으로 쪼개져 전송됩니다. 받는 쪽은 이 조각들을 이어 압축을 풉니다.</p>

<p>HPACK은 헤더를 압축하고 해제할 때 ‘압축 콘텍스트(compression context)’를 사용합니다. 그런데 이 압축 콘텐스트는 하나의 압축을 풀면 이에 영향을 받아 바뀝니다. 송신측은 메세지를 보낸뒤, 수신측이 이 메세지를 받고 압축을 풀어 압축 콘텍스트가 변경되었을 것이라 추측합니다. 따라서 원활한 통신을 위해선 받은 헤더를 쓰지 않더라도 반드시 합축을 풀어 상호간의 압축 콘텍스트를 유지해야 합니다. 그럴 수 없는 경우라면 COMPREESION_ERROR와 함께 커넥션을 끊어야 합니다.</p>

<h4 id="1034-서버-푸시">10.3.4. 서버 푸시</h4>

<p>HTTP/2.0에선 하나의 요청에 대한 응답으로 여러개의 리소스를 보낼 수 있습니다.(추가 요청이 없어도 일방적으로 응답을 보낼 수 있습니다.) 요청과 응답이 1:1로 대응해야 했던 HTTP/1.1과 달라진 점입니다.</p>

<p>이 방법은 클라이언트에서 어떤 리소스를 추가 요구할 것인지 예측할 수 있는 상황에서 요구합니다. HTTP/1.1에선 하나의 웹페이지를 띄울때 클라이언트가 응답받은 HTML에서 이미지, 파일들의 URL를 얻어내 다시 요청합니다. 하지만 HTTP/2.0에선 서버쪽에서 HTML을 보내기 전에 미리 추가로 필요한 리소스들을 파악해 같이 전송할 수 있습니다.</p>

<p>리소스를 푸시하려는 서버는 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내 미리 알려주어야 합니다. 클라이언트가 PUSH_PROMISE 프레임을 받게 되면 해당 프레임의 스트림은 클라이언트 입장에선 ‘예약됨(원격)’ 상태가 됩니다. 만약 클라이언트가 거절하고 싶다면 RST_STREAM 프레임을 보내면 됩니다.</p>

<p>이 PUSH_PROMISE 프레임을 먼저 주는 이유는 서버가 줄 리소스를 클라이언트가 모르고 요청하는 일을 막기 위해서 입니다.</p>

<p>서버 푸시를 사용할때 주의할 점은 아래와 같습니다.</p>

<ul>
  <li>중간의 프록시가 추가 리소스를 전달하지 않을 수도 있습니다.(서버 푸시가 구현 안됐거나, 정책적으로 막거나) 그리고 프록시 자체적으로도 클라이언트에게 서버 푸시를 할 수 있습니다.</li>
  <li>서버는 안전하고, 캐시가능하고, 본문을 포함하지 않는 요청에 대해서만 푸시할 수 있습니다.</li>
  <li>푸시할 리소스는 클라이언트의 본 요청과 연관되어야 합니다.</li>
  <li>클라이언트는 서버가 푸시한 리소스를 ‘동일 출처 정책’에 따라 검사해야 합니다.</li>
  <li>서버 푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH를 0으로 설정하면 됩니다.</li>
</ul>

<hr />

<h3 id="104-알려진-보안-이슈">10.4. 알려진 보안 이슈</h3>

<h4 id="1041-중개자-캡슐화-공격intermediary-encapsulation-attacks">10.4.1. 중개자 캡슐화 공격(Intermediary Encapsulation Attacks)</h4>

<p>HTTP/2.0 메세지를 프록시가 HTTP/1.1로 변환할때 메세지의 의미가 바뀔 수 있습니다. HTTP/2.0에선 헤더필드의 이름과 값을 바이너리로 인코딩하기 때문에 헤더 필드에 어떤 문자열도 사용할 수 있습니다. 때문에 번역하는 프록시가 의도적으로 헤더를 바꿀 수 있습니다.</p>

<h4 id="1042-긴-커넥션-유지로-인한-개인정보-누출-우려">10.4.2. 긴 커넥션 유지로 인한 개인정보 누출 우려</h4>

<p>HTTP/2.0에선 기본적으로 클라이언트와 서버의 커넥션이 오래 유지될 것이라고 가정합니다. 이 경우에 개인정보 유출의 위험이 있습니다. 예를들어, 사용자가 브라우저를 사용할때 이전 사용자가 무엇을 주고 받았는지 알아낼 수도 있습니다.</p>

<hr />

<h3 id="마치며">마치며</h3>

<p>추가저으로 좋은 링크 (https://developers.google.com/web/fundamentals/performance/http2)[https://developers.google.com/web/fundamentals/performance/http2]</p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/posts/study/msa_ken_krueger/MSA1/">
            Microservices with Spring Cloud 1 - Introduction to Microservices
            <small>21 Apr 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/study/c_kim_pope/C1/">
            C Unmanaged Programming 1 - 과목 소개
            <small>20 Apr 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/projects/sagyo_reboot/Sagyo3/">
            MSA 구조 적용(작성중)
            <small>19 Apr 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
