<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      HTTP 4 - 커넥션 관리 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About%20Me/sidebar_profile.png">
    <div class="sidebar-profile-description">
      <span>
         잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/About%20Me">About Me</a>
      
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily%20Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Sagyo_Reboot">Sagyo_Reboot</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Twitch_Chat_Analysis">Twitch_Chat_Analysis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Algorithm">Algorithm</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http%20The%20Definitive%20Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Java">Java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Spring">Spring</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Data_Structure">Data_Structure</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Network">Network</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      © 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">HTTP 4 - 커넥션 관리</h1>
  <span class="post-date">13 Mar 2020</span>
  
<h3 id="들어가며">들어가며</h3>

<hr>

<h3 id="41-tcp-커넥션">4.1. TCP 커넥션</h3>

<p>이번 장에선 HTTP 통신을 사용하기 위한 기저인 TCP 커넥션에 대해 알아볼 것입니다.</p>

<ul>
  <li>HTTP는 어떻게 TCP 통신을 사용하는지</li>
  <li>네트워크 지연의 원인인 TCP 커넥션의 지연, 병목, 막힘이 무엇인지</li>
  <li>지연을 해결하기 위한 병렬커넥션, keep-alive 커넥션, 커넥션 파이프라인이 무엇인지</li>
  <li>커넥션 관리를 위해 따라야 할 몇 가지 규칙들</li>
</ul>

<p>위와 같은 것들을 알아볼 것입니다.</p>

<hr>

<p>1장에서도 설명드렸듯이 모든 HTTP 통신은 TCP/IP 통신을 기반으로 이루어집니다. HTTP는 데이터가 손실되지 않는 안전한 통신인데, 이 ‘안전한’을 TCP가 보장해줍니다.</p>

<p>TCP/IP 커넥션이 맺어지면 HTTP 메세지들은 손실, 손상되지 않고 순서가 바뀌지도 않습니다. 이번 절에선 TCP/IP가 어떻게 데이터를 보장해주는지알아볼 것입니다.</p>

<p>웹 브라우저 입장에서 TCP 커넥션을 이용한 HTTP 통신은 다음과 같은 과정으로 이루어집니다.</p>

<ol>
  <li>브라우저가 URL에서 호스트 명을 추출합니다. 
(ex - http://www.joes-hardware.com:80/power-tools.html -&gt; www.joes-hardware.com)</li>
  <li>브라우저가 DNS(Domain Name System)을 이용해 호스트명에 대한 IP 주소를 찾습니다. 
(ex - www.joes-hardware.com -&gt; 202.43.78.3)</li>
  <li>브라우저가 URL에서 포트번호를 얻습니다. 
(ex - http://www.joes-hardware.com:80/power-tools.html -&gt; 80)</li>
  <li>브라우저가 호스트명의 포트 번호로 TCP 커넥션을 생성합니다.</li>
  <li>브라우저가 서버로 요청 HTTP메세지를 보냅니다.</li>
  <li>브라우저가 서버에서 온 응답 HTTP 메세지를 읽습니다.</li>
  <li>브라우저가 커넥션을 끊습니다.</li>
</ol>

<h4 id="411-신뢰할-수-있는-데이터-전송-통로인-tcp">4.1.1. 신뢰할 수 있는 데이터 전송 통로인 TCP</h4>

<p>TCP에 대해 깊게 이해하기 위해선 따로 책 한권이 필요할 정도입니다.(저자추천 도서: 『TCP/IP Illustrated』 - W.Richard Stevens)</p>

<p>4.1. 절에선 어떻게 TCP가 작동하고 데이터를 보장하는지 간략히 알아볼 것입니다.</p>

<h4 id="412-tcp-스트림은-세그먼트로-나뉘어-ip-패킷을-통해-전송된다">4.1.2. TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다</h4>

<p>TCP는 HTTP 메세지를 통째로 전송하지 않습니다. IP 패킷(== IP 데이터그램)이라는 작은 조각으로 나눠 데이터를 전송합니다.</p>

<p>패킷이라는 작은 조각으로 나누는 이유는 서킷 통신과 패킷 통신에 대해 알아야 합니다. https://brunch.co.kr/@wangho/6에 정말 잘 정리되어 있습니다. 간단히 말해 기존의 서킷 통신은 전화처럼 연결이 된 상대하고만 통신이 가능하고 그 외의 사람은 연결이 끝날때 까지 기다려야 하는데, 패킷 통신은 각자가 보낸 조각 패킷들을 받아서 조합하기 때문에 한 사람이 어떤 사람과 통신 중에 다른 사람이 끼어들어도 패킷들 사이에 다른 사람의 패킷이 들어올 수 있어 여러명과 통신이 가능하다는 것입니다.</p>

<p>TCP는 HTTP 메세지를 세그먼트라는 단위로 나눠 IP 패킷에 담아 전달합니다. 이 과정은 osi 7계층에서 네트워크 계층, 전송 계층에서 일어나기 때문에 애플리케이션 계층을 다루는 개발자에겐 보이지 않습니다.</p>

<p>IP 패킷은 아래와 같은 그림처럼 이루어져 있습니다.</p>

<p>그림 요망</p>

<p>크게 IP 패킷 헤더(보통 20 Byte), TCP 세그먼트 헤더(보통 20 Byte), TCP 데이터 조각으로 이루어져 있는데 각자의 역할이 있습니다.</p>

<p>IP 패킷 헤더는 발신지에서 목적지로 IP 패킷이 이동하는데 필요한 정보를 가지고 있습니다. 하나의 HTTP 메세지는 여러 IP 패킷으로 잘려 IP 패킷 헤더를 이용해 목적지에 도착합니다. 이때, 도착한 순서나 각 패킷들이 손상 없이 잘 도착했는지는 보장할 수 없습니다.</p>

<p>이걸 보장해주기 위해 필요한게 TCP 세그먼트 헤더입니다. TCP 세그먼트 헤더의 속성들로 조각난 IP 패킷의 순서를 맞추고, 손실된 데이터가 발견되면 해당 데이터를 다시 요청합니다.</p>

<h4 id="413-tcp-커넥션-유지하기">4.1.3. TCP 커넥션 유지하기</h4>

<p>하나의 컴퓨터는 여러개의 TCP 커넥션을 가지고 있습니다. 포트 번호마다 여러개의 커넥션이 생성될 수 있습니다. 이런 여러개의 TCP 커넥션은</p>

<p>&lt;발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트&gt;</p>

<p>위 네가지 값으로 식별됩니다. 네 가지 값이 같다면 같은 커넥션이라고 볼 수 있습니다. 한 포트에 여러 커넥션이 생성될 수 있지만 네 가지 값이 모두 같아야만 같은 커넥션이라고 합니다.</p>

<h4 id="414-tcp-소켓-프로그래밍">4.1.4. TCP 소켓 프로그래밍</h4>

<p>이런 TCP를 개발자가 직접 조작할 수도 있습니다. 이를 도와주는게 각 운영체제에서 지원하는 TCP 관련 API 입니다. 이를 흔히 소켓 API라고 부릅니다. 소켓 API는 유닉스에서 처음 개발됐지만 현재는 대부분의 운영체제에서 지원합니다.</p>

<p>아래는 소켓 API의 주요 인터페이스입니다. 물론 API도 필요 없이 더 저수준의 언어로 TCP를 조작할 수도 있겠지만… 그건 나중에.. 각 운영체제에서 제공하는 소켓 API는 개발자들에게 TCP/IP에 관한 세부사항(핸드셰이킹, IP 패킷의 분할 및 재조립 등 .. )을 숨기지만 TCP/IP를 조작 할 수 있게 도와줍니다.</p>

<table>
  <thead>
    <tr>
      <th>소켓 API</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>s = socket(<parameters>)</parameters>
</td>
      <td>연결되지 않은 익명의 새로운 소켓 생성</td>
    </tr>
    <tr>
      <td>bind(s, <local ip:port="">)</local>
</td>
      <td>소켓에 로컬 IP, 포트 번호와 인터페이스 할당</td>
    </tr>
    <tr>
      <td>connect(s, <remote ip:port="">)</remote>
</td>
      <td>로컬의 소켓과 원격 호스트, 포트 사이에 TCP 커넥션 생성</td>
    </tr>
    <tr>
      <td>listen(s, …)</td>
      <td>커넥션을 받아들이기 위해 로컬 소켓에 허용함을 표시</td>
    </tr>
    <tr>
      <td>s2 = accpet(s)</td>
      <td>누군가 로컬 포트에 커넥션을 맺기 기다림</td>
    </tr>
    <tr>
      <td>n = read(s, buffer, n)</td>
      <td>소켓으로부터 버퍼에 n바이트 읽기 시도</td>
    </tr>
    <tr>
      <td>n = write(s, buffer, n)</td>
      <td>소켓으로부터 버퍼에 n바이트 쓰기 시도</td>
    </tr>
    <tr>
      <td>close(s)</td>
      <td>TCP 커넥션을 완전히 끊음</td>
    </tr>
    <tr>
      <td>shutdown(s, <side>)</side>
</td>
      <td>TCP 커넥션의 입출력만 닫음</td>
    </tr>
    <tr>
      <td>getsockopt(s, …)</td>
      <td>내부 소켓 설정 옵션값을 읽음</td>
    </tr>
    <tr>
      <td>setsockopt(s, …)</td>
      <td>내부 소켓 설정 옵션값을 변경</td>
    </tr>
  </tbody>
</table>

<p>위의 소켓 api를 기반으로 클라이언트와 서버의 TCP 통신을 대략적으로 그려보면 다음과 같습니다.</p>

<table>
  <thead>
    <tr>
      <th>클라이언트</th>
      <th>서버</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td>1. 새로운 소켓을 만든다(socket)</td>
    </tr>
    <tr>
      <td> </td>
      <td>2. 80포트로 소켓을 묶는다(bind)</td>
    </tr>
    <tr>
      <td> </td>
      <td>3. 소켓 커넥션을 허가한다(listen)</td>
    </tr>
    <tr>
      <td> </td>
      <td>4. 커넥션을 기다린다(accept)</td>
    </tr>
    <tr>
      <td>1. 요청 URL에서 IP 주소와 포트를 얻는다</td>
      <td>:</td>
    </tr>
    <tr>
      <td>2. 새로운 소켓을 생성한다(socket)</td>
      <td>:</td>
    </tr>
    <tr>
      <td>3. 서버의 IP:포트로 연결한다(connect)</td>
      <td>:</td>
    </tr>
    <tr>
      <td> </td>
      <td>5. 커넥션 인식 및 연결 확인 메세지를 보낸다.</td>
    </tr>
    <tr>
      <td>4. 연결 성공</td>
      <td>6. 요청을 읽기 시작한다(read)</td>
    </tr>
    <tr>
      <td>5. HTTP 요청을 보낸다(write)</td>
      <td>:</td>
    </tr>
    <tr>
      <td>6. HTTP 응답을 기다린다(read)</td>
      <td>7. 요청 메세지를 처리한다.</td>
    </tr>
    <tr>
      <td>:</td>
      <td>:</td>
    </tr>
    <tr>
      <td>:</td>
      <td>8. 응답을 보낸다.(write)</td>
    </tr>
    <tr>
      <td>7. 응답을 처리한다.</td>
      <td> </td>
    </tr>
    <tr>
      <td>8. 커넥션을 닫는다(close)</td>
      <td>9. 커넥션을 닫는다(close)</td>
    </tr>
  </tbody>
</table>

<hr>

<h3 id="42-tcp의-성능에-대한-고려">4.2. TCP의 성능에 대한 고려</h3>

<p>HTTP는 osi 7계층에서 TCP 바로 위의 계층이기 때문에 HTTP의 성능은 TCP 성능에 직접적으로 영향을 받습니다.</p>

<p>이번 절에선 TCP 성능 (주로 성능 저하의 원인)에 대해 알아볼 것입니다. TCP 프로토콜 내부를 자세히 알아야 하는 절이고 많은 개발자들은 이걸 직접 다룰 일은 드물 것입니다. 하지만 본 스터디는 근본 지식을 위한 스터디이므로 저는 한번 훑어보도록 하겠습니다.</p>

<h4 id="421-http-트랜잭션-지연">4.2.1. HTTP 트랜잭션 지연</h4>

<p>그림 요망</p>

<p>위의 그림과 같이 HTTP 요청을 처리하는 시간은 요청을 전송하고 응답을 전송하는 시간에 비해 짧습니다. 대부분의 HTTP 지연은 TCP 네트워크의 지연 때문에 발생합니다.</p>

<p>HTTP 지연에는 다음과 같은 원인들이 있습니다.</p>

<ol>
  <li>처음 방문하는 호스트의 경우 DNS을 이용해 호스트명을 IP로 변환하는 과정. 과거에는 수십초가 걸림(현재는 인터넷 인프라의 발전으로 대부분 밀리초 단위로 DNS 이름 분석이 끝난다 - 옮긴이)</li>
  <li>새로운 커넥션을 만들고 설정하는 시간. 과거엔 1~2초가 걸림 (역시 인터넷 인프라의 발전으로 대부분 1초 미만으로 끝난다.)</li>
  <li>요청 메세지 전송</li>
  <li>요청 처리 및 응답 메세지 전송</li>
</ol>

<h4 id="422-성능-관련-중요-요소">4.2.2. 성능 관련 중요 요소</h4>

<p>지금부턴 다음과 같은 일반적인 TCP 관련 지연에 대해 살펴봅니다. 고성능의 HTTP 소프트웨어를 개발해야 한다면 각 항목을 모두 이해해야 합니다.</p>

<ol>
  <li>TCP 커넥션의 핸드셰이크 설정</li>
  <li>TCP의 slow start : 본래는 인터넷의 혼잡을 제어하기 위해 사용되지만 지연의 원인이 되기도 합니다.</li>
  <li>Nagle 알고리즘 : 작은 데이터를 모아 한번에 전송하기 위해 만들어진 알고리즘이지만 지연의 원인이 되기도 합니다.</li>
  <li>TCP의 편승(piggyback) 확인응답(acknowledgment)을 위한 확인응답 지연 : 이 역시 확인응답이라는 메세지를 다른 데이터에 편승 시킬 목적이었으나 지연의 원인이 되기도 합니다.</li>
  <li>TIME_WAIT 지연과 포트고갈</li>
</ol>

<h4 id="423-tcp-커넥션-핸드셰이크-지연">4.2.3. TCP 커넥션 핸드셰이크 지연</h4>

<p>핸드셰이크는 악수죠. TCP 커넥션 핸드셰이크는 정말 직관적으로 잘 이해되는 단어 같습니다. 새로운 TCP 커넥션을 맺을 때 두 TCP 소프트웨어는 커넥션을 맺기 위해 IP 패킷을 교환합니다.</p>

<p>다음 그림과 설명은 TCP 커넥션이 핸드셰이크를 하는 순서입니다.</p>

<p>그림 요망</p>

<ol>
  <li>클라이언트는 ‘SYN’이라는 플래그를 가진 작은 TCP 패킷을 보낸다.(40~60 Byte) SYN 플래그는 커넥션 생성 요청을 뜻한다.</li>
  <li>서버가 그 커넥션을 받으면 몇 가지 커넥션 매개변수를 산출해 ‘SYN’과 ‘ACK’ 플래그가 담긴 TCP 패킷을 클라이언트에게 보낸다. SYN+ACK 플래그는 커넥션 생성 요청이 승낙 됐다는 것을 뜻한다.</li>
  <li>SYN+ACK 플래그를 가진 TCP 패킷을 받은 클라이언트는 승낙을 확인했다는 뜻의 ACK 플래그를 가진 확인 응답 신호를 보낸다. 오늘날 TCP는 이 확인 응답 신호를 실질적으로 보내야할 데이터와 같이 보낸다.</li>
</ol>

<p>주고받아야할 데이터의 크기가 작은 HTTP 트랜잭션들은 통신시간의 50%이상을 실제 데이터 전송이 아니라 TCP 커넥션을 구성하는데 사용합니다. (하나의 IP 패킷은 인터넷상에서 수백 바이트, 로컬에선 1500바이트 정도 됩니다.)</p>

<p>이미 존재하는 커넥션을 재활용 하는 방식으로 이런 지연을 최소화 하는데 이는 뒤에서 살펴볼 것입니다.</p>

<h4 id="424-확인응답-지연">4.2.4. 확인응답 지연</h4>

<p>앞서 하나의 HTTP 메세지는 여러 세그먼트단위로 나뉘고 IP 패킷에 담겨 전송되고, TCP는 각 세그먼트의 순서와 손상 여부를 검사한다고 했습니다. 이렇게 HTTP 메세지를 잘 받은걸 확인한 후에 확인응답 패킷을 송신자에게 반환합니다.</p>

<p>그리고 송신자는 특정 시간 안에 확인응답을 받지 못하면 패킷 전송에 오류가 있다는 것으로 간주해 데이터를 다시 전송하게 됩니다.</p>

<p>위 과정에서 보내는 확인응답은 크기가 작습니다. 그래서 보통 TCP는 확인응답이 가야할 방향으로 송출되는 데이터 패킷에 확인응답을 같이 태워보냅니다. 이를 편승(piggyback)시킨다고 부릅니다.</p>

<p>편승하기 위해서 구현된 많은 ‘확인응답 지연’ 알고리즘은 다음과 같이 동작합니다.</p>

<ol>
  <li>보낼 확인응답을 특정시간(0.1~0.2초) 동안 버퍼에 저장한다.</li>
  <li>편승할 송출 데이터 패킷을 찾는다.</li>
  <li>일정 시간 안에 송출 데이터 패킷을 찾지 못하면 확인응답만 별도의 패킷으로 전송한다.</li>
</ol>

<p>서로 데이터 전송이 활발한 커넥션의 경우에 문제가 없겠지만 주고받는게 적은 통신에선 오히려 편승할 데이터 패킷을 찾는 과정에 시간을 버리는 일이 빈번합니다.</p>

<p>운영체제에 따라 이 확인응답 지연 관련 기능을 수정할수도 있지만 조심히 건드려야 할것입니다.</p>

<h4 id="425-tcp-느린-시작slow-start">4.2.5. TCP 느린 시작(slow start)</h4>

<p>TCP의 slow start는 생성 초기엔 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라 속도 제한을 높이는 것입니다. 이는 인터넷의 급작스러운 부하나 혼잡을 방지하기 위해 도입되었습니다.</p>

<p>속도 제한은 한번에 전송 가능한 패킷의 수로 제어 합니다. 패킷이 성공적으로 전달되면 추가로 2개의 패킷을 더 전송할 수 있는 권한을 얻게 됩니다.</p>

<p>2개를 보냈다가 성공적으로 전달되면 다음엔 4개를 보낼 수 있게되는 방식입니다. 이렇게 점진적으로 전달 패킷 양을 늘리는걸 ‘Opening the congestion window’라고 부르고 어느 정도 데이터를 주고 받은 커넥션을 ‘튜닝된’ 커넥션이라고 부릅니다.</p>

<p>새로운 커넥션은 튜닝된 커넥션보다 느리기 때문에(한 번에 보낼 수 있는 최대 패킷수가 제한되기 때문에) 커넥션을 재사용하지 않는다면 TCP의 slow start 때문에 네트워크 지연이 발생할수 있습니다.</p>

<h4 id="426-네이글nagle-알고리즘과-tcp_nodelay">4.2.6. 네이글(Nagle) 알고리즘과 TCP_NODELAY</h4>

<p>앞서 보았듯이 실제로 전송해야할 데이터가 얼마가 되든 IP 패킷으로 전송하기위해선 IP 패킷 헤더, TCP 세그먼트 헤더, 플래그등을 포함합니다. 따라서 전송해야할 데이터가 작다면 실제 보낼 데이터보다 헤더값들이 더 큰 상황이 발생할 수 있습니다.</p>

<p>네이글 알고리즘은 이런 작은 패킷들을 하나로 합쳐 전송하는 역할을 합니다. 네이글 알고리즘은 다음과 같은 순서로 이루어집니다.</p>

<ol>
  <li>전에 전송한 패킷에 아직 확인응답을 못받은 경우 전송할 데이터들을 버퍼에 쌓아둔다.</li>
  <li>쌓아둔 데이터가 세그먼트의 최대크기 만큼 쌓이면 하나의 패킷으로 전송한다.</li>
  <li>전에 전송한 패킷들이 모두 확인응답을 받아 확인응답을 기다리는 패킷들이 없다면, 버퍼에 쌓는 데이터가 세그머느의 최대 크기가 되지 않더라도 하나의 패킷으로 전송한다.</li>
</ol>

<p>네이글 알고리즘 역시 네트워크의 지연을 줄이고자 하는 목적으로 도입됐지만 오히려 네트워크 지연을 발생시키기도 합니다. 앞으로 생길지 말지 모르는 데이터를 하염없이 기다리며 지연됩니다.</p>

<p>그리고 이 네이글 알고리즘은 앞서 본 확인응답 지연과 같이 쓰이면 성능이 매우 떨어지기도 합니다. 확인응답 지연은 패킷을 자주 주고받아 확인응답을 다른 패킷에 편승시켜야 하는데, 네이글 알고리즘은 작은 패킷들은 안보내고 모으고 있으니 서로 역효과를 발생시키게 됩니다.</p>

<p>HTTP 어플리케이션 수준에서 HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하면 네이글 알고리즘을 비활성화 할 수 있습니다.</p>

<h4 id="427-time_wait의-누적과-포트-고갈">4.2.7. TIME_WAIT의 누적과 포트 고갈</h4>

<p>TIME_WAIT의 누적과 포트 고갈은 실제 상황에서 발생할 가능성은 낮지만 발생시엔 심각한 성능 저하를 일으킵니다. 그렇다면 포트고갈은 왜 일어나는 것 인지 알아보겠습니다.</p>

<p>TCP 커넥션의 종단(end-point)에서 TCP 커넥션을 끊으면 커넥션의 IP 주소와 포트번호를 메모리의 제어영역(control block)에 기록해두고 해당 주소와 포트번호는 일정 시간 동안 사용하지 않게합니다. 이를 TIME_WAIT라고 하고 보통 세그먼트의 최대 생명주기의 두배(2MSL) 정도 유지하며 2MSL은 과거엔 2분, 현재는 1분 이내입니다.</p>

<p>TIME_WAIT를 하는 이유는 이전 커넥션과 관련된 패킷이 이전 커넥션과 같은 IP, 포트를 갖는 새로운 커넥션에 들어오는 것을 방지하는 것입니다. 그래서 세그먼트의 생명주기의 두배정도를 기다리는 것입니다.</p>

<p>하지만 요즘엔 라우터들이 향상되어 커넥션이 닫힌 후에 중복 패킷이 생기는 경우는 거의 없습니다.</p>

<p>처음에 이 포트 고갈은 실제 상황에서 발생할 가능성이 낮다고 했습니다. 실제 상황보다 성능 테스트 시에 발생할 가능성이 높습니다. 커넥션에 관해 설명할때</p>

<p>&lt;발신지 IP주소, 발신지 포트, 목적지 IP주소, 목적지 포트&gt;</p>

<p>4가지가 모두 같아야 같은 커넥션이라고 했습니다. 실제 상황에선 한 발신지에서 많은 트랜잭션을 단시간에 보내는 경우는 드물기 때문에 실제론 잘 발생하지 않습니다. 오히려 발신지의 IP와 포트가 제한된 채로 많은 트랜잭션을 발생시켜 테스트하는 성능 테스트 단계에서 발생하기 쉽습니다.</p>

<hr>

<h3 id="43-http-커넥션-관리">4.3. HTTP 커넥션 관리</h3>

<p>이번 절에선 커넥션을 생성하고 최적화하는데 필요한 HTTP 기술을 알아볼 것입니다. HTTP의 Connection 헤더에 대해 알아보고 이를 최적화 하는 방법을 알아 볼 것입니다.</p>

<h4 id="431-흔히-잘못-이해하는-connection-헤더">4.3.1. 흔히 잘못 이해하는 Connection 헤더</h4>

<p>클라이언트의 요청은 바로 목적지 서버로 들어가지 않고 여러 프록시를 거칠 수 있습니다. 이때를</p>

  	클라이언트 - 프록시1 - 프록시2 - 서버

<p>순서로 통신이 이루어진다고 가정하면, 클라이언트와 프록시1 둘 간에만 적용될 옵션을 지정할 수 있습니다. 이를 hop-by-hop 헤더라고 합니다.</p>

<p>HTTP메세지의 Connection헤더는 세가지 종류의 토큰이 올 수 있습니다.</p>

<ol>
  <li>HTTP 헤더 필드 명 : 해당 커넥션에서만 사용되는 HTTP 헤더를 나열합니다. 다음 커넥션에선 해당 HTTP 헤더를 삭제하고 보냅니다.</li>
  <li>임시적인 토큰 : 커넥션에 대한 비표준 옵션입니다.</li>
  <li>close : 커넥션 작업이 완료되면 종료되어야 한다는 뜻입니다.</li>
</ol>

<p>예시를 보겠습니다.</p>

<blockquote>
  <p>HTTP/1.1 200 OK
Cache-control : max-age=3600
Connection : meter, close, bill-my-credit-card
Meter : max-uses=3, max-refuses=6, dont-report</p>
</blockquote>

<p>위는 서버에서 프록시쪽으로 갈 수 있는 응답 메세지 입니다. 이 중 Connection 헤더를 보면 meter 토큰이 있고 아래에 Meter라는 HTTP 헤더가 있습니다. 여기서 meter 헤더는 해당 커넥션에서만 사용되고 다음 커넥션으로 갈땐 Meter 헤더가 삭제 되어야 한다는 뜻입니다.</p>

<p>bill-my-credit-card는 커넥션에서 사용하기 위해 만든 비표준 옵션이라고 볼 수 있습니다.</p>

<p>추가적으로 Connection 헤더에 기술되지 않더라도 기본적으로 hop-by-hop 헤더인 HTTP 헤더들도 있습니다. Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade 같은 헤더들이 그것입니다.</p>

<h4 id="432-순차적인-트랜잭션-처리에-의한-지연">4.3.2. 순차적인 트랜잭션 처리에 의한 지연</h4>

<p>3개의 이미지가 있는 웹페이지를 연다고 가정해보겠습니다. 이 웹페이지를 열기 위해선 4번의 HTTP 트랜잭션이 필요합니다. (HTML을 가져오는 트랜잭션 1개 + 3개의 이미지를 가져오는 각각의 트랜잭션)</p>

<p>각 트랜잭션들이 새로운 커넥션이 필요하다면(HTML과 각 이미지를 호스팅하는 서버가 다르거나 포트가 다를 경우) 핸드셰이킹 지연과 TCP slow start 지연이 추가로 발생합니다.</p>

<p>이렇게 순차적으로 4개의 트랜잭션을 처리할 경우 물리적으로 지연이 발생할 뿐 아니라 사용자 입장에서 이미지가 로드될때까지 빈 화면을 바라봐야 하는 심리적인 지연도 있습니다. (뒤에서 살펴볼 병렬적으로 이미지를 받아오는 방식이 더 느릴때도 있지만 사용자는 그래도 동시에 로드되는걸 좋아한다고 합니다!)</p>

<p>또한 특정 브라우저들의 경우엔 이미지의 크기를 알기 전엔 HTML의 뼈대조차 안그려주는 브라우저도 있습니다. (html 태그 상에서 width와 height를 지정해주면 해결되긴 합니다.)</p>

<p>이렇게 발생하는 지연을 해결하기 위해 아래와 같은 방법들을 사용하고 앞으로 하나씩 알아보겠습니다.</p>

<ol>
  <li>병렬 커넥션 : 여러개의 TCP 커넥션을 통한 동시 HTTP 요청</li>
  <li>지속 커넥션 : 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용</li>
  <li>파이프라인 커넥션 : 공유 TCP 커넥션을 통한 병렬 HTTP 요청</li>
  <li>다중 커넥션 : 요청과 응답들에 대한 중재(아직 실험적인 기술)</li>
</ol>

<hr>

<h3 id="44-병렬-커넥션">4.4. 병렬 커넥션</h3>

<p>병렬 커넥션은 말 그대로 여러개의 커넥션을 맺어 여러개의 HTTP 트랜잭션을 병렬로 처리하는 것입니다. 병렬 ‘커넥션’이기 때문에 가져와야할 리소스가 다른 호스트나 포트에 있어야 합니다.</p>

<h4 id="441-병렬-커넥션은-페이지를-더-빠르게-내려-받는다">4.4.1. 병렬 커넥션은 페이지를 더 빠르게 내려 받는다</h4>

<p>하나의 커넥션은 HTTP 요청을 보내고 응답을 기다립니다. 그 기다리는 시간동안 다른 커넥션을 만들고 다른 요청을 보냅니다. 이렇게 하기 위해선 충분한 인터넷 대역폭이 확보되어야 합니다.</p>

<p>그림 요망</p>

<p>이렇게 인터넷 대역폭이 충분하고 한 커넥션이 지연되는 시간이 있을때, 하나가 지연될때 다른 커넥션을 작동시켜 지연시간을 겹치게 만들 수 있습니다. 이렇게 하면 일반적으론 더 빠르게 웹 페이지를 받아올 수 있습니다.</p>

<h4 id="442-병렬-커넥션이-항상-더-빠르지는-않다">4.4.2. 병렬 커넥션이 항상 더 빠르지는 않다</h4>

<p>하지만 병렬 커넥션이 항상 빠르지는 않습니다. 앞서 말했듯이 충분한 인터넷 대역폭이 확보되어야 하는데 인터넷 대역폭이 극히 작아 하나의 커넥션만으로 버겁다면 병렬적으로 커넥션을 사용할 수 없습니다. (오히려 여러 커넥션을 만들어야 되니 그로 인한 지연이 더 발생할 수 있습니다.)</p>

<p>그리고 커넥션을 여러개 생성하는건 메모리의 문제로 이어질 수도 있습니다.</p>

<p>또한, 복잡한 웹페이지의 경우엔 수십~수백개의 객체를 포함하는데 이를 수백개의 병렬 커넥션으로 연결할 순 없습니다. 서버쪽에서 거부하기 때문에 과도한 수의 커넥션이 맺어지면 서버쪽에서 임의로 끊을 수도 있습니다.</p>

<p>사실 서버쪽에서 거부하기 전에 사용자가 사용하는 브라우저 자체에서 병렬 커넥션의 수를 제한합니다.(최신 브라우저들은 대부분 6~8개의 병렬 커넥션을 지원합니다. - 옮긴이)</p>

<h4 id="443-병렬-커넥션은-더-빠르게-느껴질-수-있다">4.4.3. 병렬 커넥션은 더 빠르게 ‘느껴질 수’ 있다</h4>

<p>이렇게 실제로 병렬 커넥션이 더 느릴 수도 있습니다. 하지만 사용자는 병렬 커넥션을 더 선호합니다. 앞서 말했듯이 빈 화면을 보고있는 것보단 동시에 로드되는 과정을 지켜볼때 사용자는 더 빠르다고 생각합니다.</p>

<p>이렇게 사용자의 심리적인 부분을 고려하는 것도 중요합니다. 옮긴이에 따르면, 이미지 같은 것을 로드할때 처음엔 저화질 이미지를 로드해 보여주고 후에 고화질을 받아 보여주는 방식도 사용자의 심리적인 면을 고려하는 것중 하나라고 합니다.</p>

<hr>

<h3 id="45-지속-커넥션">4.5. 지속 커넥션</h3>

<p>대부분의 웹 사이트를 이용할 때 웹 클라이언트는 같은 사이트에 여러 개의 커넥션을 맺습니다. 하나의 웹 페이지를 띄우기 위해 가져와야할 많은 리소스들이 같은 서버에 있는 경우 그 서버에 또 요청을 하게 됩니다. 이를 ‘site locality’ 라고 부릅니다.</p>

<p>이를 위해 HTTP/1.1에선 처리가 완료된 후에도 TCP 커넥션을 유지합니다. 이를 ‘지속 커넥션’이라고 부르고 지속 커넥션을 이용하면 여러 번 커넥션을 맺을 때 발생할 수 있는 헨드셰이킹 지연, TCP slow start 지연을 방지해 더 빠르게 리소스를 가져올 수 있습니다.</p>

<h4 id="451-지속-커넥션-vs-병렬-커넥션">4.5.1. 지속 커넥션 vs 병렬 커넥션</h4>

<p>병렬 커넥션의 장, 단점은 앞에서 살펴보았고 지속 커넥션의 장점은 방금 살펴보았습니다. 하지만 지속 커넥션이 장점만 갖는건 아닙니다. 지속 커넥션 관리가 제대로 되지 않을 경우, 연결된 상태의 커넥션이 계속 쌓여 클라이언트, 서버 양쪽에 리소스를 낭비할 것입니다.</p>

<p>사실 가장 좋은 방법은 병렬 커넥션과 지속 커넥션을 같이 사용하는 것입니다. 요즘의 많은 웹 어플리케이션은 적은 수의 병렬 커넥션을 사용하며 각 커넥션을 지속 커넥션으로 사용합니다.</p>

<p>쉽게 볼 수 있는 지속 커넥션엔 두 가지가 있습니다. HTTP/1.0+ 에서 사용되는 ‘keep alive’ 커넥션이 있고 HTTP/1.1 에서 사용되는 ‘지속’ 커넥션이 있습니다.</p>

<h4 id="452-http10의-keep-alive-커넥션">4.5.2. HTTP/1.0+의 Keep-Alive 커넥션</h4>

<p>HTTP/1.0에서는 지속 커넥션이 없었습니다. 당시에 실험적인 수준이었던 keep-alive 커넥션을 지원하기 위해 HTTP/1.0+로 확장 됩니다.</p>

<p>keep-alive 커넥션은 처음 등장한 지속 커넥션이어서 그런지 설계상 문제가 있었습니다. 하지만 아직도 많은 클라이언트와 서버들은 keep-alive 커넥션을 사용합니다. (<strong>책이 집필 된 지 오래돼서 아직도 이 문장이 유효한지 잘 모르겠습니다.</strong>)</p>

<p>keep-alive의 설계상 문제는 HTTP/1.1 에서 수정되어 새로운 지속 커넥션으로 바뀌었습니다. 그리고 keep-alive 자체는 HTTP/1.1 명세에 빠졌습니다. 머지않아 레거시로만 남게 될 것 같습니다.</p>

<h4 id="453-keep-alive-동작">4.5.3. Keep-Alive 동작</h4>

<p>keep-alive가 HTTP/1.1 명세에서 공식적으로 빠졌더라도 아직 많은 웹 클라이언트와 서버가 keep-alive를 사용중이고 레거시와의 호환성은 개발자에겐 피할 수 없는 숙명이므로 keep-alive가 어떻게 동작하는지 알아보겠습니다.</p>

<ol>
  <li>클라이언트가 요청시 ‘Connection:Keep-Alive’ 헤더를 포함시킵니다.</li>
  <li>‘Connection:Keep-Alive’헤더를 받은 서버가 이 지속 커넥션을 수락하고자 한다면 응답 메세지에도 ‘Connection:Keep-Alive’헤더 를 포함시킵니다.</li>
  <li>응답 메세지에서 ‘Connection:Keep-Alive’헤더를 확인한 클라이언트는 지속 커넥션을 유지합니다. 만약 응답 메세지에서 ‘Connection:Keep-Alive’를 찾지 못했다면 서버가 커넥션을 끊을 것이라 추정하게 됩니다.</li>
</ol>

<p>여기서 ‘Connection:Keep-Alive’ 헤더는 커넥션을 유지하기 바라는 요청일 뿐이고 해당 헤더를 포함시켰다고 해서 keep-alive 커넥션이 만들어질거라는 보장은 없습니다. 또한, 언제든지 keep-alive 커넥션은 끊어질 수 있습니다.</p>

<h4 id="454-keep-alive-옵션">4.5.4. Keep-Alive 옵션</h4>

<blockquote>
  <p>Connection : Keep-Alive
Keep-Alive : max=5, timeout=120</p>
</blockquote>

<p>위에서 처럼 Keep-Alive 헤더를 추가해 keep-alive에 대한 옵션 사항을 줄 수도 있습니다. 위의 예시에서 max 파라미터는 몇 개의 HTTP 트랜잭션을 처리할 때 까지 커넥션을 유지할 것인지를 나타냅니다. timeout 파라미터는 이 커넥션이 얼마간 유지될 것인지를 나타냅니다. 이 외에도 다양한 파라미터를 사용할 수 있습니다.</p>

<p>하지만 ‘Connection:Keep-Alive’헤더가 keep-alive 커넥션을 보장하지 못하는 것 처럼 Keep-Alive 헤더에 옵션을 적었다고 해서 그렇게 동작할 것이라는 보장은 없습니다.</p>

<p>끝으로 Keep-Alive 헤더는 ‘Connection:Keep-Alive’ 헤더가 있을때만 유효합니다.</p>

<h4 id="455-keep-alive-커넥션-제한과-규칙">4.5.5. Keep-Alive 커넥션 제한과 규칙</h4>

<p>앞에서 살펴본 것들과 뒤에서 살펴볼 keep-alive의 제한이나 규칙등을 정리해보겠습니다.</p>

<ol>
  <li>keep-alive는 기본적으로 적용되는 것이 아닙니다.  Connection:Keep-Alive 요청 헤더를 보내야 합니다.</li>
  <li>keep-alive를 유지하려면 계속 요청과 응답에서 Connection:Keep-Alive 헤더를 유지해야 합니다. 클라이언트가 Connection:Keep-Alive를 보내지 않으면 서버는 keep-alive 커넥션을 끊을 것입니다.</li>
  <li>서버가 Connection:Keep-Alive를 보내지 않으면 클라이언트는 서버가 keep-alive 커넥션을 끊을 것이라 생각합니다.</li>
  <li>keep-alive 커넥션에서 Content-Length의 값을 알려주는 것은 매우 중요합니다. Content-Length를 알아야만 메세지의 끝과 시작점을 알 수 있기 때문입니다.</li>
  <li>정석대로라면 keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프록시와는 연결되면 안됩니다. 뒤에서 설명할 dumb 프록시로 인한 문제가 발생할 수 있기 때문입니다. 하지만 현실적으론 쉽지 않습니다.</li>
  <li>기술적으론 HTTP/1.0 을 따르는 곳에서 오는 모든 Connection 헤더 필드는 무시해야 합니다.</li>
  <li>클라이언트는 응답을 전부 받기 전에 커넥션이 끊어진다면 다시 요청을 보낼 준비를 하고 있어야 합니다.</li>
</ol>

<h4 id="456-keep-alive와-멍청한dumb-프록시">4.5.6. Keep-Alive와 멍청한(dumb) 프록시</h4>

<p>dumb 프록시에 관한 문제는 Connection 헤더를 이해못하는 구형 프록시 때문에 발생합니다. 발생 과정을 살펴보겠습니다.</p>

<ol>
  <li>클라이언트 - dumb proxy - 서버 간의 통신 상황입니다.</li>
  <li>클라이언트가 Connection : Keep-Alive 헤더를 포함한 요청을 보냅니다.</li>
  <li>dumb 프록시는 Connection : Keep-Alive 헤더를 단순히 확장 헤더로 취급하고 서버에 그대로 전달 합니다.
앞서 살펴봤듯이 Connection 헤더는 hop-by-hop 헤더로써, 다음 서버로 전송되면 안됩니다.</li>
  <li>서버는 Connection : Keep-Alive 헤더가 담긴 메세지를 받고 문제가 없는 경우에 keep-alive 커넥션에 동의하고 Connection : Keep-Alive 헤더를 포함한 응답 메세지를 보냅니다.</li>
  <li>dumb 프록시는 이번에도 Connection : Keep-Alive 헤더를 확장 헤더로 취급해 그대로 클라이언트에게 전달합니다.</li>
  <li>그리고 dumb 프록시는 keep-alive를 이해하지 못하기 때문에 서버가 커넥션을 끊기를 기다립니다. 하지만 서버는 keep-alive 커넥션에 동의했기 때문에 커넥션을 끊지 않습니다.</li>
  <li>Connection : Keep-Alive 헤더가 담긴 응답을 받은 클라이언트는 keep-alive가 맺어졌다고 생각하고 다음 요청을 프록시에 보냅니다.
하지만 프록시는 같은 커넥션에서 다른 요청이 또 올거라 예상하지 못하기 때문에 클라이언트의 다음 요청은 무시됩니다. 클라이언트는 계속 기다리게 됩니다.</li>
  <li>dumb 프록시가 중간을 어지럽혔기 때문에 클라이언트나 서버는 타임아웃이 나서 커넥션이 끊길때 까지 기다리게 됩니다.</li>
</ol>

<p>위의 모든 상황은 dumb 프록시가 다음으로 넘기지 말아야 할 Connection 헤더를 넘겨 일어난 일입니다.</p>

<h4 id="457-proxy-connection-살펴보기">4.5.7. Proxy-Connection 살펴보기</h4>

<h4 id="458-http11의-지속-커넥션">4.5.8. HTTP/1.1의 지속 커넥션</h4>

<p>앞에서 많은 시간을 들여 keep-alive 커넥션에 대해 알아봤지만 사실 keep-alive는 deprecated된 기술입니다. HTTP/1.1에선 keep-alive보다 향상된 지속 커넥션을 사용합니다.</p>

<p>HTTP/1.1의 지속 커넥션은 기본적으로 활성화되어 있습니다. keep-alive가 기본적으로 비활성이던 것과는 정반대입니다. HTTP/1.1의 지속 커넥션은 모든 커넥션을 지속 커넥션으로 취급하고, 이를 끊으러면 Connection : close 헤더를 보내야 합니다.</p>

<p>Connection : close 헤더가 없다면 HTTP/1.1을 따르는 웹 어플리케이션들은 지속 커넥션이 유지된다고 생각합니다. 물론, Connection : close를 보내지 않았다고 해서 커넥션이 영원히 유지되는 것은 아닙니다.</p>

<h4 id="459-지속-커넥션의-제한과-규칙">4.5.9. 지속 커넥션의 제한과 규칙</h4>

<p>HTTP/1.1 지속 커넥션의 특징들을 정리하겠습니다.</p>

<ol>
  <li>클라이언트가 Connection : close헤더를 포함한 요청을 보냈다면 그 커넥션으로 추가 요청을 보낼 순 없다.</li>
  <li>클라이언트가 추가적으로 요청을 보내지 않을 것이라면 Connection : close헤더를 포함해 마지막 요청을 보내야 한다.</li>
  <li>메세지에 길이 정보가 있어야 지속 커넥션을 유지 시킬 수 있다. 즉, Content-Length를 가지고나 chunked transfer encoding 되어 있어야 한다.</li>
  <li>HTTP/1.1 프록시는 클라이언트, 서버와 각각 별도의 지속 커넥션을 맺고 관리해야 한다.</li>
  <li>HTTP/1.1 프록시는 클라이언트의 HTTP지원 범위를 모른다면 지속 커녁션을 맺으면 안된다.(하지만 이게 잘 지켜지진 않는다.)</li>
  <li>HTTP/1.1 기기는 Connection : close 헤더와 관계 없이 언제든 커넥션을 끊을 수 있다.</li>
  <li>HTTP/1.1 어플리케이션은 중간에 끊어진 커넥션을 복구할 수 있어야 한다. 다시 보내도 되는 요청이면 다시 보내야 한다.</li>
  <li>클라이언트는 커넥션이 비정상적으로 끊어질 것을 대비해 다시 요청을 보낼 준비가 되어있어야 한다.</li>
  <li>하나의 클라이언트는 서버의 과부하 방지를 위해 두개 정도의 지속 커넥션을 유지해야 한다. n명의 사용자를 상대하기 위해서 프록시나 서버는 2n개의 커넥션을 유지할 수 있어야 한다.</li>
</ol>

<hr>

<h3 id="46-파이프라인-커넥션">4.6. 파이프라인 커넥션</h3>

<blockquote>
  <p>파이프라인 : 컴퓨터 과학에서 파이프라인은 한 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 가리킨다. 이렇게 연결된 데이터처리 단계는 한 단계가 서로 동시에, 또는 병렬적으로 수행될 수 있어 효율성의 향상을 꾀할 수 있다. 각 단계 사이의 입출력을 중계하기 위해 버퍼가 사용될 수 있다.  - [위키백과][https://ko.wikipedia.org/wiki/%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8_(%EC%BB%B4%ED%93%A8%ED%8C%85)]</p>
</blockquote>

<p>HTTP/1.1은 지속 커넥션을 위해 요청을 파이프라이닝 할 수 있습니다. 하나의 요청을 보내고 응답을 기다리는 동안 보낸 요청은 큐에 쌓아두고 새로운 요청을 보내고 또 큐에 쌓는 방식입니다. 대기시간이 긴 네트워크 상황에서 큰 효과를 얻을 수 있습니다.</p>

<p>하지만 파이프라이닝엔 다음과 같은 제약 사항들이 있습니다.</p>

<ol>
  <li>HTTP 클라이어느는 커넥션이 지속 커넥션인지 확인하기 전 까진 파이프라인을 이어서는 안됩니다.</li>
  <li>HTTP 응답은 요청 순서와 같게 와야 합니다. HTTP 메세지는 순번이 매개져 있지 않기 때문에 응답이 무작위로 오면 순서에 맞게 정렬시킬 방법이 없습니다.</li>
  <li>HTTP 클라이언트는 커넥션이 언제 끊어지더라도 실패한 요청을 다시 보낼 수 있어야 합니다.</li>
  <li>POST 요청과 같이 반복해서 보낼때 문제가 생길 수 있는 요청은 파이프라인을 통해 보내면 안됩니다.</li>
</ol>

<hr>

<h3 id="47-커넥션-끊기에-대한-미스터리">4.7. 커넥션 끊기에 대한 미스터리</h3>

<p>커넥션을 관리(특히 언제, 어떻게 커넥션을 끊는지)에는 명확한 기준도 없고 관련한 기술문서도 많지 않습니다.</p>

<h4 id="471-마음대로-커넥션-끊기">4.7.1. ‘마음대로’ 커넥션 끊기</h4>

<p>모든 HTTP 클라이언트, 프록시, 서버는 사실 언제든지 TCP 전송 커넥션을 독자적으로 끊을 수 있습니다. 보통은 메세지를 다 보낸 다음 끊게 되지만 이렇게 마음대로 커넥션을 끊어 버리면 HTTP메세지의 중간이 끊기는것 처럼 다양한 문제가 발생할 수 있습니다.</p>

<h4 id="472-content-length와-truncation">4.7.2. Content-Length와 Truncation</h4>

<p>오래된 HTTP 서버는 ‘커넥션을 끊는다’ == ‘데이터 전송이 끝났다’ 라는 가정하에 개발되어 Content-Length를 가지지 않는 경우가 있습니다.</p>

<p>하지만 모든 HTTP 응답은 엔터티 본문의 크기를 값는 Content-Length헤더를 가지고 있어야 합니다.</p>

<p>만약 클라이언트가 실제 엔터티 본문의 크기와 Content-Length의 값이 다른 응답을 받거나, Content-Length 자체를 받지 못했다면 정확한 길이를 다시 물어봐야 합니다. 이때, 발신자가 캐시 프록시였다면 응답을 캐시하면 안됩니다.</p>

<h4 id="473-커넥션-끊기의-허용-재시도-멱등성">4.7.3. 커넥션 끊기의 허용, 재시도, 멱등성</h4>

<p>앞서 몇번 언급했듯이 커넥션은 에러가 없더라도 언제든지 끊길 수 있습니다. HTTP 어플리케이션들은 이에 대한 대비가 되어있어야 합니다.</p>

<p>클라이언트의 경우 커넥션이 끊겨 실패한 요청을 다시 보낼 수 있어야 합니다. 이 상황은 파이프라인 커넥션에선 좀 더 복잡해집니다. 응답 대기중인 요청은 큐에 쌓여있지만 모든 응답이 오기전에 커넥션이 끊기면 어느 요청들이 처리됐는지 알수 없습니다.</p>

<p>이런 상황에서 요청이 어떤 종류의 요청이었는지는 중요합니다. 몇번을 보내도 서버에 영향을 미치지 않는 요청들(앞서 Safe Method라 배운 GET, HEAD)이나 한 번 실행됐는지, 여러번 실행됐는지에 상관없이 같은 결과를 반환하는 요청들(PUT, DELETE 와 같은)은 여러번 보내도 상관없습니다. 이런 부류의 요청을 ‘멱등(idempotent)한’ 요청이라고 합니다.</p>

<p>POST와 같은 멱등하지 않은 요청을 파이프라인을 통해 요청하다 커넥션이 예상치 못하게 끊어진다면, POST 요청을 다시 보내도 될지 말지 결정할 수 없습니다. 이런 멱등하지않은 요청은 파이프라인 커넥션을 통해 요청하면 안됩니다.</p>

<h4 id="474-우아한-커넥션-끊기">4.7.4. 우아한 커넥션 끊기</h4>

<hr>

<h3 id="마치며">마치며</h3>

<p>커넥션은 어깨너머 들은 지식을 정리하기 보단 새로운 지식으로 받아들이는 시간이었던 것 같습니다. 하지만 이 책의 학습 목표는 이런 웹 서비스가 동작하는데에 대한 깊고 근본적인 지식을 탐구하는 것이기 때문에 매우 재밌습니다! <img class="emoji" title=":smiley:" alt=":smiley:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f603.png" height="20" width="20"></p>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/posts/study/algorithm/Topological-Sort/">
            알고리즘 - 위상정렬(Topological Sort)
            <small>15 Jun 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/daily%20thoughts/CodingTest-Review/">
            코딩테스트 하루 두 탕...
            <small>13 Jun 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/study/algorithm/Dijkstra/">
            알고리즘 - 다익스트라(Dijkstra) 알고리즘
            <small>12 Jun 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
