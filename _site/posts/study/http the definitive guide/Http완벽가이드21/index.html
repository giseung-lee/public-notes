<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      HTTP 21 - 로깅과 사용 추적 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/About Me">About Me</a>
      
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Sagyo_Reboot">Sagyo_Reboot</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Twitch_Chat_Analysis">Twitch_Chat_Analysis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/java">java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/jekyll">jekyll</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/linux">linux</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">HTTP 21 - 로깅과 사용 추적</h1>
  <span class="post-date">02 Apr 2020</span>
  
<h3 id="들어가며">들어가며</h3>

<hr />

<ul>
  <li>앞서 살펴본 거의 모든 서버, 프록시 등은 처리한 HTTP 트랜잭션을 요약해 기록해 놓습니다.</li>
  <li>이번 장에선 기록을 남기는 기술, 로깅에 대해 알아보겠습니다.</li>
</ul>

<h3 id="211-로그란-무엇인가">21.1. 로그란 무엇인가?</h3>

<hr />

<ul>
  <li>로깅을 하는 이유는 크게 두 가지 입니다.
    <ul>
      <li>서버나 프록시가 장애를 일으킬 시 문제와 원인을 찾을 수 있습니다.</li>
      <li>웹 사이트에 대한 통계를 내기 위해 사용할 수 있습니다.</li>
    </ul>
  </li>
  <li>HTTP메세지를 모조리 로깅할 수도 있지만 이런 방식은 쓸모 없는 데이터까지 저장하게 되어 매우 비효율 적입니다.</li>
  <li>일반적으로 로깅하는 항목들은 아래와 같습니다.
    <ul>
      <li>HTTP 메서드</li>
      <li>클라이언트와 서버의 HTTP 버전</li>
      <li>요청받은 URL</li>
      <li>응답의 HTTP 상태 코드</li>
      <li>요청과 응답 메세지의 크기</li>
      <li>트랜잭션이 일어난 시간</li>
      <li>Referer 헤더, User-Agent 헤더</li>
    </ul>
  </li>
</ul>

<h3 id="212-로그-포맷">21.2. 로그 포맷</h3>

<hr />

<ul>
  <li>로그를 남기는 방식에 표준을 만들어 놓으면 다음과 같은 이점이 있습니다.
    <ul>
      <li>로그를 다루는 툴을 만들 수 있습니다.</li>
      <li>로그를 보기 쉬워집니다.</li>
    </ul>
  </li>
  <li>따라서 다양한 로그 포맷 표준들이 존재합니다.</li>
  <li>대부분의 HTTP 애플리케이션은 한 개 이상의 로그 포맷을 지원합니다.</li>
</ul>

<h4 id="2121-일반-로그-포맷common-log-format">21.2.1. 일반 로그 포맷(Common Log Format)</h4>

<ul>
  <li>
    <p>많이 사용되는 로그 포맷중 하나는 말 그대로 ‘일반 로그 포맷’입니다.</p>
  </li>
  <li>
    <p>NCSA(National Center for Supercomputing Applications)에서 처음 정의한 포맷입니다.</p>
  </li>
  <li>
    <p>대부분의 사용 소프트 웨어는 일반 로그 포맷을 지원합니다.</p>
  </li>
  <li>
    <p>아래는 일반 로그 포맷의 필드들입니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>remotehost</td>
          <td>요청한 컴퓨터의 호스트 명 혹은 IP</td>
        </tr>
        <tr>
          <td>username</td>
          <td>ident 검색을 수행했다면, 인증된 요청자의 이름이 존재</td>
        </tr>
        <tr>
          <td>auth-username</td>
          <td>인증을 수행 했다면, 인증된 요청자의 이름이 존재</td>
        </tr>
        <tr>
          <td>timestamp</td>
          <td>요청 날짜와 시간</td>
        </tr>
        <tr>
          <td>request-line</td>
          <td>HTTP 요청의 첫 행을 그대로 기술.</td>
        </tr>
        <tr>
          <td>response-code</td>
          <td>응답의 HTTP 상태코드</td>
        </tr>
        <tr>
          <td>response-size</td>
          <td>응답 엔터티의 Content-Length</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>다음과 같은 로그가 남을 수 있습니다.</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>209.1.32.44 - - [03/Oct/1999:14:16:00 -0400] "GET / HTTP/1.0" 200 1024 
http-guide.com - dg [03/Oct/1999:14:16:32 -0400] "GET / HTTP/1.0" 200 477
http-guide.com - dg [03/Oct/1999:14:16:32 -0400] "GET /foo HTTP/1.0" 404 0 
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 로그를 파싱하면 아래와 같이 나뉘어 집니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>로그1</th>
          <th>로그2</th>
          <th>로그3</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>remotehost</td>
          <td>209.1.32.44</td>
          <td>http-guide.com</td>
          <td>http-guide.com</td>
        </tr>
        <tr>
          <td>username</td>
          <td><비어있음></비어있음></td>
          <td><비어있음></비어있음></td>
          <td><비어있음></비어있음></td>
        </tr>
        <tr>
          <td>auth-username</td>
          <td><비어있음></비어있음></td>
          <td>dg</td>
          <td>dg</td>
        </tr>
        <tr>
          <td>timestamp</td>
          <td>03/Oct/1999:14:16:00 -0400</td>
          <td>03/Oct/1999:14:16:32 -0400</td>
          <td>03/Oct/1999:14:16:32 -0400</td>
        </tr>
        <tr>
          <td>request-line</td>
          <td>GET / HTTP/1.0</td>
          <td>GET / HTTP/1.0</td>
          <td>GET /foo HTTP/1.0</td>
        </tr>
        <tr>
          <td>response-code</td>
          <td>200</td>
          <td>200</td>
          <td>404</td>
        </tr>
        <tr>
          <td>response-size</td>
          <td>1024</td>
          <td>477</td>
          <td>0</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="2122-혼합-로그-포맷combined-log-format">21.2.2. 혼합 로그 포맷(Combined Log Format)</h4>

<ul>
  <li>
    <p>혼합 로그 포맷 역시 자주 사용되는 로그 포맷입니다.</p>
  </li>
  <li>
    <p>일반 로그 포맷과 매우 유사하며 필드 2개가 추가된 것이 전부입니다.</p>
  </li>
  <li>
    <p>아래는 추가된 2개의 필드입니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Referer</td>
          <td>Referer HTTP 헤더의 값</td>
        </tr>
        <tr>
          <td>User-Agent</td>
          <td>User-Agent Referer HTTP 헤더의 값</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>아래와 같은 로그가 남을 수 있습니다.(한 줄의 로그 입니다.)</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>209.1.32.44 - - [03/Oct/1999:14:16:00 -0400] "GET / HTTP/1.0" 200 1024 "http://www.joeshardware.com/" "5.0: Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)" 
</code></pre></div>    </div>
  </li>
  <li>
    <p>이 로그에서 Referer와 User-Agent는 다음에 해당합니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>로그1</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Referer</td>
          <td>http://www.joeshardware.com/</td>
        </tr>
        <tr>
          <td>User-Agent</td>
          <td>5.0: Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="2123-넷스케이프-확장-로그-포맷">21.2.3. 넷스케이프 확장 로그 포맷</h4>

<ul>
  <li>
    <p>넷스케이프 확장 로그 포맷은 일반 로그 포맷에서 시작해 <strong>프록시나 웹 캐시 같은 HTTP 애플리케이션을 지원하기 위해</strong> 확장되었습니다.</p>
  </li>
  <li>
    <p>일반 로그 포맷의 7개 필드를 제외하고 확장된 필드들은 다음과 같습니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>proxy-response-code</td>
          <td>트랜잭션이 프록시를 거칠 경우, 서버에서 프록시로의 HTTP 응답 코드</td>
        </tr>
        <tr>
          <td>proxy-response-size</td>
          <td>트랜잭션이 프록시를 거칠 경우, 서버에서 프록시로의 응답 엔터티 Content-Length</td>
        </tr>
        <tr>
          <td>client-request-size</td>
          <td>클라이언트가 프록시로 보내는 요청의 본문이나 엔터티의 Content-Length</td>
        </tr>
        <tr>
          <td>proxy-request-size</td>
          <td>트랜잭션이 프록시를 거칠 경우, 프록시가 서버로 보내는 요청의 본문이나 엔터티의 Content-Length</td>
        </tr>
        <tr>
          <td>client-request-hdr-size</td>
          <td>클라이언트의 요청 헤더의 바이트 길이</td>
        </tr>
        <tr>
          <td>proxy-response-hdr-size</td>
          <td>트랜잭션이 프록시를 거칠 경우, 프록시가 요청자에게 보내는 응답 헤더의 바이트 길이</td>
        </tr>
        <tr>
          <td>proxy-request-hdr-size</td>
          <td>트랜잭션이 프록시를 거칠 경우, 프록시가 서버로 전송하는 요청 헤더의 바이트 길이</td>
        </tr>
        <tr>
          <td>server-response-hdr-size</td>
          <td>서버 응답 헤더의 바이트 길이</td>
        </tr>
        <tr>
          <td>proxy-timestamp</td>
          <td>트랜잭션이 프록시를 거칠 경우, 요청과 응답이 프록시를 통해 오가는 총 시간(초)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>다음과 같은 로그가 남을 수 있습니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>209.1.32.44 - - [03/Oct/1999:14:16:00-0400] "GET / HTTP/1.0" 200 1024 200 1024 0 0 215 260 279 254 3
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 로그를 파싱하면 확장된 필드들은 아래와 같은 값을 갖습니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>로그1</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>proxy-response-code</td>
          <td>200</td>
        </tr>
        <tr>
          <td>proxy-response-size</td>
          <td>1024</td>
        </tr>
        <tr>
          <td>client-request-size</td>
          <td>0</td>
        </tr>
        <tr>
          <td>proxy-request-size</td>
          <td>0</td>
        </tr>
        <tr>
          <td>client-request-hdr-size</td>
          <td>215</td>
        </tr>
        <tr>
          <td>proxy-response-hdr-size</td>
          <td>260</td>
        </tr>
        <tr>
          <td>proxy-request-hdr-size</td>
          <td>279</td>
        </tr>
        <tr>
          <td>server-response-hdr-size</td>
          <td>254</td>
        </tr>
        <tr>
          <td>proxy-timestamp</td>
          <td>3</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="2124-넷스케이프-확장-2-로그-포맷">21.2.4. 넷스케이프 확장 2 로그 포맷</h4>

<ul>
  <li>
    <p>넷스케이프 확장 2 로그 포맷은 넷스케이프 확장 로그 포맷을 확장한 것입니다.</p>
  </li>
  <li>
    <p>넷스케이프 확장 로그 포맷에 있는 필드를 제외하고 새로 확장된 필드들은 다음과 같습니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>route</td>
          <td>프록시가 클라이언트에 요청을 만드는데 사용하는 경로</td>
        </tr>
        <tr>
          <td>client-finish-status-code</td>
          <td>넷스케이프 확장 2 로그 포맷에서 정의한 클라이언트의 종료 상태 코드</td>
        </tr>
        <tr>
          <td>proxy-finish-status-code</td>
          <td>넷스케이프 확장 2 로그 포맷에서 정의한 프록시의 종료 상태 코드</td>
        </tr>
        <tr>
          <td>cache-result-code</td>
          <td>넷스케이프 확장 2 로그 포맷에서 정의한 캐시 결과 코드</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>route 엔 다음과 같은 값이 가능합니다.</p>

    <ul>
      <li>DIRECT : 리소스를 서버에서 바로 가져옴</li>
      <li>PROXY(host:port) : 리소스를 host 라는 프록시를 통해 가져옴</li>
      <li>SOCKS(socks:port) : 리소스를 host라는 SOCKS 서버를 통해 가져옴</li>
    </ul>
  </li>
  <li>
    <p>client-finish-status-code, proxy-finish-status-code 엔 다음과 같은 코드가 존재합니다.</p>

    <ul>
      <li>- : 요청이 시작되지 않음</li>
      <li>FIN : 요청이 성공적으로 완료됨</li>
      <li>INTR : 요청이 클라이언트에 의해 중단 되었거나 프록시/서버에 의해 종료됨</li>
      <li>TIMEOUT : 요청이 프로시/서버의 타임아웃에 걸림</li>
    </ul>
  </li>
  <li>
    <p>cache-result-code엔 다음과 같은 코드가 쓰입니다.</p>

    <ul>
      <li>- : 캐시할 수 없는 리소스</li>
      <li>WRITTEN : 리소스를 캐시에 저장함</li>
      <li>REFRESHED : 리소스를 캐시했고 갱신함</li>
      <li>NO-CHECK : 캐시된 리소스를 반환했고 신선도 검사를 하지 않음</li>
      <li>UP-TO-DATE : 캐시된 리소스를 반환했고 신선도 검사를 완료함</li>
      <li>HOST-NOT-AVAILABLE : 캐시된 리소스를 반환했으며, 원격 서버가 사용할 수 있는 상태가 아니었기 때문에 신서도 검사를 하지 않음</li>
      <li>CL-MISMATCH : 리소스를 캐시에 저장하지 않았다. Content-Length가 리소스의 크기와 맞지 않았기 때문에 쓰기를 중단함.</li>
      <li>ERROR : 어떤 에러 때문에 리소스를 캐시에 저장하지 못했다.</li>
    </ul>
  </li>
  <li>
    <p>다음과 같은 로그를 남길 수 있습니다.</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>209.1.32.44 - - [03/Oct/1999:14:16:00-0400] "GET / HTTP/1.0" 200 1024 200 1024 0 0 215 260 279 254 3 DIRECT FIN FIN WRITTEN 
</code></pre></div>    </div>
  </li>
  <li>
    <p>확장된 필드들은 다음과 같이 파싱됩니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>route</td>
          <td>DIRECT</td>
        </tr>
        <tr>
          <td>client-finish-status-code</td>
          <td>FIN</td>
        </tr>
        <tr>
          <td>proxy-finish-status-code</td>
          <td>FIN</td>
        </tr>
        <tr>
          <td>cache-result-code</td>
          <td>WRITTEN</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h4 id="2125-스퀴드squid-프록시-로그-포맷">21.2.5. 스퀴드(Squid) 프록시 로그 포맷</h4>

<ul>
  <li>
    <p>스퀴드 프록시 캐시(<a href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>)는 유명한 오픈소스 프록시 캐시 프로젝트입니다.</p>
  </li>
  <li>
    <p>스퀴드 프록시 로그 포맷은 스퀴드 프록시 캐시에서 사용되는 로그 포맷입니다.</p>
  </li>
  <li>
    <p>앞서 살펴본 일반 로그 포맷을 원류로한 로그들과는 필드의 구성과 순서가 좀 다릅니다.</p>
  </li>
  <li>
    <p>다음과 같은 필드가 존재합니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>timestamp</td>
          <td>GMT 기준 1970년 1월 1일 부터 요청이 도착한 시간까지의 시간을 초 단위로 기술</td>
        </tr>
        <tr>
          <td>time-elapsed</td>
          <td>요청과 응답이 프록시를 통해 오고간 총 시간을 밀리초 단위로 기술</td>
        </tr>
        <tr>
          <td>host-ip</td>
          <td>클라이언트의 호스트 장비 IP 주소</td>
        </tr>
        <tr>
          <td>result-code/status</td>
          <td>result code는 요청에 대해 어떤 일을 했는지를 squid result code로 기술. status는 HTTP 응답 코드</td>
        </tr>
        <tr>
          <td>size</td>
          <td>프록시가 클라이언트에게 보낸 HTTP 응답 헤더와 본문을 포함한 응답 길이가 바이트 단위로 기술됨</td>
        </tr>
        <tr>
          <td>method</td>
          <td>클라이언트 요청의 HTTP 메서드</td>
        </tr>
        <tr>
          <td>url</td>
          <td>클라이언트 요청의 URL</td>
        </tr>
        <tr>
          <td>rfc931-ident</td>
          <td>클라이언트에 인증된 사용자 이름</td>
        </tr>
        <tr>
          <td>hierarchy/from</td>
          <td>프록시가 클라이언트로 요청을 봬며 거친 경로를 기술.</td>
        </tr>
        <tr>
          <td>content-type</td>
          <td>프록시 응답 엔터티의 Content-Type</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>squid result code는 꽤나 많기 때문에 링크를 남기겠습니다. <a href="https://wiki.squid-cache.org/SquidFaq/SquidLogs#Squid_result_codes">https://wiki.squid-cache.org/SquidFaq/SquidLogs#Squid_result_codes</a></p>
  </li>
  <li>
    <p>스퀴드 로그 포맷을 사용한다고 해서 위 링크의 모든 result code를 구현하는 것은 아닙니다.</p>
  </li>
  <li>
    <p>스퀴드 로그 포맷은 다음과 같은 로그를 남길 수 있습니다.</p>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>99823414 3001 209.1.32.44 TCP_MISS/200 4087 GET http://www.joes-hardware.com - DIRECT/proxy.com text/html 
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 로그를 파싱하면 각 필드는 다음과 같은 값을 갖습니다.</p>

    <table>
      <thead>
        <tr>
          <th>필드</th>
          <th>로그1</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>timestamp</td>
          <td>99823414</td>
        </tr>
        <tr>
          <td>time-elapsed</td>
          <td>3001</td>
        </tr>
        <tr>
          <td>host-ip</td>
          <td>209.1.32.44</td>
        </tr>
        <tr>
          <td>result-code/status</td>
          <td>TCP_MISS/200</td>
        </tr>
        <tr>
          <td>size</td>
          <td>4087</td>
        </tr>
        <tr>
          <td>method</td>
          <td>GET</td>
        </tr>
        <tr>
          <td>url</td>
          <td>http://www.joes-hardware.com</td>
        </tr>
        <tr>
          <td>rfc931-ident</td>
          <td>-</td>
        </tr>
        <tr>
          <td>hierarchy/from</td>
          <td>DIRECT/proxy.com</td>
        </tr>
        <tr>
          <td>content-type</td>
          <td>text/html</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="213-적중-계량하기">21.3. 적중 계량하기</h3>

<hr />

<ul>
  <li>앞서 말했듯이 로그는 에러를 진단하거나, 웹 사이트에 대한 통계를 내어 여러 용도로 사용하기 위해 남겨집니다.</li>
  <li>하지만 캐시가 사용된다면 클라이언트의 요청은 서버까지 오지 못하고 캐시에서 처리 됩니다.</li>
  <li>그렇다면 정확한 통계가 이루어지지 않습니다. 이와 같은 상황은 어떻게 해결할까요?</li>
  <li>중요한 문서들에 대해 캐시를 하지 않아 버릴 수도 있습니다. 모든 요청은 서버로 가게되고 정확한 통계를 낼 수 있습니다. 하지만 이렇게 되면 응답시간이 길어지고 서버의 부하가 증가합니다.</li>
  <li>대신 캐시에도 로그가 쌓일테니 캐시의 로그를 주기적으로 원 서버에 보내면 어떨까요? 이런 방법을 적중 계량(Hit Metering) 이라고 합니다.</li>
  <li>적중 계량은 HTTP의 확장으로 RFC 2227에서 정의되었습니다.</li>
</ul>

<h4 id="2131-개요">21.3.1. 개요</h4>

<ul>
  <li>적중 계량 규약은 캐시와 서버가 접근 정보를 공유하고 캐시의 리소스 양을 제어할 수 있는 몇가지 기능을 정의합니다.</li>
  <li>적중 계량은 캐시에서 요청이 끝남으로서 발생되는 문제를 완벽히 해결해주진 않지만 어느정도로 서버가 원하는 정보를 제공해 줄 순 있습니다.</li>
  <li>적중 계량을 사용하면 캐시를 이용해 성능을 높이면서도 서버에서 정확한 접근 통계를 낼 수 있습니다.</li>
</ul>

<h4 id="2132-meter-헤더">21.3.2. Meter 헤더</h4>

<ul>
  <li>
    <p>적중 계량을 위해선 Meter 라는 헤더가 사용됩니다.</p>
  </li>
  <li>
    <p>Meter 헤더에 다양한 지시자와 값들을 통해 적중 계량을 구현할 수 있습니다.</p>
  </li>
  <li>
    <p>다음은 Meter 헤더에 사용 될 수 있는 지시자들 입니다.</p>

    <table>
      <thead>
        <tr>
          <th>지시자</th>
          <th>약어</th>
          <th>주체</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>will-report-and-limit</td>
          <td>w</td>
          <td>캐시</td>
          <td>캐시는 사용량을 보고하고 서버가 기술한 사용제한에 복종함</td>
        </tr>
        <tr>
          <td>wont-report</td>
          <td>x</td>
          <td>캐시</td>
          <td>캐시는 사용 제한에 복종하지만, 사용량 보고는 하지 않음</td>
        </tr>
        <tr>
          <td>wont-limit</td>
          <td>y</td>
          <td>캐시</td>
          <td>캐시는 사용량 보고를 하지만 사용 제한은 없음</td>
        </tr>
        <tr>
          <td>count</td>
          <td>c</td>
          <td>캐시</td>
          <td>“사용횟수/재사용횟수” 로 기술되는 보고 지시자. “:count=2/4”와 같이 쓰인다.</td>
        </tr>
        <tr>
          <td>max-uses</td>
          <td>u</td>
          <td>서버</td>
          <td>서버가 캐시를 사용해 응답할 수 있는 최대 횟수를 기술. “max-uses=100” 과 같이 쓰임</td>
        </tr>
        <tr>
          <td>max-reuses</td>
          <td>r</td>
          <td>서버</td>
          <td>서버가 캐시를 재사용해 응답할 수 있는 최대 횟수를 기술. “max-reuses=100”과 같이 쓰임</td>
        </tr>
        <tr>
          <td>do-report</td>
          <td>d</td>
          <td>서버</td>
          <td>서버가 프록시에게 사용량 보고를 요구함</td>
        </tr>
        <tr>
          <td>dont-report</td>
          <td>e</td>
          <td>서버</td>
          <td>서버가 사용량 보고를 원하지 않음</td>
        </tr>
        <tr>
          <td>timeout</td>
          <td>t</td>
          <td>서버</td>
          <td>서버가 리소스를 계량할 때 시간제한을 거는데 사용. 캐시는 해당 타임아웃 정각이나 1분 전후로 보고를 해야함. “timeout=60”과 같이 쓰임</td>
        </tr>
        <tr>
          <td>wont-ask</td>
          <td>n</td>
          <td>서버</td>
          <td>서버는 계량 정보를 원하지 않음.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>아래 그림은 Meter 헤더가 사용되는 과정을 나타냅니다.</p>
  </li>
</ul>

<p><img src="/public/image/Http The Definitive Guide/meter_example.png" alt="meter_example.png" /></p>

<ul>
  <li>클라이언트 입장에선 변하는게 없습니다. 프록시가 서버로 요청을 보낼때 ‘will-report-and-limit’을 보내 사용량을 보고하며 사용 제한에 복종한다고 말합니다.</li>
  <li>서버는 프록시에게 리소스를 건네주며 ‘do-report’를 지시했습니다.</li>
  <li>프록시는 클라이언트에게 리소스를 건네줍니다.</li>
  <li>이후 시간이 흘러 프록시가 갖은 리소스가 신선하지 않아 재검사를 보낼때 Meter에 적중 횟수를 보고 합니다.</li>
</ul>

<h3 id="214-개인-정보-보호에-대해">21.4. 개인 정보 보호에 대해</h3>

<hr />

<ul>
  <li>한편, 로깅은 본래 선의의 목적으로 사용되지만 악용 될 수도 있습니다.</li>
  <li>웹 사이트의 사용 기록을 몰래 매매할 수도 있고 수집한 로그로 개인의 사생활을 엿볼 수도 있습니다.</li>
  <li>로그를 다루는 개발자라면 항상 이 점을 염두해 두어야 할 것입니다.</li>
</ul>

<h3 id="마치며">마치며</h3>

<hr />

<ul>
  <li>웹 프로젝트를 할 때 로그는 프레임워크가 해주는대로 ‘알아서 잘 남겠거니’하고 지나쳤었습니다.</li>
  <li>이번 장을 학습한 이후로는 좀 더 적극적으로 로그를 남기고 사용할 수 있을 것 같습니다.</li>
</ul>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/posts/study/c_kim_pope/C3/">
            C Unmanaged Programming 2 - C언어 기본 문법2 - 1 (작성중)
            <small>23 Apr 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/study/msa_ken_krueger/MSA2/">
            Microservices with Spring Cloud 2 - Modern Spring - Spring Boot, Spring Data, and Spring Data REST
            <small>22 Apr 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/daily%20thoughts/%EC%98%81%EC%96%B4%EA%B3%B5%EB%B6%80/">
            영어 공부를 더 해야겠다.
            <small>22 Apr 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
