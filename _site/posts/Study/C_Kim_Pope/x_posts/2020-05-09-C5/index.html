<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      C Unmanaged Programming 5 - C 스타일 문자열, 출력 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/About Me">About Me</a>
      
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Sagyo_Reboot">Sagyo_Reboot</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Twitch_Chat_Analysis">Twitch_Chat_Analysis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Algorithm">Algorithm</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Java">Java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Spring">Spring</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Data_Structure">Data_Structure</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Network">Network</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">C Unmanaged Programming 5 - C 스타일 문자열, 출력</h1>
  <span class="post-date"></span>
  
<ul>
  <li>
    <p>해당 포스팅은 <a href="https://www.udemy.com/course/c-unmanaged-programming-by-pocu/">Kim Pope 선생님의 C 언매니지드 프로그래밍 강의</a>를 정리하며 사견을 붙인 것입니다.</p>
  </li>
  <li>
    <p>포스팅 내 목차는 동영상강의 기준입니다.</p>
  </li>
</ul>

<h2 id="141-문자열의-표현과-길이">141. 문자열의 표현과 길이</h2>

<hr />

<ul>
  <li>C에는 자체적인 문자열이 없습니다. 하지만 C만의 문자열 표현법이 있습니다. 이를 ‘C 스타일 문자열’이라고 합니다.</li>
  <li>처음엔 매우 혁신적인 방법이었고, 지금도 많은 C 계열 언어의 문자열이 내부적으론 C 스타일 문자열로 구현이 되어 있습니다.</li>
  <li>기술 면접에서 기본기로 많이 물어보기도 합니다.</li>
  <li>문자열과 다른 기본 자료형의 차이
    <ul>
      <li>기본 자료형에서 중요했던건 자료형의 <strong>크기와 범위!</strong></li>
      <li>기본 자료형에선 자료형의 크기와 범위가 고정되어 있었습니다.</li>
      <li>근데 문자열의 크기는…? 매번 달라집니다. 그렇기 때문에 문자열은 기본 자료형에 포함시키지 못합니다.</li>
    </ul>
  </li>
  <li>보통 ‘문자열’이라고 부릅니다. ‘문장’이라는 말도 있는데. ‘문자열’이라고 표현하는 이유가 C에서 문장은 ‘문자’들의 배열로 표현되기 때문입니다.</li>
  <li>그런데 배열 자체에선 배열의 길이를 저장하지 않습니다. 따라서 프로그래머가 따로 배열의 길이를 기억해줘야 합니다. (함수에 배열 넘길 때 배열 길이 계산해서 같이 넘긴 것 처럼 말이죠.)</li>
</ul>

<h2 id="142-문자열-관리-시-길이의-문제">142. 문자열 관리 시 길이의 문제</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print_str</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">char</span> <span class="n">chars</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"I want to be Programmer"</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">NUM_CHARS</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="cm">/* 일일이 구해줘야 한다! */</span>
	
	<span class="n">site_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NUM_CHARS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="n">chars</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>위 코드처럼 문자열의 길이를 하드코딩 해두면 문자열이 달라질때 마다 바꿔줘야 합니다. 하지만… 사람은 항상 실수를 하기 때문에 이를 매번 꼼꼼히 관리하지 못해 버그가 발생합니다.</li>
</ul>

<h2 id="143-문자열-길이-문제-해결방법1">143. 문자열 길이 문제 해결방법1</h2>

<hr />

<ul>
  <li>매번 문자열의 길이를 관리하긴 힘드니까 개발자들은 여러 방법을 탐색합니다.</li>
</ul>

<h3 id="작전1--길이를-배열-첫-위치에-저장1">작전1 : 길이를 배열 첫 위치에 저장(1)</h3>

<ul>
  <li>문자열 첫 메모리 위치에 문자열의 길이를 저장하고 뒤에 실제 문자열이 뒤 따라오게 하는 방법이 있습니다.</li>
  <li>하지만 이 방법엔 문제가 있습니다. unsigned char로 저장할 수 있는 최대 숫자는 255입니다. 근데 문자열이 255자가 넘지 말라는 법은 없습니다.</li>
</ul>

<h3 id="작전1--길이를-배열-첫-위치에-저장2">작전1 : 길이를 배열 첫 위치에 저장(2)</h3>

<ul>
  <li>
    <p>그러면 길이를 저장하는 곳은 int형으로 해두면 되지 않을까요?? signed int만 해도 21억 어느정도가 되기 때문에 말이죠.</p>
  </li>
  <li>
    <p>실제로 다른 언어들에선 이 방법을 씁니다. (C#같은..)</p>
  </li>
  <li>
    <p>그런데 이 방법의 단점이 있습니다.</p>

    <ul>
      <li>
        <p>실제 저장할 문자열은 1바이트인데 여기에 길이 저장에만 4바이트를 쓰는 일이 발생할 수도 있습니다.</p>
      </li>
      <li>
        <p>그리고 더 큰 문제는 순수 C 코드로 이걸 작성하는 방법이 애매하기 때문입니다.</p>

        <ul>
          <li>
            <p>첫 데이터는 int*로 캐스팅해서 읽고 다음부턴 char*로 읽어야 합니다. 가능은 하고, 실제로 이진 데이터 수준에선 이런 방법을 쓰지만 이걸 언어로 삼기엔… 아래와 같은 일이..</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">array</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span> <span class="cm">/* 0~3 4바이트엔 문자열 길이 5, 4~8 5바이트엔 "HELLO"가 들어있는 문자열 */</span>
      
<span class="kt">int</span><span class="o">*</span> <span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* array[0]번째 주소를 int*로 캐스팅해 길이를 읽습니다. */</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* array[4] 부터는 char*로 "HELLO"를 읽습니다.*/</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="144-문자열-길이-문제-해결방법-2-c-스타일-문자열">144. 문자열 길이 문제 해결방법 2, C 스타일 문자열</h2>

<hr />

<h3 id="작전2--문자열이-끝나는-위치를-표시">작전2 : 문자열이 끝나는 위치를 표시</h3>

<ul>
  <li>다른 방법으론 char[] 만 쓰되, 문자열이 끝나는 위치에 특수한 문자를 두는 방법을 생각할 수 있습니다.</li>
  <li>ASCII 코드중에 화면에 출력되지 않는 특수 문자들이 있습니다. 이를 ‘제어 문자’(control character)라고 불립니다.</li>
  <li>ASCII 0~31, 127 번입니다.</li>
  <li>ASCII 0 : null character. 널 문자가 배열의 끝을 표시할 때 사용하는 특수한 문자입니다.
    <ul>
      <li><code class="highlighter-rouge">char null_char = '\0'</code> 으로 쓸 수 있고 <code class="highlighter-rouge">char null_char = 0</code>이라고도 쓸 수 있습니다. 하지만 읽기 쉽게 보통 <code class="highlighter-rouge">'\0'</code>를 씁니다.</li>
    </ul>
  </li>
  <li><strong>‘C 스타일 문자열’이라 하면 널 문자로 끝나는 char 배열을 말합니다.</strong></li>
  <li>‘널 문자로 끝나는 문자열’ 이라고도 합니다.</li>
  <li>C 스타일 문자열로 “HELLO C LANG”을 표현하면 ‘H’, ‘E’, ‘L’, ‘,L’, ‘O’, ‘ ‘, ‘C’ , ‘ ‘, ‘L’, ‘A’, ‘N’, ‘G’, ‘\0’</li>
  <li><code class="highlighter-rouge">char str1[] = "abc";</code>는 스택에 “abc”를 저장하고 <code class="highlighter-rouge">char* str2 = "abc";</code>는 데이터섹션에 “abc”를 저장합니다. 두 경우 모두 끝에 <code class="highlighter-rouge">'\0'</code>가 저장됩니다. (그런데 <code class="highlighter-rouge">char*</code> 앞엔 <code class="highlighter-rouge">const</code>를 붙여줘야 합니다. 데이터섹션에 들어가기 때문에!! 바뀌면 위험하니까!!)</li>
  <li><code class="highlighter-rouge">char str[] = {'a', 'b', 'c'};</code> 에선 <code class="highlighter-rouge">\0</code>이 붙지 않습니다. 문자열을 쓰려고 한 게 아니라 진짜 문자 배열을 쓰려 했으니.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"POCU"</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"str length: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</code></pre></div></div>

<ul>
  <li>위 코드를 실행해보면 <code class="highlighter-rouge">str length: 5</code> 가 찍힙니다.</li>
</ul>

<h2 id="145-c-스타일-문자열의-장단점-문자열-길이-구하기">145. C 스타일 문자열의 장단점, 문자열 길이 구하기</h2>

<hr />

<ul>
  <li>
    <p><strong>언제나 문자열엔 널 문자가 있다는걸 잊지 맙시다!!</strong></p>
  </li>
  <li>
    <p>C 스타일 문자열의 장점</p>

    <ul>
      <li>가장 최소한의 메모리 사용</li>
      <li>한 가지 데이터형(char)으로 문자열과 길이를 다 표현</li>
    </ul>
  </li>
  <li>
    <p>C 스타일 문자열의 단점</p>

    <ul>
      <li>문자열의 길이를 알려면 O(N)이 돌아야 합니다.</li>
    </ul>
  </li>
  <li>
    <p>문자열 길이 구하는 코드 정도는 작성할줄 알죠?</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">get_str_length</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>‘이 코드가 최선입니까?’ 👉 기억 안나면 포인터 복습..</li>
      <li>이걸 개미 눈곱만큼 더 효율적으로 쓰는 방법은 포인터를 쓰는 것입니다.</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">get_str_length</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">){</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">-</span><span class="n">str</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">get_str_length</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">){</span>
		<span class="o">++</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>앞으로 문자열 설명할 때 모든 걸 포인터로 설명합니다.</p>
  </li>
  <li>그런데 사실 이미 만들어진 함수가 이씃ㅂ니다. <string.h>를 인클루드 하면 쓸 수 있습니다.</string.h></li>
  <li>하지만 직접 작성하는건 학습의 목적입니다~</li>
  <li>사람들이 가끔 하는 실수로, <code class="highlighter-rouge">char str[] = {'P', 'O', 'C', 'U'};</code> 같이 써 놓고 <code class="highlighter-rouge">size_t len = strlen(str);</code>을 해버리는 것입니다. 이걸 찍었을 때 에러가나면 차라리 좋은데, 함수에서 <code class="highlighter-rouge">'\0</code>‘찾을때 까지 계속 가서 이상한 값을 찾습니다.</li>
</ul>

<h3 id="외부에서-들어오는-문자열">외부에서 들어오는 문자열</h3>

<ul>
  <li>입출력에서 자세히 보겠지만, 외부에서 들어오는 문자열은 조심해서 읽어야 합니다. 얼마나 들어올지 모르기 때문에 발생하는 문제입니다.</li>
  <li>C11의 strlen_s() 같은 함수가 안전하게 처리해주기도 합니다</li>
  <li>strlen(str)은 읽기만 하는 함수여서 안전하다고 생각할 수도 있는데, 하드웨어나 다른 프로그램이 보호하는 메모리를 읽으려고 하면 뻑이 날 수 있습니다.</li>
</ul>

<h2 id="146-문자열-조작-두-문자열의-비교">146. 문자열 조작, 두 문자열의 비교</h2>

<hr />

<ul>
  <li>두 문자열이 같은 지 다른 지 어떻게 알 수 있을까요?</li>
  <li>요즘 얘들은 ‘사전식 배열’ 순서가 뭔지 모른다고요??? 와우…</li>
  <li>두 문자열 시작 포인터를 받아서 같으면 0, 좌항이 크면 양수, 우항이 크면 음수. 직접 작성해보세요.</li>
</ul>

<h2 id="147-문자열-비교-알고리즘">147. 문자열 비교 알고리즘</h2>

<hr />

<ul>
  <li>이건 너무 쉽지 않습니까?</li>
  <li>포인터 움직이면서 좌항이 크면 양수 리턴, 우항이 크면 음수 리턴, ‘\0’으로 같으면 0리턴</li>
</ul>

<h2 id="148-더-효율적인-문자열-비교-함수-작성하기1">148. 더 효율적인 문자열 비교 함수 작성하기1</h2>

<hr />

<ul>
  <li>
    <p>정말 단순하게 if문 3개 써서 구하는건 패스하고, 더 효율적인 방법들을 알아봅시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">compare_str</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str0</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str1</span><span class="p">){</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str0</span> <span class="o">!=</span> <span class="sc">'\0'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">str0</span> <span class="o">==</span> <span class="o">*</span><span class="n">str1</span><span class="p">){</span>
		<span class="o">++</span><span class="n">str0</span><span class="p">;</span>
		<span class="o">++</span><span class="n">str1</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="cm">/* 나왔다는건 지금 *str0가 '\0'거나 *str0와 *str1이 다를 때 */</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">str0</span> <span class="o">-</span> <span class="o">*</span><span class="n">str1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">compare_str</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str0</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str1</span><span class="p">){</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str0</span> <span class="o">!=</span> <span class="sc">'\0'</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">str0</span> <span class="o">==</span> <span class="o">*</span><span class="n">str1</span><span class="p">){</span>
		<span class="o">++</span><span class="n">str0</span><span class="p">;</span>
		<span class="o">++</span><span class="n">str1</span><span class="p">;</span>
	<span class="p">}</span>
    <span class="cm">/* 깔끔하게 1, 0, -1 만 리턴하고 싶다면*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">str0</span><span class="o">==*</span><span class="n">str1</span><span class="p">){</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">*</span><span class="n">str0</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">str1</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">;</span>
<span class="p">}</span> 
</code></pre></div>    </div>
  </li>
  <li>
    <p>복잡한 로직을 간단하게 작성할 수 있는 능력은 중요합니다. (물론, 너무 함축하여 가독성이 떨어지면 좀.. 그렇죠?)</p>
  </li>
</ul>

<h2 id="149-더-효율적인-문자열-비교-함수-작성하기-2-strcmp와-strncmp">149. 더 효율적인 문자열 비교 함수 작성하기 2, strcmp()와 strncmp()</h2>

<hr />

<ul>
  <li>
    <p>복잡한 로직을 더 복잡하게 풀어 쓰는 사람들도 있습니다..</p>
  </li>
  <li>
    <p>그리고 본인이 사용하는 함수가 내부적으로 어떻게 도는지 모르는 사람들도 있습니다.</p>
  </li>
  <li>
    <p>위 문자열 비교 알고리즘에서 두 문자열 함수 길이를 뽑고 그 길이로 뭐 하려고 하는 사람들이 시작할 때 아래처럼 strlen 돌리고 시작하는데, 이러는 순간 이미 O(N)짜리 for문 2번 돌리고 시작한 겁니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="n">len0</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str0</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">len1</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str1</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="strcmp-strncmp">strcmp(), strncmp()</h3>

<ul>
  <li>문자열 비교함수 정도는 사실 이미 존재합니다.</li>
  <li>strncmp()는 최대 n개 문자까지만 비교입니다만 사용도는 낮습니다.</li>
</ul>

<h2 id="150-코드보기-대소문자-구분-없는-문자열-비교">150. 코드보기: 대소문자 구분 없는 문자열 비교</h2>

<hr />

<ul>
  <li>
    <p>대소문자 구분 없이 문자열을 비교하는 코드를 작성해 봅시다.</p>

    <ul>
      <li>사실 그냥 비교할 때 소문자로 바꿔서 비교한거 밖에 없습니다.</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">string_case_insensitive_compare</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str0</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str1</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">c1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">c2</span><span class="p">;</span>
  	
	<span class="n">c1</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="o">*</span><span class="n">str0</span><span class="p">);</span> <span class="cm">/* tolower는 ctype.h에 들어있는 함수 */</span>
	<span class="n">c2</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="o">*</span><span class="n">str1</span><span class="p">);</span> <span class="cm">/* 각 배열의 첫 문자를 소문자로 바꿔 저장 */</span>
  	
	<span class="k">while</span> <span class="p">(</span><span class="n">c1</span><span class="o">!=</span><span class="sc">'\0'</span> <span class="o">&amp;&amp;</span> <span class="n">c1</span><span class="o">==</span><span class="n">c2</span><span class="p">){</span>
		<span class="n">c1</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="o">*++</span><span class="n">str0</span><span class="p">);</span>
		<span class="n">c2</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="o">*++</span><span class="n">str1</span><span class="p">);</span>
	<span class="p">}</span>
  	
	<span class="k">if</span> <span class="p">(</span><span class="n">c1</span><span class="o">==</span><span class="n">c2</span><span class="p">){</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
  	
	<span class="k">return</span> <span class="n">c1</span> <span class="o">&gt;</span> <span class="n">c2</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="151-문자열-복사-strcpy-strncpy">151. 문자열 복사, strcpy(), strncpy()</h2>

<hr />

<ul>
  <li>
    <p>문자열 복사</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">copy_str</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">src</span><span class="p">){</span>
	<span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">){</span>
		<span class="o">*</span><span class="n">dest</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
  	
	<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str1</span> <span class="o">=</span> <span class="s">"POCU"</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">str2</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
  
<span class="n">copy_str</span><span class="p">(</span><span class="n">str2</span><span class="p">,</span> <span class="n">str1</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <string.h>에 strcpy() 함수를 사용합시다.

```c
char* strcpy(char* dest, const char* src);
```

- 왜 char*를 반환하는 지는 아무도 모름.. 문서에도 별 얘기 없음..

</string.h>
  </li>
  <li>
    <p>C11의 strcpy_s() 는 errno_t를 반환합니다. 나중에 다시 알아봅니다.</p>
  </li>
  <li>
    <p>근데 위에서 dest의 길이를 src보다 짧게 잡아 놓았으면 어떻게 될까요?</p>

    <ul>
      <li>포인터로 다루기 때문에 dest 범위를 벗어나서 그냥 복사를 합니다. C는 정말 무섭습니다.</li>
    </ul>
  </li>
  <li>
    <p>위험하기 때문에 C11에서 안전한 strcpy_s()가 나왔습니다. s는 safe입니다.</p>
  </li>
  <li>
    <p>그리고 또 다른 비교적 안전한 함수로 strncpy()가 있습니다.</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">char* strncpy(char* dest, const char* src, size_t count);</code> 최대 count개의 문자를 복사합니다.</p>
      </li>
      <li>
        <p>src가 count보다 짧으면 남은 count를 모두 ‘\0’로 채웁니다.</p>
      </li>
      <li>
        <p>src가 count보다 길면 count만큼 복사합니다. <strong>count끝까지 문자를 채우기 때문에 마지막에 널 문자를 넣지 않습니다!!</strong></p>

        <ul>
          <li>
            <p>그래서 보통 아래처럼 마지막에 널 문자를 추가하는 방어 코드를 씁니다.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">strncpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">DEST_SIZE</span><span class="p">);</span>
<span class="n">dest</span><span class="p">[</span><span class="n">DEST_SIZE</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>정리하자면, strcpy()
    <ul>
      <li>위험할수 있습니다. dest 크기 &lt; src크기 일 경우 다른 메모리를 덮어 쓸 수 있습니다.</li>
      <li>두 크기를 확실히 통제 가능하다면 안전합니다.</li>
    </ul>
  </li>
  <li>strncpy()
    <ul>
      <li>strcpy()보다 안전하지만 dest의 남은 걸 0으로 채우기 때문에 덜 빠릅니다.</li>
      <li>count보다 src가 길 경우에 마지막에 널 문자가 안들어가는 위험 요소가 있습니다.</li>
    </ul>
  </li>
  <li>C11엔 이것보다 안전한 strcpy_s, strncpy_s가 있지만 위 두 함수보다는 느립니다.</li>
</ul>

<h2 id="152-문자열-합치기-strcat-strncat">152. 문자열 합치기, strcat(), strncat()</h2>

<hr />

<ul>
  <li>
    <string.h>에 있는 함수입니다.
</string.h>
  </li>
  <li><code class="highlighter-rouge">char* strcat(char* dest, const char* src)</code></li>
  <li>src의 문자열을 dest 뒤에 붙입니다. dest의 널 문자 위치부터 src 문자열을추가합니다. (dest의 널 문자가 src[0]로 교체됩니다.)</li>
  <li>dest의 길이가 충분해야 합니다.</li>
  <li>역시, strcat()보다 조금 더 안전한 strncat()이 있습니다.</li>
  <li><code class="highlighter-rouge">char* strncat(char* dest, const char* src, size_t count)</code></li>
  <li>dest뒤에 src 문자중 count 개를 복사합니다. 마찬가지로 dest의 널 문자 위치부터 src의 문자열을 추가합니다.</li>
  <li>끝에 널 문자를 마지막에 붙여줘서 총 count+1 개의 문자를 덮어 씁니다.</li>
</ul>

<h2 id="153-코드보기-문자열-버퍼를-이용한-출력">153. 코드보기: 문자열 버퍼를 이용한 출력</h2>

<hr />

<ul>
  <li>
    <p>출력할 것들을 버퍼에 쌓아두고 버퍼가 다 쌓이면 출력하는 함수를 구현해 봅니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define BUFFER_LENGTH (32)
</span>  
<span class="k">static</span> <span class="kt">size_t</span> <span class="n">s_buffer_index</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">s_buffer</span><span class="p">[</span><span class="n">BUFFER_LENGTH</span><span class="p">];</span>
  
<span class="kt">void</span> <span class="nf">buffered_print</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">src</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">num_left</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">src</span><span class="p">;</span>
  	
    <span class="cm">/* 몇개 더 출력해야 하는지 기억하는 변수 */</span>
	<span class="n">num_left</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
      
    <span class="k">while</span><span class="p">(</span><span class="n">num_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="kt">size_t</span> <span class="n">copy_count</span> <span class="o">=</span> <span class="n">BUFFER_LENGTH</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">s_buffer_index</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">buffer_empty</span> <span class="o">=</span> <span class="n">s_buffer_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
          
        <span class="k">if</span><span class="p">(</span><span class="n">num_lfet</span> <span class="o">&lt;</span> <span class="n">copy_count</span><span class="p">){</span>
            <span class="n">copy_count</span> <span class="o">=</span> <span class="n">num_left</span><span class="p">;</span>
        <span class="p">}</span>
          
        <span class="n">s_buffer_index</span> <span class="o">+=</span> <span class="n">copy_count</span><span class="p">;</span>
        <span class="n">num_left</span> <span class="o">-=</span> <span class="n">copy_count</span><span class="p">;</span>
          
        <span class="k">if</span><span class="p">(</span><span class="n">buffer_empty</span><span class="p">){</span>
            <span class="n">strncpy</span><span class="p">(</span><span class="n">s_buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">copy_count</span><span class="p">);</span>
            <span class="n">s_buffer</span><span class="p">[</span><span class="n">s_buffer_index</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">strncat</span><span class="p">(</span><span class="n">s_buffer</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">copy_count</span><span class="p">);</span>
        <span class="p">}</span>
          
        <span class="n">p</span> <span class="o">+=</span> <span class="n">copy_count</span><span class="p">;</span>
          
        <span class="cm">/* 버퍼가 가득 찼으면 출력, 가득 안찼으면 계속 채움 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s_buffer_index</span> <span class="o">==</span> <span class="n">BUFFER_LENGTH</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s_buffer</span><span class="p">);</span>
            <span class="n">s_buffer_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>데이터를 버퍼에 쌓다가 출력하는 식의 방식은 여러 곳에서 사용합니다.</p>
  </li>
</ul>

<h2 id="154-문자열-찾기">154. 문자열 찾기</h2>

<hr />

<ul>
  <li>
    <p>문자열 찾는 함수는 <string.h>에 strstr()이 있습니다.</string.h></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">char</span> <span class="n">msg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"I love string! I love C"</span><span class="p">;</span>
  	
	<span class="kt">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">"int"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"result : %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
  	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 처럼 문자열에 없는 문자열을 찾으려고 한다면 ‘널 포인터’를 반환합니다. 그런데 널 포인터를 출력하겠다?? 위험한 행동입니다. 컴파일러에 따라 에러를 표시해주기도 하고 널 포인터를 출력해주기도 하고 터치기도 합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">char</span> <span class="n">msg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"I love string! I love C"</span><span class="p">;</span>
  	
	<span class="kt">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">"int"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"result : %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="o">==</span><span class="nb">NULL</span> <span class="o">?</span> <span class="s">"(null)"</span> <span class="o">:</span> <span class="n">result</span><span class="p">);</span>
  	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>널 인지 확인해주고 출력해줍시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">char</span> <span class="n">msg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"I love string! I love C"</span><span class="p">;</span>
  	
	<span class="kt">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">strstr</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="s">"string"</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"result : %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="o">==</span><span class="nb">NULL</span> <span class="o">?</span> <span class="s">"(null)"</span> <span class="o">:</span> <span class="n">result</span><span class="p">);</span>
  	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/* result : string! I love C*/</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>문자열을 찾았으면 찾은 문자열의 처음 위치를 리턴합니다. 그래서 해당 char*를 출력하면 뒤로 쭉 다 나옵니다.</p>
  </li>
</ul>

<h2 id="155-문자열-찾기-함수가-메모리-주소를-반환하는-이유">155. 문자열 찾기 함수가 메모리 주소를 반환하는 이유</h2>

<hr />

<ul>
  <li>
    <p>C#의 string.indexOf()는 찾은 문자열의 index를 반환합니다. 그런데 왜 C는 주소를 반환할 까요?</p>
  </li>
  <li>
    <p>일단 문자열을 찾아서 찾은 문자열 뒤로 새로운 문자열을 만들어 반환할 수도 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="nf">strstr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">substr</span><span class="p">){</span>
	<span class="cm">/* 생략 */</span>
	<span class="kt">char</span> <span class="n">result</span><span class="p">[]</span> <span class="o">=</span> <span class="n">str</span><span class="err">에서</span> <span class="err">찾은</span> <span class="n">substr</span><span class="err">부터</span> <span class="err">나머지</span><span class="p">;</span>
  	
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span> <span class="cm">/* result[]는 스택 메모리에 할당되고, 함수가 끝나면 사라집니다. */</span>
</code></pre></div>    </div>

    <ul>
      <li>위 방법에서 result[]는 함수가 끝나면 스택에서 사리지기 때문에 사용할 수 없습니다.</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="nf">strstr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">substr</span><span class="p">){</span>
	<span class="cm">/* 코드 생략 */</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">();</span>
	<span class="cm">/* 코드 생략 */</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>그러면 함수 끝나고 쓸 수 있게 malloc() (memory allocation)으로 힙 메모리에 데이터를 넣으면 어떨까요?
        <ul>
          <li>OS에서 메모리를 받아올 수 있지만, 받아온 메모리를 free(result)로 해제하지 않으면 메모리 누수가 발생합니다. 이 함수를 여러 개발자가 쓰고 누군가는 실수를 할 것입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>추가 메모리를 쓰지도 않고 사람의 실수를 막을 수도 있는 방법이 그냥 원본에서 찾은 주소를 돌려주는 것입니다.</p>
  </li>
</ul>

<h2 id="156-문자열-토큰화">156. 문자열 토큰화</h2>

<hr />

<ul>
  <li>‘프로그래밍 입문’강좌에서 이미 토큰화를 배웠습니다.(정규 과정을 차례차례 밟은 학생들만..)</li>
  <li>C에서도 토큰화 함수가 있는데 C#과 좀 다릅니다.</li>
  <li>토큰화 예제
    <ul>
      <li>구분 문자(delims) : 콤마, 마침표, 스페이스</li>
      <li>토큰화할 문자열(msg) : “Hi, there. hello. Bye”</li>
      <li>msg : Hi, there. hello. Bye\0</li>
      <li>1단계 : <code class="highlighter-rouge">char* token = strtok(msg, delims);</code>
        <ul>
          <li>msg : Hi\0 there. hello. Bye\0</li>
        </ul>
      </li>
      <li>2단계 : <code class="highlighter-rouge">char* token = strtok(NULL, delims);</code>
        <ul>
          <li>msg : Hi\0 there\0 hello. Bye\0</li>
        </ul>
      </li>
      <li>3단계 : <code class="highlighter-rouge">char* token = strtok(NULL, delims);</code>
        <ul>
          <li>msg : Hi\0 there\0 hello\0 Bye\0</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>토큰화를 시작하려면 문자열(msg)을 strtok()에 넣고, msg의 다음 토큰을 구하려면 NULL을 입력합니다.</li>
  <li>더 이상 토큰이 없다면 strtok()는 NULL을 반환합니다.</li>
  <li><strong>토큰화하는 문자열은 const가 아니라 원본이 바뀌게 됩니다.</strong></li>
  <li>함수에 NULL을 입력하는 것을 보니… 함수가 전에 사용했던 msg를 어딘가에 저장하고 있다는 것이니까… 어디에 저장되어 있을까요?
    <ul>
      <li>함수 내 정적변수가 아닐까요? 파일 정적 변수일수도 있고. 함수 내 정적 변수일겁니다.</li>
    </ul>
  </li>
  <li>이 정도 힌트 줬으면 토큰화 함수도 작성할 줄 알아야 합니다. 할만합니다.</li>
  <li>C11에 strtok_s() 있습니다.</li>
</ul>

<h3 id="c-문자열-함수들-특징">C 문자열 함수들 특징</h3>

<ul>
  <li>많은 함수들이 문자열을 변경하지 않습니다.
    <ul>
      <li>함수에서 const char*를 사용합니다.</li>
    </ul>
  </li>
  <li>문자열을 변경하더라도 원본은 변경하지 않습니다.
    <ul>
      <li>사본만 변경합니다.</li>
    </ul>
  </li>
  <li>strtok()의 경우엔 원본을 변경합니다.</li>
  <li>절대 새로운 문자열을 만들어 반환해주지 않습니다.
    <ul>
      <li>메모리 누수의 위험</li>
    </ul>
  </li>
</ul>

<h2 id="157-코드보기--문자열을-대문자-또는-소문자로-바꾸기">157. 코드보기 : 문자열을 대문자 또는 소문자로 바꾸기</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">is_alpha</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span> <span class="cm">/* 알파벳인가 */</span>
<span class="kt">int</span> <span class="nf">to_upper</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span> <span class="cm">/* 문자를 대문자로 */</span>
<span class="kt">int</span> <span class="nf">to_lower</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span> <span class="cm">/* 문자를 소문자로 */</span>
<span class="kt">void</span> <span class="nf">string_toupper</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span> <span class="cm">/* 문자열을 대문자열로 */</span>
<span class="kt">void</span> <span class="nf">string_tolower</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span> <span class="cm">/* 문자열을 소문자열로 */</span>
</code></pre></div></div>

<ul>
  <li>
    <p>위 5 가지의 함수를 작성합시다!</p>
  </li>
  <li>
    <p>is_alpha</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">is_alpha</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">){</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">&gt;=</span><span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">&lt;=</span><span class="sc">'Z'</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span><span class="o">&gt;=</span><span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">&lt;=</span><span class="sc">'z'</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>to_upper</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">to_upper</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_alpha</span><span class="p">(</span><span class="n">c</span><span class="p">)){</span>
		<span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x20</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>c &amp; ~0x20; 는 비트 마스킹이라는 것입니다. 0x20은 십진수 32인데, 아스키에서 대문자와 소문자간의 차이가 32입니다.(의도한 것 같습니다.)</li>
      <li>c &amp; ~0x20은 c에서 32를 빼는 것과 마찬가지입니다.
        <ul>
          <li>0x20은 0010 0000 (2) 입니다.</li>
          <li>~0x20은 1101 1111(2) 입니다.</li>
          <li>a는 0110 0001, z는 0111 1010 입니다.</li>
          <li>c &amp; ~0x20은 c를 그대로 남기되, 2^5 자리만 0으로 바꾸는 것입니다. 이런 걸 비트 마스킹이라고 부릅니다.</li>
          <li>‘a’ &amp; ~0x20을 하면 0110 0001 이 0100 0001 이 됩니다. 대소문자 차이를 32로 둔건 의도한 것 같습니다. 천재들인가..</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>to_lower</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">to_lower</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_alpha</span><span class="p">(</span><span class="n">c</span><span class="p">)){</span>
		<span class="k">return</span> <span class="n">c</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>대문자를 소문자로 변경하는 방법은 반대로 c에 32를 더하는 것과 같습니다.</li>
    </ul>
  </li>
  <li>
    <p>string_toupper</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">string_toupper</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">){</span>
        <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">to_upper</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">);</span>
        <span class="o">++</span><span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>string_tolower</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">string_tolower</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">){</span>
        <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">to_lower</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">);</span>
        <span class="o">++</span><span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="158-출력-서식-지정formatted-출력-서식-문자열format-string">158. 출력, 서식 지정(formatted) 출력, 서식 문자열(format string)</h2>

<hr />

<h3 id="출력">출력?</h3>

<ul>
  <li>출력이란 프로그램에서 프로그램 외부로 데이터를 보여주는 행위입니다.</li>
  <li>프로그램이 갖고 있는걸 밖으로 빼주는 거라서 이상한 데이터들이 없습니다. 입력보다 쉽습니다. 입력은 뭐가 들어올지 모르니..</li>
</ul>

<h3 id="서식-지정-출력">서식 지정 출력</h3>

<ul>
  <li>C에서 출력에 기본이 되는 함수입니다. 아래 세 함수는 어디에 출력할지만 다를 뿐, 작동법은 동일합니다.
    <ul>
      <li>printf() : 콘솔창(stdout)에 출력</li>
      <li>fprintf() : 스트림에 출력 (f는 file을 의미합니다.) 단, fprintf는 첫 번째 인자로 어디에 출력할지를 넣어줘야 합니다.</li>
      <li>sprintf() : 문자열에 출력</li>
    </ul>
  </li>
  <li>C에서 printf()의 첫번째 인자는 무조건 문자열입니다. 다른 언어들 처럼 <code class="highlighter-rouge">printf(3)</code> 이런거 안됩니다.
    <ul>
      <li>다른 언어에서 <code class="highlighter-rouge">print(3)</code>같은 게 되는 이유는, 다른 언어엔 함수 오버로딩이 있기 때문입니다.</li>
    </ul>
  </li>
  <li>printf는 일반 문자열 혹은 서식문자열을 매개변수롤 받습니다.
    <ul>
      <li>서식 문자열은 %로 시작하는 문자열을 말합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="159-일반적인-서식-문자열-형식-서식-지정자format-specifier">159. 일반적인 서식 문자열 형식, 서식 지정자(format specifier)</h2>

<hr />

<ul>
  <li>%뒤에 옵션이 4개나 올 수 있습니다.</li>
  <li>%[플래그][너비][.숫자 정밀도 or .문자열 최소/최대 출력 개수][길이] 서식 지정자</li>
  <li>서식지정자
    <ul>
      <li>%를 출력하고 싶을땐 printf(“%%\n”);</li>
      <li>문자출력시 printf(“%c\n”, ‘a’);</li>
      <li>문자열 출력 printf(“%s\n”, “POCU”);</li>
      <li>부호 있는 정수 %d</li>
      <li>부호 없는 정수 %u</li>
      <li>부호 없는 정수를 8진수로 출력 %o</li>
      <li>부호 없는 정수를 16진수(소문자)로 출력 %x</li>
      <li>부호 없는 정수를 16진수(대문자)로 출력 %X</li>
      <li>부호 없는 정수 넣으라고 했는데 부호 있는거 넣으면 부호있는 수의 비트패턴을 부호 없는 것 처럼 읽습니다.</li>
      <li>부동 소수점 %f</li>
      <li>지수표기법 %e, %E</li>
      <li>포인터값 출력 printf(“%p\n”, (void*)name);</li>
    </ul>
  </li>
  <li>너비 - 기본적으로 오른쪽 정렬이 됩니다. printf(“%5d\n”, number);</li>
  <li>플래그
    <ul>
      <li>- : 왼쪽 정렬 printf(“%-5d\n”, number);</li>
      <li>0 : 빈 공백을 9으로 채워줌 printf(“%05d\n”, number);</li>
      <li>+ : 항상 부호를 표시 printf(“%+5d\n”, number);</li>
      <li>공백 : 양수인 경우에도 부호칸을 비워둠 printf(“% 5d\n”, number);</li>
    </ul>
  </li>
  <li>하나하나 다 알려주면 끝도 없으니까 필요할 때 알아서 잘 찾아보면서 해라~</li>
</ul>

<h2 id="160-코드보기--ascii표-그리기">160. 코드보기 : ASCII표 그리기</h2>

<hr />

<ul>
  <li>
    <p>예쁘게 ASCII표 그려보기.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>  
<span class="kt">void</span> <span class="nf">print_ascii_table</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">MIN_ASCII</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_ASCII</span> <span class="o">=</span> <span class="mi">126</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NUM_CHARS</span> <span class="o">=</span> <span class="n">MAX_ASCII</span> <span class="o">-</span> <span class="n">MIN_ASCII</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NUM_COLS</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">NUM_ROWS</span> <span class="o">=</span> <span class="p">(</span><span class="n">NUM_CHARS</span> <span class="o">+</span> <span class="n">NUM_COLS</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">NUM_COLS</span><span class="p">;</span>
  
    <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ch</span><span class="p">;</span>
  
    <span class="n">printf</span><span class="p">(</span><span class="s">"Dec  Hex  Char</span><span class="se">\t</span><span class="s">Dec  Hex  Char</span><span class="se">\t</span><span class="s">Dec  Hex  Char</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  
    <span class="k">for</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">r</span><span class="o">&lt;</span><span class="n">NUM_ROWS</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">){</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">MIN_ASCII</span> <span class="o">+</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%03d %#X %5c</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
  
        <span class="n">ch</span> <span class="o">+=</span> <span class="n">NUM_ROWS</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%03d %#X %5c</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>        
  
        <span class="n">ch</span> <span class="o">+=</span> <span class="n">NUM_ROWS</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%03d %#X %5c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>        
    <span class="p">}</span>
  
    <span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="o">=</span> <span class="n">MIN_ASCII</span> <span class="o">+</span> <span class="n">r</span><span class="p">;</span> <span class="n">ch</span><span class="o">&lt;=</span><span class="n">MAX_ASCII</span><span class="p">;</span> <span class="n">ch</span><span class="o">+=</span><span class="n">NUM_ROWS</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%03d %#X %5c</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">print_ascii_table</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="161-코드보기--바이트-단위-변환-표">161. 코드보기 : 바이트 단위 변환 표</h2>

<hr />

<ul>
  <li>
    <p>표 예쁘게 그려보기2</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>  
<span class="cp">#define SCALE (1024.0f)
</span>  
<span class="cp">#define BYTE (1.0f)
#define KB (SCALE * BYTE)
#define MB (SCALE * KB)
#define GB (SCALE * MB)
#define TB (SCALE * GB)
#define PB (SCALE * TB)
</span>  
<span class="cp">#define LENGTH (6)
</span><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">DATA_STORAGE_NAMES</span><span class="p">[</span><span class="n">LENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Byte"</span><span class="p">,</span> <span class="s">"Kilobyte"</span><span class="p">,</span> <span class="s">"Megabyte"</span><span class="p">,</span> <span class="s">"Gigabyte"</span><span class="p">,</span> <span class="s">"Terabyte"</span><span class="p">,</span> <span class="s">"Petabyte"</span><span class="p">};</span>
  
<span class="kt">void</span> <span class="nf">print_byte_conversion_char</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">double</span> <span class="n">divisor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  
    <span class="n">printf</span><span class="p">(</span><span class="s">"%9s"</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
  
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">LENGTH</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%17s "</span><span class="p">,</span> <span class="n">DATA_STORAGE_NAMES</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">%4s"</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
  
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">LENGTH</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s %17.15f %17.12f %17.9f %17.6f %17.3f %17.0f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">DATA_STORAGE_NAMES</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">BYTE</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">KB</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">MB</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">GB</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">TB</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">PB</span><span class="o">/</span><span class="n">divisor</span><span class="p">);</span>
  
        <span class="n">divisor</span> <span class="o">*=</span> <span class="n">SCALE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
  
<span class="kt">void</span> <span class="nf">print_byte_conversion_chart_scientific</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">double</span> <span class="n">divisor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  
    <span class="n">printf</span><span class="p">(</span><span class="s">"%9s"</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
  
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">LENGTH</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%17s "</span><span class="p">,</span> <span class="n">DATA_STORAGE_NAMES</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
  
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">%4s"</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
  
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">LENGTH</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s %17.2e %17.2e %17.2e %17.2e %17.2e %17.2e</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">DATA_STORAGE_NAMES</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">BYTE</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">KB</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">MB</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">GB</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">TB</span><span class="o">/</span><span class="n">divisor</span><span class="p">,</span> <span class="n">PB</span><span class="o">/</span><span class="n">divisor</span><span class="p">);</span>
  
        <span class="n">divisor</span> <span class="o">*=</span> <span class="n">SCALE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">print_byte_conversion_char</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">print_byte_conversion_chart_scientific</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="162-서식-문자열이-필요한-이유-fprintf-stdout-버퍼링-sprintf">162. 서식 문자열이 필요한 이유, fprintf(), stdout, 버퍼링, sprintf()</h2>

<hr />

<ul>
  <li>C에선 오버로딩이 없어서 <code class="highlighter-rouge">printf(int)</code> , <code class="highlighter-rouge">printf(char)</code>등이 불가능합니다.</li>
  <li>C#에서 사용하는 <code class="highlighter-rouge">Console.WriteLine("Hello"+name+" hey~");</code> 같이 임시문자열을 사용하는 방법도 C에선 안됩니다.</li>
  <li>fprintf()도 사용은 똑같습니다.
    <ul>
      <li>다만, 첫번째 인자를 스트림으로 씁니다.</li>
      <li>기본적으로 3개의 표준 스트림이 주어집니다. stdout(콘솔 출력), stdin(콘솔 입력), stderr(에러 메세지를 출력하는 콘솔 출력)</li>
      <li><code class="highlighter-rouge">fprintf(stdout, "str : %s\n", "hello world");</code></li>
      <li>stdout은 계속 썼던 콘솔 스트림입니다. 라인 버퍼링을 사용합니다.
        <ul>
          <li>라인 버퍼링이란 ‘버퍼가 꽉 차거나’, ‘버퍼에 \n 이 들어올 때’ 버퍼를 비우는 버퍼링입니다.</li>
          <li>강제로 버퍼를 비우고 싶다면 <code class="highlighter-rouge">fflush(stdout);</code> 을 호출하면 됩니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>버퍼링 종류
    <ul>
      <li>풀 버퍼링(full buffering)
        <ul>
          <li>버파가 가득차면 비웁니다. fflush()로 강제로 비울 수 있습니다.</li>
        </ul>
      </li>
      <li>라인 버퍼링
        <ul>
          <li>버퍼가 꽉 차거나, ‘\n’을 만나면 버퍼를 비웁니다. fflush()로 강제로 비울 수 있습니다.</li>
        </ul>
      </li>
      <li>버퍼링 없음(no buffering)
        <ul>
          <li>버퍼를 사용하지 않습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>fprintf는 출력이니까 당연히 stdin 스트림은 패스하고 stdout, strerr 스트림을 쓸 수 있습니다.
    <ul>
      <li>stdout과 strerr를 써보면 결과는 같게 보이는데, 곧 배웁니다.</li>
    </ul>
  </li>
  <li>표준 스트림 외에도 파일 스트림 등이 있습니다. C#에선 문자열 스트림이 있었지만 C에선 문자열 스트림은 없고 대신 sprintf()가 있습니다.
    <ul>
      <li>sprintf()는 많이 씁니다. <code class="highlighter-rouge">int sprintf(char* buffer, const char* format, ...)</code></li>
      <li>C++에선 string 클래스가 있어도 sprintf()를 많이 씁니다. 빨라서!</li>
    </ul>
  </li>
</ul>

<h2 id="163-출력-함수의-안정성-기타-출력-함수">163. 출력 함수의 안정성, 기타 출력 함수</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Cateriana Hassinger"</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">"%s's socre: %d"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">score</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>위와 같은 코드는 당연히 안전하지 않습니다. 버퍼보다 버퍼에 쓸 문자열이 크기 때문에 버퍼를 지나쳐서 다른 메모리에 덮어씁니다.</li>
  <li>C99에 snprintf()가 등장합니다.
    <ul>
      <li>마이크로소프트 비주얼 C엔 _snprintf() 가 있는데 snprintf()와 약간 다릅니다.</li>
    </ul>
  </li>
  <li>이 외에도 puts(), putchar() 같은 출력 함수도 있지만 주로 printf를 씁니다.</li>
</ul>

<h2 id="164-정리">164. 정리</h2>

<hr />

<ul>
  <li>섹션 5에서 배운걸 정리해봅시다.</li>
  <li>C스타일 문자열
    <ul>
      <li>문자열의 표현방법</li>
      <li>다양한 문자열 함수들</li>
      <li>안전한 문자열 처리</li>
    </ul>
  </li>
  <li>출력
    <ul>
      <li>서식지정 출력</li>
      <li>printf(), fprintf(), sprintf()</li>
      <li>서식 문자열</li>
      <li>기타 출력 함수</li>
    </ul>
  </li>
</ul>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
