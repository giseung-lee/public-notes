<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      C Unmanaged Programming 9 - 레지스터, 스택, 힙, 동적 메모리, 다중 포인터 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/About Me">About Me</a>
      
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Sagyo_Reboot">Sagyo_Reboot</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Twitch_Chat_Analysis">Twitch_Chat_Analysis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Algorithm">Algorithm</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/java">java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/jekyll">jekyll</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/linux">linux</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">C Unmanaged Programming 9 - 레지스터, 스택, 힙, 동적 메모리, 다중 포인터</h1>
  <span class="post-date"></span>
  
<h2 id="224-메모리의-종류">224. 메모리의 종류</h2>

<hr />

<ul>
  <li>
    <p>컴퓨터는 다양한 하드웨어로 구성되어 있습니다. 그 중 가장 중요한 부품 2가지가 있다면 CPU와 메모리입니다.</p>
  </li>
  <li>
    <p>CPU</p>

    <ul>
      <li>모든 코드의 로직(연산)을 실행하는 제어 장치</li>
      <li>컴퓨터의 핵심 두뇌</li>
      <li>CPU안에도 레지스터라고 불리는 작고 빠른 저장공간이 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>메모리</p>

    <ul>
      <li>실행 중인 코드 및 연산의 중간 결과 등을 저장하는 공간</li>
      <li>변수, 배열 등 대입되는 데이터가 저장됩니다.</li>
      <li>컴퓨터의 공책, 메모장과 같은 역할입니다.</li>
      <li>메모리도 중요한 2가지를 뽑을 수 있습니다. (외에 데이터 섹션, 코드 섹션 등이 있습니다.)
        <ul>
          <li>스택 메모리</li>
          <li>힙 메모리</li>
        </ul>
      </li>
      <li>스택 메모리, 힙 메모리는 물리적으로는 같은 메모리입니다.</li>
      <li>기본은 힙 메모리입니다. 힙 메모리가 조금 더 범용적인 형태입니다. 내어 달라고 하면 운영체제가 내어줍니다.</li>
      <li>스택 메모리는 프로그램마다(엄밀히 말하면 프로그램의 스레드 마다) 떼어준 메모리입니다.</li>
    </ul>
  </li>
</ul>

<h2 id="225-스택-메모리">225. 스택 메모리</h2>

<hr />

<ul>
  <li>스택 메모리는 앞에서 많이 봤습니다. 모른다면 전 강의를 복습..</li>
  <li>스택 메모리에 대해 더 알고 싶으면 <strong>함수 호출 규약(calling convention)</strong>에 대해 더 알아보시길 바랍니다.</li>
  <li>컴파일러마다 따르는 calling convention이 있는데 이 규약에 따라 스택 메모리에서 메모리를 어떻게 주고 받고, 돌아가는 지 달라집니다.</li>
</ul>

<h2 id="226-레지스터">226. 레지스터</h2>

<hr />

<ul>
  <li>레지스터는 CPU에 있습니다. 메모리 아닙니다. 단, 역할은 메모리와 비슷합니다.</li>
  <li>메모리는 느립니다.
    <ul>
      <li>CPU의 데이터를 메모리에 저장하려면 CPU에서 메모리까지 연결해주는 버스(bus)를 태워 데이터를 주고 받아야 합니다. 그런데, 버스를 태워 데이터를 보내는 것 자체가 지연입니다. 또한, 버스의 크기를 어떻게 설정하는 지에 따라 성능이 좌우되기도 합니다.</li>
      <li>대부분 컴퓨터의 메모리는 DRAM입니다. DRAM은 저렴한 대신 기록한 데이터를 유지하기 위해 주기적으로 데이터를 다시 써야 합니다.(가만히 두면 날아갑니다.) SRAM은 이러 단점이 없긴 한데… 매우 비쌉니다.</li>
    </ul>
  </li>
  <li>컴퓨터 공학자들은 저렴하고 빠른 컴퓨터를 만들고 싶었습니다. 그래서 메모리는 DRAM을 쓰되, SRAM을 CPU와 메모리 사이에 두기로 했습니다.</li>
  <li>사이에 두기로 했지만 아예 CPU안에 넣어버렸습니다. 굉장히 작은 크기만. 그것이 레지스터 입니다.(엄밀히 말하면 SRAM 자체는 아니지만 거진 비슷합니다.)</li>
</ul>

<h2 id="227-어셈블리어로-보는-레지스터">227. 어셈블리어로 보는 레지스터</h2>

<hr />

<ul>
  <li>레지스터는 CPU가 사용하는 저장 공간 중 가장 빠른 저장공간입니다.</li>
  <li>CPU가 연산할 땐 레지스터에 있는 데이터를 사용합니다. 연산 결과도 일단 레지스터에 저장합니다.</li>
  <li>그런데 저희는 이미 레지스터를 많이 만났습니다. 어셈블리어 까볼때.
    <ul>
      <li>어셈블리어에서 봤던 ebp, esp, eax, ecx 등이 레지스터입니다.</li>
    </ul>
  </li>
  <li>X86에서 사용하는 레지스터
    <ul>
      <li>8개의 범용 레지스터 (general-purpose register)
        <ul>
          <li>ESP, EBP, EAX, EBX, ECX, EDX 등</li>
        </ul>
      </li>
      <li>6개의 세그먼트 레지스터 (segment register)</li>
      <li>1개의 플래그 레지스터 (flags register)</li>
      <li>1개의 명령어 포인터 (instruction pointer)</li>
    </ul>
  </li>
</ul>

<h2 id="228-register-키워드">228. register 키워드</h2>

<hr />

<ul>
  <li>
    <p>어셈블리어로 코딩하면 register 수준에서 데이터를 다룰 수 있습니다 ㅎㅎ</p>
  </li>
  <li>
    <p>그런데, C는 레지스터를 써달라고 시도해 볼 순 있습니다. 단, 컴파일러에 따라 해줄지 말지는 모릅니다.</p>
  </li>
  <li>
    <p>거의 안쓸거지만 설명은 드립니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
<span class="cm">/* size_t는 계속 레지스터에 넣어주세요!! */</span>
<span class="k">register</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  
<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="n">printf</span><span class="p">(</span><span class="s">"num: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>register</p>

    <ul>
      <li>
        <p>register <자료형> <변수명>;</변수명></자료형></p>
      </li>
      <li>
        <p>저장 유형 지정자(storage-class specifier) 라고 부릅니다.</p>
      </li>
      <li>
        <p>‘가능하면 해당 변수를 레지스터에 저장해달라’</p>
      </li>
      <li>
        <p>실제로 레지스터에 저장할 지는 컴파일러가 결정합니다.</p>
      </li>
      <li>
        <p>레지스터는 메모리와 다르기 때문에 몇 가지 제약이 있습니다. (메모리가 아니라 레지스터에 저장했기 때문에 쓸 수 없는 기능들)</p>

        <ul>
          <li>
            <p>변수의 주소를 구할 수 없습니다.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">register</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
      
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span> <span class="cm">/* 컴파일 오류 */</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>레지스터 배열을 포인터로 사용 불가</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">register</span> <span class="kt">int</span> <span class="n">nums</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
      
<span class="n">p</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span> <span class="cm">/* 컴파일 오류 */</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* 컴파일 오류 */</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>전역변수에 사용할 수 없습니다. (전역 변수는 메모리의 데이터 섹션에 들어가야 하며, 레지스터는 몇 개 없는데 전역 변수는 프로그램 실행 내내 잡혀 있어야 하므로)</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>      
<span class="k">register</span> <span class="kt">int</span> <span class="n">g_num</span><span class="p">;</span> <span class="cm">/* 컴파일 오류 */</span>
      
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>
        <p>요즘 대부분 컴파일러는 register를 그냥 무시합니다.</p>
      </li>
      <li>
        <p>예전 임베디드 시스템에선 꽤 사용되던 키워드입니다.(CPU도 느리고 메모리도 적어서 프로그래머가 더 많은 일을 했어야 했던 때)</p>
      </li>
      <li>
        <p>요즘 컴파일러는 release모드에서 알아서 최적화 해줍니다. 레지스터에 계속 잡아두면 빠를 변수는 레지스터에 잡아줍니다.</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="229-힙-메모리">229. 힙 메모리</h2>

<hr />

<ul>
  <li>스택 메모리의 단점
    <ul>
      <li>수명 - 함수가 반환되면 함수 안의 데이터가 날아갑니다. 오래 잡아 두고 싶으면 전역변수를 쓰던지, static 키워드를 써야 했습니다. 근데 이렇게 하면 함수 안에서만 있거나, 프로그램 끝날때까지 있거나입니다. 중간에 원할 때 만들고 원할 때 지울 수 있으면 좋겠습니다.</li>
      <li>크기 - 스택 메모리의 크기는 작고 한정되어 있습니다. 큰 데이터는 스택 메모리에 못 넣을 수도 있습니다.</li>
    </ul>
  </li>
  <li>힙 메모리
    <ul>
      <li>컴퓨터에 존재하는 범용 메모리입니다.</li>
      <li>스택 메모리처럼 특정 용도로 떼어 놓은 메모리가 아닙니다.</li>
      <li>컴파일러 및 CPU가 메모리 관리를 안해주기 때문에 개발자가 원할 때 원하는 만큼 할당 받고, 원할 때 반납(해제)할 수 있습니다.</li>
    </ul>
  </li>
  <li>힙 메모리 장점
    <ul>
      <li>용량 제한이 없습니다.</li>
      <li>프로그래머가 직접 수명을 제어할 수 있습니다. - 양날의 검</li>
    </ul>
  </li>
  <li>힙 메모리 단점
    <ul>
      <li>빌려온 메모리를 해제 안하면 누구도 그 메모리를 쓸 수 없습니다.(메모리 누수라고 합니다.)</li>
      <li>언매니지드 언어라는 뜻도 힙 메모리를 관리안해주기 때문입니다.
        <ul>
          <li>메모리관리를 해주는 매니지드언어(C#, Java 등)은 힙 메모리를 관리해주는 기능이 존재합니다. 이런 메모리관리는 범용적으로 적용되기 때문에 속도는 느립니다.</li>
        </ul>
      </li>
      <li>메모리 관리를 직접 해줘야 합니다. 실수를 막기 위한 좋은 습관들을 들여야 합니다.</li>
      <li>스택에 비해 할당/해제 속도가 느립니다.
        <ul>
          <li>스택은 오프셋 개념이라 빈틈없이 쓸 수 있습니다. 힙은 비사용중인 메모리중 아무데나 집어주기 때문에 메모리 공간에 불규칙적인 구멍이 생겨 효율적으로 메모리를 사용하기 힘듭니다.(‘메모리 파편화’라고도 합니다.)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>정적 메모리 vs 동적 메모리
    <ul>
      <li>스택 메모리는 정적 메모리입니다. 컴파일시 메모리를 얼마나 쓸 지 정해져 있습니다. 할당/해제가 자동으로 관리 되도록 컴파일 됩니다.</li>
      <li>힙 메모리는 실행중에 크기와 할당/해제 시기가 달라질 수 있습니다. 어떤 파일을 언제 열지, 언제 저장할 지, 어떤 행동을 할 건지 등에 따라 달라집니다.</li>
    </ul>
  </li>
</ul>

<h2 id="230-동적-메모리">230. 동적 메모리</h2>

<hr />

<ul>
  <li>동적메모리를 사용할 땐 세 가지 단계를 거칩니다.
    <ul>
      <li>메모리 할당
        <ul>
          <li>힙 관리자에게 메모리를 xxx 바이트만큼 달라고 요청합니다.</li>
          <li>관리자는 xxx 바이트 만큼 연속되는 빈 메모리를 찾아 사용중으로 상태를 바꾸고 메모리의 시작 주소를 반환합니다.</li>
        </ul>
      </li>
      <li>메모리 사용
        <ul>
          <li>반환하는 주소를 포인터로 받습니다.</li>
          <li>그 이후는 평소 프로그래밍 하듯이 합니다.</li>
        </ul>
      </li>
      <li>메모리 해제
        <ul>
          <li>주소를 다 쓰면 다 썼다고 힙 관리자에게 알려줍니다.</li>
          <li>힙 관리자는 해당 메모리를 사용가능한 상태로 다시 바꿉니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="231-메모리-할당-및-해제-함수-malloc">231. 메모리 할당 및 해제 함수, malloc()</h2>

<hr />

<ul>
  <li>할당
    <ul>
      <li>malloc()</li>
      <li>calloc()</li>
    </ul>
  </li>
  <li>해제
    <ul>
      <li>free()</li>
    </ul>
  </li>
  <li>재할당
    <ul>
      <li>realloc()</li>
    </ul>
  </li>
  <li>기타(정적 메모리에도 사용 가능)
    <ul>
      <li>memset()</li>
      <li>memcpy()</li>
      <li>memcmp()</li>
    </ul>
  </li>
</ul>

<h3 id="malloc">malloc()</h3>

<ul>
  <li>memory allocation의 약자입니다.</li>
  <li><code class="highlighter-rouge">void* malloc(size_t size);</code></li>
  <li>void 포인터를 용도에 맞는 포인터로 캐스팅해서 사용합니다.</li>
  <li>반환된 주소에 있는 초기 값은 쓰레기 값입니다. C에선 초기화 안해줍니다.</li>
  <li>메모리가 없거나 기타 이유로 실패하면 NULL을 반환합니다.</li>
</ul>

<h2 id="232-free-malloc-사용-예">232. free(), malloc() 사용 예</h2>

<hr />

<h3 id="free">free()</h3>

<ul>
  <li>malloc()의 짝꿍입니다. 메모리를 해제해줍니다.</li>
  <li>malloc() 을 작성하면 일단 바로 free()를 작성하는 습관을 들입시다. 중간 코드는 malloc(), free()를 쓰고 써도 됩니다.</li>
  <li><code class="highlighter-rouge">void free(void* ptr);</code></li>
  <li>malloc을 통해 얻어온 주소만 free 가능합니다. 외에 malloc으로 받아온 포인터가 아닌 다른 포인터를 넣으면 결과는 undefined입니다.</li>
</ul>

<h3 id="malloc-사용-예">malloc() 사용 예</h3>

<ul>
  <li>쭉 코드보는 시간</li>
</ul>

<h2 id="233-동적-메모리-할당-시-문제">233. 동적 메모리 할당 시 문제</h2>

<hr />

<ul>
  <li>
    <p>할당 받아온 주소를 그대로 연산에 사용하면 발생할 수 있는 문제가 있습니다.</p>

    <ul>
      <li>한 포인터에 최초에 malloc으로 받아온 주소가 아니라 중간에 다른 주소를 대입하면 free 할때 undefinded한 결과가 나옵니다. 그리고 malloc으로 받은 메모리는 해제되지 못하고 남아 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>할당받은 포인터로 연산을 최대한 자제시키는 코딩 표준.</p>

    <ul>
      <li>
        <p>malloc을 받아온 원본 포인터는 그냥 가지고 있고, 연산이 필요하면 다른 포인터를 선언해서 그걸로 연산해라.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span><span class="o">*</span> <span class="n">nums</span><span class="p">;</span> <span class="cm">/* malloc 받을 포인터 */</span>
 <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span> <span class="cm">/* 연산할 포인터 */</span>
     
 <span class="n">nums</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">LENGTH</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
 <span class="n">p</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span> <span class="cm">/* free를 위한 원본은 남겨두기 위해 주소 복사 */</span>
     
 <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">LENGTH</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
 	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
 <span class="p">}</span>
     
 <span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>해제한 메모리를 또 해제하는 경우도 있습니다. undefined한 결과이지만 크래시가 날 수도 있습니다.</p>
  </li>
  <li>
    <p>해제한 메모리를 사용하려 하는 경우도 있습니다.(memory stomp라고 합니다.) 역시 결과는 undefined 이긴 합니다.</p>
  </li>
  <li>
    <p>실수를 줄일 수 있는 습관2</p>

    <ul>
      <li>
        <p>해제 후 널 포인터를 대입</p>

        <ul>
          <li>
            <p>free() 한 뒤에 바로 NULL을 대입해줍니다. 다음에 누가 해당 변수를 호출해도 메모리는 안전합니다.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="n">nums</span><span class="p">;</span>
<span class="cm">/* 코드 생략 */</span>
<span class="n">nums</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">LENGTH</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="cm">/* 코드 생략 */</span>
<span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
<span class="n">nums</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="234-free는-몇-바이트를-해제할지-어떻게-알지-calloc-memset-realloc">234. free()는 몇 바이트를 해제할지 어떻게 알지?, calloc(), memset(), realloc()</h2>

<hr />

<ul>
  <li>free()를 호출할 땐 몇 바이트를 해제할지 어떻게 알까요? 분명 주소만 넘기는데
    <ul>
      <li>운영체제의 구현마다 다르긴 하지만 보통 malloc(??)을 하면 보통 ??보다 조금 큰 메모리를 할당한 다음, 그 조금 큰 부분에 힙 관리자가 쓸 데이터들을 저장해 둡니다.</li>
      <li>프로그램에게 돌려주는 주소는 그 조금 더 큰 데이터 뒤에 실제 사용할 메모리의 주소를 줍니다.</li>
      <li>그리고 free할 주소를 받아오면, 받은 주소보다 조금 앞에부터 메모리를 해제해줍니다.</li>
      <li>확인은 직접 메모리를 까보면 됩니다!</li>
    </ul>
  </li>
</ul>

<h3 id="calloc">calloc()</h3>

<ul>
  <li>
    <p><code class="highlighter-rouge">void* calloc(size_t num, size_t size);</code></p>
  </li>
  <li>
    <p>c의 의미는 의견이 분분합니다. 😮😮</p>

    <ul>
      <li>counted alloc</li>
      <li>clear alloc</li>
      <li>C alloc</li>
    </ul>
  </li>
  <li>
    <p>메모리를 할당할 대 자료형의 크기와 수를 따로 지정합니다.</p>
  </li>
  <li>
    <p>모든 바이트를 0으로 초기화 해줍니다.</p>
  </li>
  <li>
    <p>잘 쓰진 않습니다. calloc 대신 malloc과 memset을 함께 씁니다.</p>

    <ul>
      <li>memset은 0 이외의 값으로도 초기화 가능합니다.</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="n">nums</span><span class="p">;</span>
  
<span class="n">nums</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">LENGTH</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  
<span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
<span class="n">nums</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="n">nums</span><span class="p">;</span>
  
<span class="n">nums</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">LENGTH</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">memset</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LENGTH</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  
<span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
<span class="n">nums</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="memset">memset()</h3>

<ul>
  <li>
    <p><code class="highlighter-rouge">void* memset(void* dest, int ch, size_t count);</code></p>
  </li>
  <li>
    <string.h>에 있습니다.

</string.h>
  </li>
  <li>
    <p>char로 1바이트씩 초기화됩니다.</p>
  </li>
  <li>
    <p>그 외의 바이트수 단위로 초기화 하려면 직접 for문으로 초기화해줘야 합니다.</p>
  </li>
  <li>
    <p>count가 dest의 영역을 넘어설 경우나, dest가 널 포인터의 경우 결과는 undefined입니다.</p>
  </li>
  <li>
    <p>memset은 char로만 초기화 합니다.(1바이트씩 초기화 합니다.)</p>
  </li>
  <li>
    <p>int로 초기화 하고 싶다면.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="n">nums</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  
<span class="n">nums</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">LENGTH</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span>
  
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
<span class="n">nums</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="realloc">realloc()</h3>

<ul>
  <li><code class="highlighter-rouge">void* realloc(void* ptr, size_t new_size);</code></li>
  <li>이미 존재하는 메모리(ptr)의 크기를 new_size 바이트로 변경합니다.</li>
  <li>새로운 크기가 허용하는 한 기존 데이터를 그대로 유지됩니다.(4바이트를 10바이트로 늘리면 4바이트 그대로 들어있고, 10바이트를 4바이트로 줄이면 10바이트안의 4바이트는 유지합니다.)</li>
  <li>배열의 크기를 동적으로 조절할 때 사용할 수 있습니다.</li>
  <li>돌려주는 주소는 기존 주소일 수도, 아닐 수도 있습니다.(랜덤입니다.)</li>
  <li><code class="highlighter-rouge">nums = realloc(NULL, LENGTH);</code> 와 같이 NULL을 재할당 하려고 하면 새로운 메모리를 할당해줍니다. 뭐 거의 안쓰입니다.</li>
</ul>

<h2 id="235-realloc의-메모리-누수-문제-memcpy">235. realloc()의 메모리 누수 문제, memcpy()</h2>

<hr />

<ul>
  <li>
    <p>realloc엔 중요한 문제가 있습니다. realloc에 성공시 새롭게 할당된 주소를 주고 기존 주소는 free해줍니다. 하지만, <strong>실패 시엔 NULL을 반환해주지만 기존 메모리는 해제하지 않습니다.</strong> 즉, 메모리 누수가 될 수 있습니다.</p>
  </li>
  <li>
    <p>때문에, 임시 변수를 사용해 재할당 하는 게 올바른 realloc 입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="n">nums</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">tmp</span><span class="p">;</span>
  
<span class="n">nums</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">SIZE</span><span class="p">);</span>
	<span class="o">:</span>
<span class="n">tmp</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">SIZE</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
	<span class="n">nums</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
	<span class="o">:</span>
<span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>realloc은 malloc + memcpy + free 와 유사합니다. 위 realloc을 아래와 같이 쓸 수 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="n">nums</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">tmp</span><span class="p">;</span>
  
<span class="n">nums</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">SIZE</span><span class="p">);</span>
	<span class="o">:</span>
<span class="n">tmp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">SIZE</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">SIZE</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
	<span class="n">nums</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
	<span class="o">:</span>
<span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>realloc은 임시변수를 안쓰면 무조건 메모리 누수의 위험이 있습니다. 차라리 malloc + memcpy + free로 명시적으로 쓰는게 낫습니다.</p>
  </li>
</ul>

<h3 id="memcpy">memcpy()</h3>

<ul>
  <li><code class="highlighter-rouge">void* memcpy(void* dest, const void* src, size_t);</code></li>
  <li>
    <string.h>에 있습니다.
</string.h>
  </li>
  <li>src의 데이터를 count 바이트만큼 dest에 복사합니다.</li>
  <li>dest영역을 넘어서 데이터를 복사할 경우(소유하지 않은 메모리에 쓰기), src나 dest가 널 포인터인 경우(널포인터 역참조) 결과는 undefined 입니다.</li>
</ul>

<h2 id="236-memcmp-정적-vs-동적-메모리">236. memcmp(), 정적 vs 동적 메모리</h2>

<hr />

<ul>
  <li>여러줄 입력 받아 출력하는 예시 코드</li>
</ul>

<h3 id="memcmp">memcmp()</h3>

<ul>
  <li>
    <p><code class="highlighter-rouge">int memcmp(const void* lhs, const void* rhs, size_t count);</code></p>
  </li>
  <li>
    <p>첫 count 바이트 만큼의 메모리를 비교합니다.</p>
  </li>
  <li>
    <p>strcmp()와 비슷합니다. 단, 널 문자를 만나도 계속 진행됩니다.</p>
  </li>
  <li>
    <p>결과가 undefined 인 경우</p>

    <ul>
      <li>lhs와 rhs의 크기를 넘어 비교할 경우 (소유하지 않은 메모리에 쓰기)</li>
      <li>lhs나 rhs가 널 포인터일 경우 (널 포인터 역참조)</li>
    </ul>
  </li>
  <li>
    <p>memcmp를 이용해 구조체 두 개를 비교하는 예</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">firstname</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">lastname</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span> <span class="n">student_t</span><span class="p">;</span>
  
<span class="o">:</span>
  
<span class="n">student_t</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Lulu"</span><span class="p">,</span> <span class="s">"Kim"</span><span class="p">,</span> <span class="mi">12345</span><span class="p">};</span>
<span class="n">student_t</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Teemo"</span><span class="p">,</span> <span class="s">"Park"</span><span class="p">,</span> <span class="mi">12341</span><span class="p">};</span>
<span class="n">student_t</span> <span class="n">s3</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Lulu"</span><span class="p">,</span> <span class="s">"Choi"</span><span class="p">,</span> <span class="mi">12351</span><span class="p">};</span>
<span class="n">student_t</span> <span class="n">s4</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Teemo"</span><span class="p">,</span> <span class="s">"Park"</span><span class="p">,</span> <span class="mi">12349</span><span class="p">};</span>
  
<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  
<span class="n">result</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">student_t</span><span class="p">));</span> 
<span class="cm">/* Lulu &gt; Teemo, -1 */</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s3</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">student_t</span><span class="p">));</span> 
<span class="cm">/* Kim &gt; Choi, 1 */</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s4</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">student_t</span><span class="p">));</span> 
<span class="cm">/* 12349 &gt; 12341, 1 */</span>
</code></pre></div>    </div>

    <ul>
      <li>단, 구조체 비교에서 구조체 안에 포인터 변수가 있을 때 두 포인터가 가리키는 값이 같더라도 주소가 다르므로 memcmp시엔 다른 결과가 나올 수 있습니다.
        <ul>
          <li>자바에서 두 객체를 ==로 비교하면 주소 비교하는 그런거랑 비슷합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="구조체-멤버-변수---배열-vs-포인터">구조체 멤버 변수 - 배열 vs 포인터</h3>

<ul>
  <li>
    <p>고정된 길이 배열</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
	<span class="kt">char</span> <span class="n">firstname</span><span class="p">[</span><span class="n">NAME_LEN</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">lastname</span><span class="p">[</span><span class="n">NAME_LEN</span><span class="p">];</span>
<span class="p">}</span> <span class="n">name_fixed_t</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>그대로 대입 가능</li>
      <li>파일에 곧바로 저장 가능</li>
      <li>memcpy()를 곧바로 사용 가능</li>
      <li>낭비하는 용량이 있음</li>
      <li>메모리 할당/해제 속도 빠름</li>
      <li>크기가 제한 되면 이 방법을 더 많이 씁니다.</li>
    </ul>
  </li>
  <li>
    <p>동적 메모리를 사용하는 포인터</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">firstname</span><span class="p">;</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">lastname</span><span class="p">;</span>
<span class="p">}</span> <span class="n">name_dynamic_t</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>그대로 대입 불가 - 얕은 복사가 되기 때문에</li>
      <li>파일에 곧바로 저장 불가능</li>
      <li>memcpy() 곧바로 사용 불가능</li>
      <li>낭비하는 용량 없음</li>
      <li>메모리 할당/해제 속도 느림</li>
    </ul>
  </li>
  <li>
    <p>베스트 프랙티스</p>
    <ul>
      <li>정적 메모리를 우선적으로 사용할 것. 훌륭한 C 프로그래머들은 최대한 정적 메모리를 쓰려고 합니다. 동적 메모리는 실수의 여지도 있고 시간도 더 걸립니다.</li>
    </ul>
  </li>
</ul>

<h2 id="237-동적-메모리의-소유권-문제">237. 동적 메모리의 소유권 문제</h2>

<hr />

<ul>
  <li>
    <p>할당된 메모리는 해제를 해줘야 합니다. 그런데 누가 해제를 할 것인지에 대한게 동적 메모리의 소유권 문제입니다.</p>
  </li>
  <li>
    <p>소유주란 메모리를 반드시 책임지고 해제해야 하는 주체입니다.</p>
  </li>
  <li>
    <p>동적으로 할당한 메모리의 기본적인 소유주는 메모리를 생성한 함수 입니다. 기본적으론 할당한 함수에서 해제하는게 맞습니다. 그런데 할당한 함수에서 해제하기 애매한 함수들이 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="nf">combine_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">){</span>
	<span class="kt">void</span><span class="o">*</span> <span class="n">str</span><span class="p">;</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
	<span class="cm">/* a와 b 두 길이 합친걸 size에 할당 */</span>
	<span class="n">str</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="cm">/* a, b 문자열을 str에 복사 */</span>
	<span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">result</span> <span class="o">=</span> <span class="n">combine_string</span><span class="p">(</span><span class="s">"Hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>일단, combine_string 함수에서 새로운 메모리를 할당 받았지만 해제하진 않습니다. 그런데 이 함수의 사용자는 combine_string 함수가 메모리를 동적 할당하는 지 모를 수도 있습니다.</p>
      </li>
      <li>
        <p>C++에서는 이런 문제를 RAII (Resource Acquisition Is Initialization, 자원 획득은 초기화)라는 방법으로 해결합니다.</p>

        <ul>
          <li>한 객체가 생성될 때 필요한 메모리를 할당합니다.(생성자라는 특별한 함수)</li>
          <li>객체의 수명이 다할때 메모리를 해제합니다.(소멸자라는 특별한 함수)</li>
          <li>객체의 수명이라는 범위에 메모리의 수명을 종속 시킵니다.</li>
          <li>하지만 C에는 객체라는 개념이 없습니다.</li>
        </ul>
      </li>
      <li>
        <p>C에선 RAII 같은 방법을 쓸 수 없습니다. 일단, 최대한 이런 함수를 작성하지 맙시다. 위와 같은 함수에선 포인터를 반환하는게 아니라, 결과를 담아줄 포인터를 매개변수로 받읍시다.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">combine_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">out_str</span><span class="p">){</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
	<span class="cm">/* a와 b 두 길이 합친걸 size에 할당 */</span>
	<span class="n">out_str</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="cm">/* a, b 문자열을 str에 복사 */</span>
	<span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <ul>
          <li>combine_string을 호출하는 함수 안에서 주소를 malloc, free 하도록 합시다.</li>
        </ul>
      </li>
      <li>
        <p>하지만 위와 같은 방법으로도 할 수 없을 때가 있습니다. 이럴 땐 함수, 변수 이름에 잘 드러나게 써줍시다. (주석은 안보는 사람도 많습니다.. ㅜㅜ)</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">*</span> <span class="nf">combine_string_malloc</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">b</span><span class="p">){</span>
	<span class="kt">void</span><span class="o">*</span> <span class="n">pa_str</span><span class="p">;</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
	<span class="cm">/* a와 b 두 길이 합친걸 size에 할당 */</span>
	<span class="n">pa_str</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="cm">/* a, b 문자열을 str에 복사 */</span>
	<span class="k">return</span> <span class="n">pa_str</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <ul>
          <li>함수명 끝에 _malloc을 붙여 메모리를 할당하는 함수라는 걸 알려주고</li>
          <li>할당하는 변수엔 pa_(pointer allocated) 라고 써줍시다. 변수명도 이렇게 해두면 IDE에서 보여줍니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Best Practice</p>

    <ul>
      <li>malloc 작성한 뒤엔 곧바로 free 추가하기
        <ul>
          <li>중간에 return 할 수 있는 함수는 goto문을 이용해 free_and_return 하도록 합시다.</li>
        </ul>
      </li>
      <li>동적 할당한 메모리 주소를 저장하는 포인터 변수와, 포인터 연산에 사용하는 포인터 변수를 분리해 사용합시다.
        <ul>
          <li>원래 할당한 변수로 연산하다보면 중간에 그 주소를 잃어 버릴 수도 있습니다.</li>
        </ul>
      </li>
      <li>메모리 해제 후 널 포인터를 대입합시다.
        <ul>
          <li>free를 두번 할 경우 undefined한 결과를 막기 위해</li>
        </ul>
      </li>
      <li>정적 메모리를 우선적으로 사용하고, 어쩔 수 없을 때만 동적 메모리를 사용합시다.</li>
      <li>동적 메모리를 할당하고 자체적으로 free를 안하는 함수는 변수와 함수 이름에 표기를 해줍시다.</li>
    </ul>
  </li>
</ul>

<h2 id="238-다중-포인터-이중-포인터">238. 다중 포인터, 이중 포인터</h2>

<hr />

<ul>
  <li>
    <p>여기가 C에서 배울 것의 마지막이고 다중 포인터, 이중 포인터 뒤로는 지금까지 배운걸 활용하면서 심화하는 것입니다.</p>
  </li>
  <li>
    <p><strong>포인터는 주소를 저장하는 변수다!</strong> 라는 개념을 잊지 맙시다.</p>
  </li>
  <li>
    <p>이중 포인터란 포인터 변수의 주소를 저장하는 변수를 이중 포인터라고 합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>
<span class="kt">int</span><span class="o">**</span> <span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span> <span class="cm">/* (int*)* */</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>퀴즈 - 아래 코드 시행 후 각 변수들의 값은?</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num1</span><span class="p">;</span> <span class="cm">/* num1의 주소: 0x100 */</span>
<span class="kt">int</span> <span class="n">num2</span><span class="p">;</span> <span class="cm">/* num2의 주소: 0x104 */</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>   <span class="cm">/* p의 주소: 0x108 */</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>   <span class="cm">/* q의 주소: 0x10C */</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">r</span><span class="p">;</span>   <span class="cm">/* r의 주소: 0x110 */</span>
<span class="kt">int</span><span class="o">**</span> <span class="n">pp</span><span class="p">;</span> <span class="cm">/* pp의 주소: 0x114 */</span>
   
<span class="n">num1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">num2</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
   
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num1</span><span class="p">;</span>
<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num2</span><span class="p">;</span>
<span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num1</span><span class="p">;</span>
   
<span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">;</span>
<span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
<span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">;</span>
<span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
변수  주소   값
num1 0x100 2048
num2 0x104 1024
p    0x108 0x104
q    0x10C 0x104
r    0x110 0x100
pp   0x114 0x110
*/</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="239-다중-포인터를-쓰는-이유-다중-포인터-예">239. 다중 포인터를 쓰는 이유, 다중 포인터 예</h2>

<hr />

<ul>
  <li>위 퀴즈 설명중…</li>
  <li>여러 겹의 다중 포인터도 가능은 합니다. <code class="highlighter-rouge">int***** a = &amp;b;</code> 근데 2중 포인터는 많이 쓰지만(2중 배열 쓸 때..) 3중 포인터부터 거의 안씁니다.(3차원 배열을 다뤄야할 경우엔 쓰곤 합니다.)</li>
  <li>메인 함수에서 <code class="highlighter-rouge">int main(int argc, char* argv[]);</code> 를 자주 보는데 <code class="highlighter-rouge">char* argv[]</code>가 배열의 배열이니 사실 <code class="highlighter-rouge">char** argv</code>라고 쓸 수도 있습니다.</li>
  <li>다중 포인터를 활용한 swap 함수..</li>
</ul>

<h2 id="240-코드보기--단어-정렬">240. 코드보기 : 단어 정렬</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="cp">#include "string_comparer.h" 
</span>
<span class="k">enum</span> <span class="p">{</span><span class="n">NUM_WORDS</span> <span class="o">=</span> <span class="mi">6</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">words</span><span class="p">[</span><span class="n">NUM_WORDS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">"premium"</span><span class="p">,</span> <span class="s">"level"</span><span class="p">,</span> <span class="s">"cultured"</span><span class="p">,</span> <span class="s">"moaning"</span><span class="p">,</span> <span class="s">"skinny"</span><span class="p">,</span> <span class="s">"curve"</span>
    <span class="p">};</span>
    
    <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">== sort ascending =="</span><span class="p">);</span>
    
    <span class="n">qsort</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">NUM_WORDS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">),</span> <span class="n">compare_string</span><span class="p">);</span>
    
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NUM_WORDS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    
    <span class="n">puts</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">== sort descending =="</span><span class="p">);</span>
    
    <span class="n">qosrt</span><span class="p">(</span><span class="n">words</span><span class="p">,</span> <span class="n">NUM_WORDS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">),</span> <span class="n">compare_string_desc</span><span class="p">);</span>
    
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">NUM_WORDS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;string.h&gt;
#include "string_comparer.h"
</span>
<span class="kt">int</span> <span class="nf">compare_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">b</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">w0</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">w1</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="o">*</span><span class="n">w0</span><span class="p">,</span> <span class="o">*</span><span class="n">w1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">compare_string_desc</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">b</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">w0</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">w1</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">**</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="o">*</span><span class="n">w1</span><span class="p">,</span> <span class="o">*</span><span class="n">w0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="241-정리">241. 정리</h2>

<hr />

<ul>
  <li>이번 섹션에서 배운 것
    <ul>
      <li>메모리의 종류</li>
      <li>동적 메모리</li>
      <li>다중 포인터</li>
    </ul>
  </li>
</ul>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
