<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      C Unmanaged Programming 3 - 빌드과정 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/nonuse/static/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/nonuse/static/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Algorithm">Algorithm</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Java">Java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Spring">Spring</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Data_Structure">Data_Structure</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Network">Network</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">C Unmanaged Programming 3 - 빌드과정</h1>
  <span class="post-date"></span>
  
<ul>
  <li>
    <p>해당 포스팅은 <a href="https://www.udemy.com/course/c-unmanaged-programming-by-pocu/">Kim Pope 선생님의 C 언매니지드 프로그래밍 강의</a>를 정리하며 사견을 붙인 것입니다.</p>
  </li>
  <li>
    <p>포스팅 내 목차는 동영상강의 기준입니다.</p>
  </li>
</ul>

<h2 id="63-소스코드에서-실행파일까지-c-프로그램의-빌드-과정">63. 소스코드에서 실행파일까지, C 프로그램의 빌드 과정</h2>

<hr />

<ul>
  <li>C에서 만든 컴파일 모델의 뼈대는 다른 언어들에서도 사용합니다.</li>
</ul>

<h3 id="c-프로그램의-빌드-과정">C 프로그램의 빌드 과정</h3>

<ul>
  <li>
    <p>빌드란?</p>

    <ul>
      <li>사람이 읽기 쉬운 소스코드를 기계어 명령어로 변환 하는 과정</li>
      <li>명령어들을 모아 기계에서 실행 가능한 실행 파일로 만드는 과정</li>
    </ul>
  </li>
  <li>
    <p>빌드의 단계</p>

    <ol>
      <li>전처리(preprocessing)</li>
      <li>컴파일(compilation)</li>
      <li>어셈블(assembling)</li>
      <li>링크(linking)</li>
    </ol>
  </li>
  <li>
    <p>2, 3 단계를 합쳐 컴파일이라고도 부르고, 1, 2, 3 단계를 합쳐서 컴파일이라고도 부릅니다.</p>
  </li>
  <li>
    <p>각 과정을 크게보면 다음과 같습니다.</p>
  </li>
  <li>
    <p>소스코드(.h, .c) <br />–[전처리기]–&gt; 확장된 소스코드(트랜스레이션 유닛) <br />–[컴파일러]–&gt; 어셈블리 코드 <br />–[어셈블러]–&gt; 오브젝트 코드 <br />–[링커]–&gt; 실행파일(.exe, .out)</p>
  </li>
  <li>
    <p>강의에서 사용하던 clang은 clang 명령어로 소스코드를 바로 실행파일로 만듭니다. 하지만 clang에서도 옵션을 주면 한 단계씩 실행 가능합니다.</p>

    <ul>
      <li>현업에선 최소 2단계로는 나눠 사용합니다.(컴파일, 링크)</li>
    </ul>
  </li>
  <li>
    <p>조만간 강의에서 볼 코드는 다음과 같이 이루어져 있습니다.</p>

    <ul>
      <li>func.h 👉 함수 헤더파일(함수 선언부)</li>
      <li>func.c 👉 함수 구현파일</li>
      <li>main.c 👉 실행 파일</li>
    </ul>
  </li>
  <li>
    <p>조만간 쓸 명령어는 다음과 같습니다. 각 옵션은 <a href="https://clang.llvm.org/docs/UsersManual.html">여기</a>를 참고해주세요!</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -std=c89 -W -Wall -pedantic-errors *.c
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="64-h와-c-파일">64. .h와 .c 파일</h2>

<hr />

<ul>
  <li>C# 에선 func.cs 와 main.cs만 있었지만 C에선 func.h, func.c 로 헤더를 분리해줍니다. 컴퓨터 성능이 안좋던 시절에 더 효율적으로 만들기 위해 나눴습니다.</li>
</ul>

<h3 id="c-파일">C 파일</h3>

<ul>
  <li>실제 로직 코드들입니다. 함수 정의(== 함수 구현), 전역변수, 매크로 등이 들어갑니다.</li>
</ul>

<h3 id="헤더-파일">헤더 파일</h3>

<ul>
  <li>여러 소스코드 파일에 공통적으로 필요한 것들을 저장해 두는 파일입니다.</li>
  <li>함수 선언, 매크로, extern 변수선언 등이 들어갑니다.</li>
  <li>#include를 통해 다른 파일에 들어갑니다. 컴파일 과정에서 #include는 단순 텍스트 복분입니다.</li>
</ul>

<h3 id="예시">예시</h3>

<ul>
  <li>
    <p>아래와 같은 상황을 가정합시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* adder.c */</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>앞서 말했듯이 지금 같은 상황에서 main 함수는 add를 모르기 때문에 컴파일 되지 않습니다.</li>
    </ul>
  </li>
  <li>
    <p>이걸 컴파일 하기 위해서 add 함수의 원형을 알아야 합니다. 원형을 알려주는게 헤더 파일입니다. 헤더파일을 작성하고 adder.c 와 main.c에 해당 헤더 파일을 복붙 하겠다는 의미의 #include를 써줍니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* adder.h */</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* adder.c */</span>
<span class="cp">#include "adder.h"
</span><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>
<span class="cp">#include "adder.h"
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="65-헤더-파일이-필요한-이유">65. 헤더 파일이 필요한 이유</h2>

<hr />

<ul>
  <li>사실, 헤더 파일이 필수적이진 않습니다. adder.c를 include 할 수도 있고 main.c에 모든 소스를 다 넣을 수도 있습니다.</li>
  <li>하지만 우선 작업의 편의상 파일을 나누는건 당연합니다. 한 파일에 100만 줄을 작성할 순 없습니다.</li>
  <li>그런데 파일을 나눠 놓고 보면 동일한 함수를 다른 파일에서 쓸 때 문제가 됩니다.
    <ul>
      <li>이때 복붙으로 쓸 함수를 다른 파일로 옮겨오면… 혼나야 합니다.</li>
    </ul>
  </li>
  <li>이때 헤더파일을 사용하면 함수 선언을 여러 C 파일끼리 공유가능합니다. (다른 언어들은 더 똑똑하기 때문에 굳이 헤더파일을 작성할 필요가 없습니다. 언어쪽에서 해줍니다.)</li>
  <li>그렇다면, 함수 선언 부분만 include 했는데 어떻게 프로그램이 돌까요?
    <ul>
      <li>빌드가 여러 단계로 나뉜 이유입니다. 정의 없이 선언만으로 컴파일이 가능하고, 선언부에 정의를 옮겨 주는게 링크 단계입니다.</li>
    </ul>
  </li>
</ul>

<h2 id="66-include--와-include-">66. #include &lt;&gt; 와 #include “”</h2>

<hr />

<ul>
  <li>두 방식은 <strong>디스크 상의 어느 위치에서 헤더 파일을 찾느냐</strong> 차이입니다.</li>
  <li>#include &lt;&gt;
    <ul>
      <li>시스템 경로에서만 헤더 파일을 검색합니다.</li>
      <li><strong>컴파일러가 제공하는 시스템 헤더 파일을 인클루드 할 때</strong> 사용합니다.</li>
    </ul>
  </li>
  <li>#include “”
    <ul>
      <li>현재 작업중인 디렉터리에서 헤더 파일을 먼저 검색합니다.</li>
      <li>없으면 시스템 경로를 검색합니다.</li>
      <li>개발자가 구현한 헤더파일을 인클루드 할 때 사용합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="67-빌드-과정--전처리-단계">67. 빌드 과정 : 전처리 단계</h2>

<hr />

<ul>
  <li>앞서 말했듯이 전처리 단계는 <strong>“소스코드 👉 확장된 소스 코드(트랜스레이션 유닛)”</strong> 과정입니다.</li>
  <li>전처리기라는 별도의 프로그램이 담당합니다.</li>
  <li>전처리기는 다음과 같은 일을 합니다.
    <ul>
      <li>주석 제거</li>
      <li>매크로를 확장 합니다.(복붙 합니다.)</li>
      <li>인클루드 파일들을 확장 합니다.(복붙 합니다.)
        <ul>
          <li>C 전처리기는 사실 #include 가 붙으면 파일 형식을 가리지 않고 붙여 넣습니다.</li>
        </ul>
      </li>
      <li>컴파일의 기본 단위인 확장된 소스 코드(translation unit)을 돌려줍니다.</li>
    </ul>
  </li>
</ul>

<h2 id="68-트랜슬레이션-유닛-보는-방법">68. 트랜슬레이션 유닛 보는 방법</h2>

<hr />

<ul>
  <li>
    <p>컴파일 할 때 ‘-E’ 플래그를 주면 됩니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -E {filename}.c
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 명령어로는 콘솔 에서만 보입니다. 파일로 따로 보고 싶으면 출력 리디렉션(output redirection) 이라는 콘솔의 기능을 쓰면 됩니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -E {filename}.c &gt; {filename}.pre
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="69-빌드-과정--컴파일-단계">69. 빌드 과정 : 컴파일 단계</h2>

<hr />

<ul>
  <li>컴파일 단계는 <strong>“확장된 소스코드 👉 어셈블리 코드”</strong> 과정입니다.</li>
  <li>컴파일러가 담당합니다.</li>
  <li>어셈블리어는 기계 코드와 거의 1:1로 대응됩니다. 하지만, 어셈블리어 조차 원래 사람들이 쓰기 쉬우라고 만들어진 프로그래밍 언어입니다.</li>
  <li>어셈블리어는 아직 정의를 모르는 심볼(함수나 변수 이름)을 사용할 수 있습니다. 때문에 헤더 파일만 이용해도 컴파일이 가능합니다.</li>
  <li>컴파일러가 선언만 찾고 정의를 못찾으면 그 부분은 구멍만 남겨 둡니다.(어떤 주소가 들어갈 지 비워 둡니다.) 필요한 함수 주소를 메우는건 링크 단계입니다.</li>
</ul>

<h2 id="70-어셈블리어-코드-보는-방법">70. 어셈블리어 코드 보는 방법</h2>

<hr />

<ul>
  <li>
    <p>플래그 ‘-S’ 를 쓰면 어셈블리어 코드가 .s 파일로 저장됩니다. (출력 리디렉션 안해도 저장해줍니다.)</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -S {filename}.c
</code></pre></div>    </div>
  </li>
  <li>
    <p>어셈블리어가 기계어랑 1:1로 대응 된다는 뜻은, 컴파일이 된다면 해당 기계에서만 돈다는 뜻입니다. 기계마다 사용하는 명령어도 다르고 대응하는 어셈블리어도 다르기 때문입니다.</p>

    <ul>
      <li>컴파일러 만드는 개발자들은 도대체 어떤 분들인지…</li>
    </ul>
  </li>
</ul>

<h2 id="71-빌드-과정--어셈블-단계">71. 빌드 과정 : 어셈블 단계</h2>

<hr />

<ul>
  <li>어셈블 단계는 <strong>“어셈블리 코드 👉 오브젝트 코드”</strong> 단계입니다.</li>
  <li>어셈블러가 담당합니다. 어셈블리어와 기계어가 거의 1:1 대응 한다고 했는데, 바로 그 일을 합니다.</li>
  <li>오브젝트 코드란
    <ul>
      <li>기계가 이해 가능한 기계코드 입니다. 기계어라고도 합니다.</li>
      <li>오브젝트 코드에도 아직 메꿔야 하는 구멍이 있습니다.(컴파일 할 때 비워 놓은 부분)</li>
      <li>여기부턴 사람이 읽기 힘듭니다..</li>
    </ul>
  </li>
</ul>

<h2 id="72-오브젝트-코드-보는-방법">72. 오브젝트 코드 보는 방법</h2>

<hr />

<ul>
  <li>
    <p>-c 플래그를 넣으면 .o 파일로 저장됩니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -c {filename}.c
</code></pre></div>    </div>
  </li>
  <li>
    <p>출력된 .o 파일은 이진 파일이라 일반 텍스트 편집기로 열 순 없습니다. 16진수 편집기로 열어야 합니다.</p>

    <ul>
      <li>선생님이 사용하는 16진수 편집기 <a href="https://mh-nexus.de/en/hxd/">HxD</a></li>
    </ul>
  </li>
  <li>
    <p>main.c에서 뽑은 오브젝트 코드를 보면 뚫어 놓은 add 함수 구멍이 아직 매꿔지지 않았음을 볼 수 있습니다. 레이블을 남겨둡니다.</p>

    <p class="p_img"><img src="/nonuse/static/image//obj_code.png" alt="obj_code.png" /><small>add 부분이 레이블로 남겨져있다.</small></p>
  </li>
</ul>

<h2 id="73-빌드-과정--링크-단계">73. 빌드 과정 : 링크 단계</h2>

<hr />

<ul>
  <li>
    <p>링크 단계는 <strong>“오브젝트 코드 👉 실행 파일”</strong> 단계입니다.</p>
  </li>
  <li>
    <p>링커가 담당합니다.</p>
  </li>
  <li>
    <p>링커에 들어가는 입력은 모든 오브젝트 코드들입니다. 오브젝트 코드들의 구멍을 메꾸고 실행 파일을 만듭니다.</p>
  </li>
  <li>
    <p>링커가 오브젝트 코드들을 돌면서 각 함수의 시작 주소를 기억합니다. 그리고 돌면서 레이블로 남겨진 함수를 발견 하면 레이블 부분에 해당 함수의 주소로 점프 하는 코드를 넣습니다.</p>

    <ul>
      <li>
        <p>링커가 뚫어 놓은 구멍에 해당하는 함수를 찾으면 에러를 뱉습니다. adder.h, adder.c, main.c 중 adder.c를 지우고 컴파일 해보면 아래와 같은 에러가 뜹니다.</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main-5500ed.o : error LNK2019: add 외부 기호(참조 위치: main 함수)에서 확인하지 못했습니다.
a.exe : fatal error LNK1120: 1개의 확인할 수 없는 외부 참조입니다.
clang: error: linker command failed with exit code 1120 (use -v to see invocation)
</code></pre></div>        </div>
      </li>
      <li>
        <p>오류에 친절하게 main-5500ed.o 파일에서 LNK2019 에러가 났다고 뜹니다. 에러를 읽는 스킬이 늘었습니다. 후..</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="74-링크-단계가-분리되어-있는-이유">74. 링크 단계가 분리되어 있는 이유</h2>

<hr />

<ul>
  <li>빌드 단계를 컴파일 / 링크로 나누는 주된 이유입니다.
    <ul>
      <li>컴파일 할 때 함수의 구멍을 남긴다고 했습니다. 이걸 컴파일 과정에서 하려면 한 파일을 컴파일 할 때마다 모든 파일, 함수를 훑어줘야 합니다.  O(n^2) 느낌인가</li>
      <li>각 파일을 컴파일 할 때 함수의 구멍을 메꾼다고 한다면, 구멍을 메꾼 후 파일들을 합칠 때 함수들이 중복되는 문제가 발생합니다.</li>
    </ul>
  </li>
  <li>물론 모든 c파일을 합쳐 컴파일 할 수도 있습니다. 실제로 컴파일 성능을 위해서 하는 경우도 있긴합니다만.. 거의 보기 힘들 겁니다. 1줄만 바꿔도 1만줄 모두 컴파일 하기 때문에..</li>
  <li>결론적으로, 컴파일 / 링크를 나누는게 빠르고 관리 하기도 편합니다.</li>
  <li>업계에선 .o 파일들을 따로 만들고, .o 파일을 .exe로 만드는 과정을 따로 둡니다. clang에서도 .o 파일들 가지고 링크만 할 수도 있습니다.</li>
</ul>

<h2 id="75-라이브러리library-정적동적-라이브러리와-링크">75. 라이브러리(library), 정적/동적 라이브러리와 링크</h2>

<hr />

<ul>
  <li>잘 알고 있는 라이브러리도 이와 같이 만들 수 있습니다.</li>
  <li>라이브러리는 컴파일 했을 때 실행 파일이 아니라 나중에 실행 할 수 있는 함수들을 바이너리로 만들어 놓은 것입니다.
    <ul>
      <li>함수를 기계어로 변환 후 파일로 저장해 놓은 것!</li>
    </ul>
  </li>
  <li>라이브러리엔 정적 라이브러리, 동적 라이브러리가 있습니다.</li>
</ul>

<h3 id="정적-라이브러리">정적 라이브러리</h3>

<ul>
  <li>링킹이 빌드 할 때 일어납니다.</li>
  <li>정적 라이브러리는 함수들을 합쳐서 실행 파일을 만듭니다.</li>
  <li>실행 파일이 커지고 메모리를 더 먹을 순 있으나, 일단 exe에 다 넣어 놓으니 실행 속도가 빠릅니다.</li>
</ul>

<h3 id="동적-라이브러리">동적 라이브러리</h3>

<ul>
  <li>링킹이 파일 실행시 일어납니다.</li>
  <li>동적 라이브러리를 사용하는 실행 파일엔 아직 구멍이 뚫려 있습니다. 실행 파일이 실행 될 때 운영 체제가 빈 구멍을 동적 라이브러리에서 찾아 메꿔줍니다.</li>
  <li>실행 파일 크기가 작아집니다.</li>
  <li>여러 실행 파일이 같은 라이브러리를 공유 할 수 있습니다. 메모리를 절약 할 수 있습니다.</li>
  <li>단점으론 이름이 같지만 버전이 다른 동적 라이브러리를 두 프로그램에서 사용할 때 충돌이 납니다.
    <ul>
      <li>DLL Hell 이라고도 부릅니다.</li>
      <li>A은행, B은행 프로그램이 모두 같은 보안 라이브러리A를 사용하는데 버전이 다르면 충돌이 날 수 있습니다.
        <ul>
          <li>보안 라이브러리A를 만드는 회사가 하위 버전의 호환을 염두에 두고 상위 버전을 만들면 상관 없지만.. 흠…</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="76-분할-컴파일과-전역-변수">76. 분할 컴파일과 전역 변수</h2>

<hr />

<h3 id="분할-컴파일">분할 컴파일</h3>

<ul>
  <li>실제 소스 코드는 파일 수가 수십, 수백 개가 될 수 있습니다.</li>
  <li>컴파일 할 땐 모든 파일들을 개별적으로 컴파일 해 오브젝트 파일을 만듭니다. 후에 오브젝트 파일들을 링크시켜 실행 파일을 만듭니다.
    <ul>
      <li>여러 파일을 컴파일 할 땐 멀티 프로세서에서 따로따로 컴파일 할 수도 있습니다.</li>
      <li>링크는 혼자 해야겠죠.</li>
    </ul>
  </li>
  <li>분할 컴파일 하다가 에러나서 한 파일에 때려 넣는 사람들이 있는데… 하지 마세요</li>
</ul>

<h2 id="77-다른-파일에-있는-전역-변수-사용시-문제점">77. 다른 파일에 있는 전역 변수 사용시 문제점</h2>

<hr />

<ul>
  <li>
    <p>다음과 같은 상황을 가정합시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* monster.h */</span>
<span class="kt">void</span> <span class="nf">add_monster</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* monster.c */</span>
<span class="cp">#include "monster.h"
</span><span class="kt">int</span> <span class="n">g_mob_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">add_monster</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="o">++</span><span class="n">g_mob_count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>
<span class="cp"># include &lt;stdio.h&gt;
# include "monster.h"
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="n">add_monster</span><span class="p">();</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">g_mob_count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>위 코드를 빌드 하려하면 main.c 파일에서 <strong>“use of undeclared identifier ‘g_mob_count’“</strong> 에러가 납니다. main 함수 입장에선 컴파일 할 땐 g_mob_count를 모른다는 뜻입니다. 앞서 알아봤듯이, 파일들 끼리 연결 하는건 컴파일이 끝나고 링크 과정에 일어나니까요.</li>
    </ul>
  </li>
  <li>
    <p>그렇다고 main 함수에 g_mob_count를 넣고 빌드를 하면 어떻게 될까요.</p>

    <ul>
      <li>컴파일은 되지만 링크 과정에서 <strong>“LNK2008 : g_mob_count already defined ~~~”</strong> 에러가 납니다. 같은 전역변수가 겹쳤다는 얘기입니다.</li>
      <li>C에선 동일한 전역변수 이름을 여러 파일에서 못씁니다. 링커가 거절합니다.</li>
    </ul>
  </li>
  <li>
    <p>이를 위해서 main 함수에 새로운 전역 변수를 만드는게 아니라 monster.c 에 있는 전역 변수를 쓸 것이라 선언을 해줘야 합니다.</p>
  </li>
</ul>

<h2 id="78-extern-키워드">78. extern 키워드</h2>

<hr />

<ul>
  <li>
    <p>그것이 extern 입니다. extern 전역변수는 헤더파일에 넣으면 됩니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* monster.h */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">g_mob_count</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">add_monster</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>main.c에 넣어도 되긴 합니다. (안써도 #include “monster.h” 에서 가져옵니다.)</p>

    <ul>
      <li>다른 언어의 접근 지시자랑 비슷합니다.</li>
    </ul>
  </li>
  <li>
    <p>누구라도 쓸 수 있게 하고 싶다면 헤더파일에, 한 파일에서만 쓰게 하고 싶으면 c 파일에 사용합니다.</p>

    <ul>
      <li>모호합니다. C에서 전역 변수 사용을 지양하는 사람들도 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>다음과 같이 extern을 안쓰는 경우에 에러가 날 수 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* monster.h */</span>
<span class="kt">int</span> <span class="n">g_mob_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">add_monster</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li>#include 할때 extern 없는 g_mob_count를 monster.c, main.c 에 모두 복붙하니 링커에서 에러가 납니다.</li>
    </ul>
  </li>
  <li>
    <p>함수 앞에도 extern 붙일 수 있으나, 함수는 안 붙여도 자동 extern 입니다.(함수 뒤에 {} 를 안열고 ; 로 끝나는 걸로 알 수 있습니다.)</p>
  </li>
</ul>

<h2 id="79-코드보기--extern-키워드">79. 코드보기 : extern 키워드</h2>

<hr />

<ul>
  <li>패스</li>
</ul>

<h2 id="80-전역-변수의-문제-static-키워드">80. 전역 변수의 문제, static 키워드</h2>

<hr />

<ul>
  <li>
    <p>‘전역 변수는 쓰지 말라’ 라는 말이 있습니다.</p>
  </li>
  <li>
    <p>우려 할 부분이 있긴 합니다.</p>

    <ul>
      <li>extern 사용시 어떤 파일에서든 접근 할 수 있습니다. 파른 파일에서 자기 파일 안의 변수를 건드릴 수 있습니다. 파일이 많아지면 누가 자기 변수 바꾸는 지 잡기 힘듭니다.
        <ul>
          <li>다른 파일이 자기 전역변수 못쓰게 할 수 있으면 좋겠습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>프로그램이 살아있는 동안 메모리에 있으면서도, 다른 파일에선 접근 못하게 하고 싶을 때 static 키워드를 사용 할 수 있습니다.</p>
  </li>
  <li>
    <p>아까의 예를 다음처럼 쓸 수 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* monster.h */</span>
<span class="kt">void</span> <span class="nf">add_monster</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* monster.c */</span>
<span class="cp">#include "monster.h"
</span><span class="k">static</span> <span class="kt">int</span> <span class="n">s_mob_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">add_monster</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="o">++</span><span class="n">s_mob_count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>
<span class="cp"># include &lt;stdio.h&gt;
# include "monster.h"
</span><span class="k">extern</span> <span class="kt">int</span> <span class="n">s_mob_count</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="n">add_monster</span><span class="p">();</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s_mob_count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>이 상태로 빌드를 하게 된다면 링커 오류가 발생합니다. main.c에선 s_mob_count 전역 변수를 사용하려고 빈칸을 남겨 뒀는데 monster.c에선 static 키워드를 사용했기 때문에 링커에서 main.c에 넣어줄 s_mob_count를 찾지 못합니다.</li>
      <li>static이 어떻게 돌아가는지를 이해하긴 어렵고 일단 이 부분은 익숙해집시다.</li>
    </ul>
  </li>
</ul>

<h3 id="static">static</h3>

<ul>
  <li>변수 범위가 파일로 한정됩니다.</li>
  <li>정적 변수라고 합니다.</li>
  <li>전역 변수이기 때문에 프로그램이 돌 때 계속 메모리를 먹고 있습니다.</li>
</ul>

<h3 id="static-키워드를-지역-변수에-사용할-때">static 키워드를 지역 변수에 사용할 때</h3>

<ul>
  <li>
    <p>다음과 같이 바꿀 수 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* monster.c */</span>
<span class="cp">#include "monster.h"
# include &lt;stdio.h&gt;
</span><span class="kt">void</span> <span class="nf">add_monster</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">s_mob_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="o">++</span><span class="n">s_mob_count</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s_mob_count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>
<span class="cp"># include "monster.h"
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="n">add_monster</span><span class="p">();</span>
	<span class="n">add_monster</span><span class="p">();</span>
	<span class="n">add_monster</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>함수 안에 s_mob_count를 static으로 넣고 0으로 초기화 한다고 써 놓았지만, 실제 위 코드가 돌아가면 1, 2, 3을 찍습니다.</li>
      <li>static 키워드를 함수 안에서 사용하면 <strong>개념상 전역 변수로서 한 번만 초기화 되고 프로그램이 돌 동안 계속 메모리에 올라가있지만, 해당 함수 안에서만 접근 가능합니다.</strong></li>
    </ul>
  </li>
  <li>
    <p>함수 역시 그 파일 안에서만 쓰고 싶으면 static 키워드를 넣으면 됩니다. private과 비슷하네요.</p>
  </li>
</ul>

<h2 id="81-코드보기--static-키워드">81. 코드보기 : static 키워드</h2>

<hr />

<ul>
  <li>패스~</li>
  <li>C에서도 전역 변수 static으로 만들어 놓고 getter/setter를 만들기도 합니다. 객체지향 언어에서 private 걸고 getter/setter 만들 듯이.</li>
</ul>

<h2 id="82-c와-h-파일-정리-순환-헤더-인클루드와-해결법">82. .c와 .h 파일 정리, 순환 헤더 인클루드와 해결법</h2>

<hr />

<h3 id="정리">정리</h3>

<ul>
  <li>빌드 4단계가 돌려면 아래 기본 원칙을 따릅시다.
    <ul>
      <li>헤더 파일엔 선언만 합시다.
        <ul>
          <li>함수선언, 전역변수 extern 선언</li>
        </ul>
      </li>
      <li>.c 파일엔 정의가 들어갑니다.
        <ul>
          <li>함수 정의, 전역 및 정적 변수 정의</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="순환-헤더">순환 헤더</h3>

<ul>
  <li>
    <p>전처리기는 복-붙으로 수행 된다고 했습니다. 근데 인클루드를 순환해서 할 수 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* A.h */</span>
<span class="cp">#include "B.h"
</span><span class="o">~~~</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* B.h */</span>
<span class="cp">#include "C.h"
</span><span class="o">~~~</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* C.h */</span>
<span class="cp">#include "A.h"
</span><span class="o">~~~</span>
</code></pre></div>    </div>

    <ul>
      <li>이 경우 컴파일이 안됩니다. 에러를 내줍니다.</li>
      <li>“순환 헤더 인클루드 (circular header include)” 라고 부르고 “헤더가 꼬였다” 라고도 합니다. 실무에서 자주 발생하는 문제입니다. 다른 언어에선 걱정할 필요 없는 C에서만 나오는 문제입니다.</li>
    </ul>
  </li>
  <li>
    <p>해결1</p>

    <ul>
      <li>#include는 c에서만 합시다.</li>
      <li>b 헤더에서 a 헤더 전체를 인클루드 하지 말고 a에 정의된걸 전방 선언합니다.</li>
      <li>서로 인클루드를 해야만 한다면! <strong>인클루드 가드</strong>를 사용합니다. 순환 헤더를 막는 업계 표준입니다.</li>
    </ul>
  </li>
  <li>
    <p>다음과 같이 인클루드 가드를 씁니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* foo.h */</span>
<span class="cp">#ifndef FOO_H </span><span class="cm">/* if not defined */</span><span class="cp">
#define FOO_H
</span><span class="cm">/* 원래 헤더 파일 내용 */</span>
<span class="cp">#endif FOO_H
</span></code></pre></div>    </div>

    <ul>
      <li>#으로 시작하는 것들은 전처리기가 처리합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="83-인클루드-가드-작동법">83. 인클루드 가드 작동법</h2>

<hr />

<ul>
  <li>인클루드 가드는 다음과 같이 작동합니다.
    <ul>
      <li><code class="highlighter-rouge">#ifndef FOO_H</code> 만약 FOO_H가 정의되지 않았다면</li>
      <li><code class="highlighter-rouge">#define FOO_H</code> 지금부터 FOO_H를 정의해라.</li>
      <li><code class="highlighter-rouge">/* 헤더 파일 내용 */</code> 이렇게</li>
      <li><code class="highlighter-rouge">#endif</code> 정의 끝!</li>
    </ul>
  </li>
  <li>헤더 파일을 조건적으로 컴파일하라고 지시하는 것입니다.</li>
</ul>

<h2 id="84-인클루드-가드-예제">84. 인클루드 가드 예제</h2>

<hr />

<ul>
  <li>패스</li>
  <li>인클루드 가드는 그냥 무조건 넣는다고 생각합시다!</li>
  <li>비슷한 기능으로 #pragma once 라는 키워드도 있습니다. C에서도 되고 간단한데 C 표준은 아닙니다. (그런데 대부분 컴파일러가 지원하긴 합니다.)
    <ul>
      <li>C++ 에선 표준으로 사용합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="85-c-컴파일러의-종류와-특징">85. C 컴파일러의 종류와 특징</h2>

<hr />

<ul>
  <li>C는 표준위원회가 있고 컴파일러들은 다양합니다.</li>
  <li>GCC
    <ul>
      <li>가장 유명한 컴파일러입니다.</li>
      <li>많은 C 표준 대부분을 지원합니다.</li>
    </ul>
  </li>
  <li>MS의 Visual C++
    <ul>
      <li>유명합니다. C++ 컴파일러이긴 한데 C도 컴파일 합니다.</li>
      <li>C99표준을 지원하고 C11은 대부분 지원하지 않습니다.</li>
      <li>윈도우에서만 놀거라면 자주 사용합니다.</li>
    </ul>
  </li>
  <li>Clang
    <ul>
      <li>LLVM 컴파일러 구조를 사용하는 C계열 컴파일러입니다.</li>
      <li>애플이 먼저 개발했으나 이제 구글, MS 등 모두 같이 개발중입니다.</li>
      <li>선생님이 많이 좋아하는 컴파일러 같습니다.</li>
      <li>컴파일 속도도 빠릅니다.</li>
    </ul>
  </li>
  <li>소형기기 컴파일러
    <ul>
      <li>소형기기들은 하드웨어 자체가 다르기 때문에 컴파일러도 다릅니다.</li>
      <li>각 소형기기 마다 맞는 컴파일러를 사용합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="86-정리">86. 정리</h2>

<hr />

<ul>
  <li>1강부터 지금까지 한 걸 정리해 보겠습니다.
    <ul>
      <li>Hello world</li>
      <li>C언어 기본 문법</li>
      <li>스택 메모리가 어떻게 도는지 가볍게
        <ul>
          <li>포인터를 위한 준비운동입니다.</li>
        </ul>
      </li>
      <li>빌드</li>
      <li>분할 컴파일</li>
    </ul>
  </li>
</ul>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
