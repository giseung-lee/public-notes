<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      C Unmanaged Programming 12 - 나만의 라이브러리 만들기, C99 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/nonuse/static/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/nonuse/static/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Algorithm">Algorithm</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Java">Java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Spring">Spring</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Data_Structure">Data_Structure</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Network">Network</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">C Unmanaged Programming 12 - 나만의 라이브러리 만들기, C99</h1>
  <span class="post-date"></span>
  
<h2 id="281-나만의-라이브러리-만들기">281. 나만의 라이브러리 만들기</h2>

<hr />

<ul>
  <li>빌드과정을 배울때 오브젝트 파일이 나온다고 배웠습니다. 오브젝트 파일들을 연결해 exe로 만드는게 아니라 라이브러리로 만들 수 있습니다.</li>
  <li>소스 코드 공개 없이 라이브러리를 만들고 배포할 수 있습니다.(헤더 파일은 예외)</li>
  <li>C에선 두 종류의 라이브러리가 존재합니다.
    <ul>
      <li>정적 라이브러리</li>
      <li>동적 라이브러리</li>
    </ul>
  </li>
  <li>정적 라이브러리와 오브젝트 파일을 링크하는 것을 ‘정적 링킹’이라고 합니다. 라이브러리 안의 기계어를 exe 파일에 복사합니다.
    <ul>
      <li>동적 링킹에 비해 실행 파일 크기 자체가 커지고 메모리를 더 많이 잡아먹습니다.</li>
      <li>동적 링킹에 비해 실행속도가 빠릅니다.(링커가 최적화를 시켜줍니다.)</li>
    </ul>
  </li>
</ul>

<h2 id="282-정적-라이브러리-만들기">282. 정적 라이브러리 만들기</h2>

<hr />

<ul>
  <li>
    <p>정적 라이브러리를 만들고 사용하는 방법은 아래와 같은 순서로 이루어집니다.</p>

    <ul>
      <li>소스 코드를 컴파일 하여 정적 라이브러리를 만듭니다.
        <ul>
          <li>한 라이브러리당 하나의 파일이 만들어집니다.</li>
          <li>윈도우계열에선 *.lib, 리눅스 계열에선 *.a 확장자를 사용합니다.(리눅스에선 라이브러리를 아카이브(archive)라고 부릅니다.)</li>
        </ul>
      </li>
      <li>다른 소스코드들을 작성할 때 정적 라이브러리의 헤더 파일들을 사용합니다.</li>
      <li>컴파일 할 때 정적 라이브러리와 함께 링킹됩니다.</li>
    </ul>
  </li>
  <li>
    <p>정적 라이브러리는 아래와 같은 과정으로 만들어집니다.</p>

    <ul>
      <li>c파일을 컴파일하여 오브젝트 파일을 얻어냅니다.
        <ul>
          <li><code class="highlighter-rouge">&gt; clang -std=c89 -W -Wall -pedantic-errors -c simple_mapth.c -o simple_math.o</code></li>
        </ul>
      </li>
      <li>오브젝트 파일들을 라이브러리로 만들어주는 프로그램을 실행합니다.
        <ul>
          <li>윈도우의 경우 llvm-ar, 리눅스의 경우 ar 을 사용합니다.</li>
          <li><code class="highlighter-rouge">llvm-ar -명령어&lt;modifier&gt; 정적_라이브러리_파일 &lt;o파일들&gt;</code></li>
          <li>명령어 r : 정적_라이브러리_파일에 o파일들을 추가</li>
          <li>명령어 d : 정적_라이브러리_파일에서 o파일들을 삭제</li>
          <li>modifier(선택) : 각 명령어마다 사용할 수 있는 modifier가 다릅니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>정적 라이브러리 만들기 예시</p>

    <ul>
      <li>
        <p>modifier c를 사용하지 않을 때 + o파일을 하나씩 지정</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; llvm-ar -r simple_math.lb simple_math.o
llvm-ar.exe: warning: creating simple_math.lib
</code></pre></div>        </div>
      </li>
      <li>
        <p>modifier c를 사용할 때 + 폴더 안에 있는 모든 o파일들을 지정</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; llvm-ar -rc simple_math.lb *.o
</code></pre></div>        </div>
      </li>
      <li>
        <p>일반적으론 o파일이 저장되어 있는 곳과 lib 파일이 떨어질 곳을 분리합니다.</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>objects &gt; llvm-ar -rc ..\lib\simple_math.lib *.o
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>사용하고 싶은 파일에서 정적 라이브러리의 헤더를 인클루드 합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>
  
<span class="cp">#include &lt;stdio.h&gt;
#include "simple_math.h"
</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>빌드 할 때 정적 라이브러리와 함께 빌드 하라고 명령해줍니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -std-c89 -W -Wall -pedantic-errors -I &lt;dir&gt; -L &lt;dir&gt; -l&lt;lib_name&gt; *.c
</code></pre></div>    </div>

    <ul>
      <li>-I &lt;dir&gt;
        <ul>
          <li>인클루드 할 때 헤더파일을 검색할 경로를 추가합니다.</li>
        </ul>
      </li>
      <li>-L &lt;dir&gt;
        <ul>
          <li>빌드 시 사용할 라이브러리 파일이 있는 폴더를 지정합니다.</li>
        </ul>
      </li>
      <li>-l&lt;lib_name&gt;
        <ul>
          <li>소문자 L, l다음 띄어쓰기 없음, ‘.lib’은 생략</li>
          <li>빌드시 사용할 라이브러리 이름을 지정합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>빌드 명령 예시</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; clang -std=c89 -W -Wall -pedantic-errors -I "../simple_math" -L "../lib" -lsimple_math *.c
</code></pre></div>    </div>
  </li>
  <li>
    <p>명령어로 실행하려면 여러 라이브러리를 직접 같이 빌드하라고 명령해줘야 합니다. 하나씩. 그런데 당연히 불편하기 때문에 IDE에서 제공하는 프로젝트 파일들이 이런 일들을 대신해줍니다.</p>

    <ul>
      <li>proj 파일은 라이브러리를 만들때 어떤 파일들을 컴파일 해야하는 지, 실행파일 만들때 어떤 소스코드와 어떤 라이브러리를 합쳐야 하는 지 등을 적어두는 파일입니다.</li>
      <li>프로젝트 파일이 없더라도 CMake 같은 프로젝트 파일 같은 일을 해주는 프로그램도 있습니다.</li>
      <li>하지만 실무에선 당연히 IDE가 제공하는 기능을 사용합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="283-동적-라이브러리와-링크">283. 동적 라이브러리와 링크</h2>

<hr />

<ul>
  <li>동적 라이브러리와 링크하는 것을 동적 링킹이라고 합니다. 실행 파일이 만들어 져도 아직 실행 파일에 구멍이 남아있습니다. 실행 파일을 실행할 때 실제 링킹이 일어나는 방법입니다. (링킹은 운영체제가 해줍니다.)</li>
  <li>정적 링킹에 비해
    <ul>
      <li>실행 파일 크기가 작습니다.</li>
      <li>여러 실행 파일을 동일한 라이브러리를 공유할 수 있습니다. -&gt; 메모리 절약</li>
      <li>실행 파일 이름은 같지만 버전이 다른 동적 라이브러리를 사용하면 dll 지옥이라는 것을 맛볼 수 있습니다.
        <ul>
          <li>A보안 프로그램에서 1.0 버전의 C 라이브러리를 사용하고, B 보안 프로그램에서 1.2 버전의 C 라이브러리를 사용하면 충돌납니다!</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>동적 라이브러리 사용 절차
    <ul>
      <li>소스코드를 컴파일 해 동적 라이브러리를 만듭니다.
        <ul>
          <li>윈도우의 경우 *.dll, 리눅스계열을 경우 *.so 파일입니다.</li>
        </ul>
      </li>
      <li>다른 소스 코드에서 라이브러리의 헤더 파일을 인클루드 합니다.</li>
      <li>컴파일 할 때 동적 라이브러리와 함께 링킹합니다.
        <ul>
          <li>단, 이때 링킹은 실제 동적 라이브러리의 기계어가 실행 파일에 들어가는 것이 아닙니다.</li>
          <li>실행 중 동적으로 링킹하기 위한 정보만 포함합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>동적 라이브러리와 운영 체제
    <ul>
      <li>동적 라이브러리를 실행시 동적 링킹 해주는 것은 운영체제 입니다.</li>
      <li>운영체제 마다 실행 파일 및 동적 라이브러리 내부 포맷이 다릅니다.
        <ul>
          <li>리눅스 계열 : ELF(executable and linkable format) 포맷</li>
          <li>윈도우 : PE(portable executable) 포맷</li>
        </ul>
      </li>
      <li>운영 체제의 동적 링커가 링킹 해줍니다.
        <ul>
          <li>프로그램이 실행될 때 필요한 동적 라이브러리들을 로딩, 링킹 해줍니다.</li>
          <li>이를 수행하기 위해 동적 라이브러리 함수들을 메모리에 맵핑해둬야 합니다.</li>
          <li>맵핑에 필요한 정보가 위 포맷에 저장되어 있습니다. 즉, 운영체제가 지원하지 않는 포맷은 읽어올 수 없습니다.</li>
        </ul>
      </li>
      <li>윈도우에선 보통 비주얼 스튜디오의 컴파일러를 사용합니다. (물론 clang, GCC를 사용할 수도 있습니다.)</li>
      <li>리눅스 계열은 주로 clang이나 GCC를 이용해 컴파일 합니다.</li>
    </ul>
  </li>
  <li>동적 라이브러리를 만드는 자세한 설명은 생략합니다. (운영체제와 컴파일러 별로 상이한 부분이 많아 모두 설명하려면 양이 많아져서) 필요하면 찾아서 해보세요!!</li>
</ul>

<h2 id="284-정적-vs-동적-라이브러리">284. 정적 vs 동적 라이브러리</h2>

<hr />

<ul>
  <li>정적, 동적 라이브러리는 각각 장단점이 있습니다.</li>
  <li>동적 라이브러리
    <ul>
      <li>장점
        <ul>
          <li>실행 파일을 바꾸지 않고 동적 라이브러리 파일만 업데이트 가능</li>
          <li>동적 라이브러리 파일을 바꾸지 않고 실행 파일만 업데이트 가능</li>
          <li>필요에 따라 동적 라이브러리를 선택적으로 로딩 가능 (ex - CPU 세대별로 최적화된 동적 라이브러리 파일을 만들어 둡니다.)</li>
          <li>여러 실행 파일들이 같은 동적 라이브러리를 공유할 수 있습니다.(메모리 절약 가능)</li>
        </ul>
      </li>
      <li>단점
        <ul>
          <li>dll을 이용한 해킹에 취약 (ex - dll 인젝션)</li>
          <li>dll hell에 빠질 수 있습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>정적 라이브러리
    <ul>
      <li>장점
        <ul>
          <li>함수의 주소가 공개 안되니 조금 더 안전합니다.</li>
          <li>정확한 버전의 라이브러리가 실행 파일 안에 내포되어 있습니다.(dll hell의 위험이 없음)</li>
          <li>최적화에 유리합니다.</li>
        </ul>
      </li>
      <li>단점
        <ul>
          <li>CPU 세대별로 실행 파일을 만들어 배포해야 합니다.</li>
          <li>라이브러리의 소스코드가 바뀔 때 마다 실행 파일을 재배포 해야 합니다.</li>
          <li>실행 파일의 크기가 커집니다.</li>
          <li>실행 중 다른 실행 파일들과 라이브러리 공유 불가합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>베스트 프랙티스
    <ul>
      <li>기본적으로 정적 라이브러리를 사용</li>
      <li>동적 라이브러리가 필요해지면 그때 동적 라이브러리로 전환</li>
    </ul>
  </li>
</ul>

<h2 id="285-c99-표준">285. C99 표준</h2>

<hr />

<ul>
  <li>
    <p>지금까지 C89에 포함되는 C의 기본과 핵심들을 알아봤습니다. 이제부턴 C89에서 불편했던 기능들을 개선한 C99를 알아보겠습니다.</p>
  </li>
  <li>
    <p>단, C99의 기능을 사용할 땐 호환성에 주의해야 합니다. 본인의 프로그램이 실행될 플랫폼들이 모두 C99를 지원하는 지 알아야 합니다.</p>
  </li>
  <li>
    <p>C99로 빌드하기 -&gt; c89를 c99로만 바꾸면 됩니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; clang -std=c99 -W -Wall -pedantic-errors *.c
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="286-인라인-함수">286. 인라인 함수</h2>

<hr />

<ul>
  <li>
    <p>C99의 기능인 인라인 함수를 알아보기 전에 매크로 함수를 복습해봅시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define POW(n, p, i, r) r=1;                 \
                        for (i=0; i&lt;p; ++i){ \
                           r *= n;           \
                        }                    \
</span></code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">POW</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>복-붙으로 처리되기 때문에 함수 호출에 따른 부하를 막을 수 있지만 디버깅이 힘들고 가독성이 떨어지는 함수였습니다.</p>
  </li>
  <li>
    <p>기존 함수에 매크로 함수의 장점만 추가하고 싶어서 만들어진 기능이 인라인 함수 입니다.</p>
  </li>
  <li>
    <p>인라인 함수</p>

    <ul>
      <li>사용은 inline이라는 키워드만 붙여주면 됩니다.</li>
      <li><code class="highlighter-rouge">inline 반환형 함수_이름(매개변수 목록) { } </code></li>
      <li>컴파일러에게 최적화 해달라고 해주는 ‘힌트’입니다. 매크로 함수처럼 코드를 복붙해줍니다.</li>
      <li>컴파일러에 따라 지원 안할 수도 있고, 효율저깅지 않아 무시할 수도 있습니다.</li>
      <li>컴파일러에 따라 inline을 안써도 알아서 최적화 해줄 수도 있습니다.</li>
      <li>인라인 함수를 호출하는 코드를 컴파일 할 때, 컴파일러가 그 함수를 미리 알고 있어야 합니다. 이를 위해 인라인 함수 구현은 소스 파일이 아니라 헤더파일에 둬야 합니다.</li>
    </ul>
  </li>
  <li>
    <p>C의 인라인 함수는 C++에서 가져온 기능입니다. 단, C++의 인라인 함수는 명확하지만 C의 인라인 함수는 명확하지 않은 부분들이 꽤 있습니다.</p>
  </li>
</ul>

<h2 id="287-인라인-함수-제대로-사용하는-법">287. 인라인 함수 제대로 사용하는 법</h2>

<hr />

<ul>
  <li>
    <p>인라인 함수는 아래처럼 헤더 파일에 구현까지 모두 작성합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* simple_math.h */</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op2</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>아래처럼 메인 함수에서 호출하면</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>
<span class="cp">#include "simple_math.h"
#include &lt;stdio.h&gt;
</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="o">*</span> <span class="n">add</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>컴파일러가 아래처럼 바꿔줍니다. (이해를 돕기 위한 것이지 전처리기 처럼 단순한 복붙은 아님)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>
<span class="cp">#include "simple_math.h"
#include &lt;stdio.h&gt;
</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">20</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">30</span> <span class="o">+</span> <span class="mi">50</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>매크로는 그냥 텍스트 자체로 복붙합니다. 괄호로 인한 연산자 우선순위 문제가 생길수도 있고..</p>
  </li>
  <li>
    <p>인라인 함수는 컴파일러가 컴파일 중에 함수 호출을 코드로 바꿔주는 것입니다.</p>
  </li>
  <li>
    <p>복붙을 위해선 함수 구현을 알고 있어야 합니다. 즉, 트랜스레이션 유닛안에 인라인 함수의 구현이 있어야 합니다. 이 말은, 함수의 구현이 다른 C 파일에 있으면 불가능 하다는 것입니다.(C 파일별로 컴파일 되기 때문에) 헤더 파일안에 함수의 구현이 있고, 전처리기에서 헤더 파일을 복붙하면서 함수의 구현을 원하는 C 파일안으로 가져와야 해당 C 파일 컴파일 시 인라인 함수를 적용할 수 있습니다.</p>
  </li>
  <li>
    <p>그런데 헤더에 함수의 구현부를 넣어 사용할 때 유의해야 할 부분이 있습니다. 구현부까지 만들어 놓은 하나의 헤더 파일을 두 개의 c 파일에 인클루드 했다고 가정합시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* simple_math.h */</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">op1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">op2</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">op1</span> <span class="o">+</span> <span class="n">op2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* file1.c */</span>
<span class="cp">#include "simple_math.h"
</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="o">:</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* file2.c */</span>
<span class="cp">#include "simple_math.h"
</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="o">:</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>file1.c와 file2.c를 컴파일해 빌드하려고 하면 링킹 오류가 발생합니다. 전처리기가 include를 하며 file1.c와 file2.c 모두에 add 함수를 넣어 놓는데, 빌드하는 과정에서 같은 이름의 함수가 발견되기 때문입니다.(file1.c의 add와 file2.c의 add)</p>
  </li>
</ul>

<h2 id="288-링킹-오류가-나는-이유">288. 링킹 오류가 나는 이유</h2>

<hr />

<h2 id="289-링킹-오류-해결법">289. 링킹 오류 해결법</h2>

<hr />

<h2 id="290-c-인라인과의-차이">290. C++ 인라인과의 차이</h2>

<hr />


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
