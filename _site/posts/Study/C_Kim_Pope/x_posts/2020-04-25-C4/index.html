<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      C Unmanaged Programming 4 - 포인터 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/About Me">About Me</a>
      
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Sagyo_Reboot">Sagyo_Reboot</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Twitch_Chat_Analysis">Twitch_Chat_Analysis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Algorithm">Algorithm</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/java">java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/jekyll">jekyll</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/linux">linux</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">C Unmanaged Programming 4 - 포인터</h1>
  <span class="post-date"></span>
  
<ul>
  <li>
    <p>해당 포스팅은 <a href="https://www.udemy.com/course/c-unmanaged-programming-by-pocu/">Kim Pope 선생님의 C 언매니지드 프로그래밍 강의</a>를 정리하며 사견을 붙인 것입니다.</p>
  </li>
  <li>
    <p>포스팅 내 목차는 동영상강의 기준입니다.</p>
  </li>
</ul>

<h2 id="87-포인터">87. 포인터</h2>

<hr />

<ul>
  <li>앞서 스택메모리를 알려드린건 지금 이 포인터를 배우기 위함입니다.</li>
  <li>포인트 뒤로 나오는 모든 것들엔 포인터가 필요하다고 보시면 됩니다.</li>
  <li>선생님이 C에서 중요하다고 생각하는 세 가지는 다음과 같습니다.
    <ul>
      <li>포인터</li>
      <li>동적 메모리 할당</li>
      <li>구조체, 공용체를 포인터, 동적 메모리와 함께 쓰는 법</li>
    </ul>
  </li>
</ul>

<h3 id="개발자가-직접-메모리-주소를-이용해-데이터를-바꿀-수-있나요">개발자가 직접 메모리 주소를 이용해 데이터를 바꿀 수 있나요?</h3>

<ul>
  <li>다른 언어였다면 불가능 하지만 C에선 가능합니다. 이걸 잘하면 매우 강력한 일을 할 수 있지만, 잘못 건드리면 흐흐.. 😈</li>
  <li>C가 위험하다, 강력하다 모두 이 포인터 때문입니다.</li>
</ul>

<h2 id="88-주소-연산자-">88. 주소 연산자 \&amp;</h2>

<hr />

<ul>
  <li>
    <p>직접 메모리 주소로 변수를 조작하려면 우선 해당 변수의 주소를 알아야 합니다.</p>
  </li>
  <li>
    <p>아래 코드를 실행해 봅시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print_address</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"address of num is %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">print_address</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
address of num is 00000068ED6FF914
*/</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>\&amp;를 주소 연산자라고 합니다. (비트연산자 \&amp;와 헷갈리지 맙시다. 비트연산자 \&amp;는 피연산자가 2개입니다.)</p>

    <ul>
      <li>\&amp;뒤에 오는 변수의 주소를 돌려줍니다.</li>
    </ul>
  </li>
  <li>
    <p>주소를 표현할 땐 16진수를 사용합니다.</p>

    <ul>
      <li>printf 에서 “%p” 를 사용하면 주소를 16진수로 보여줍니다.</li>
    </ul>
  </li>
  <li>
    <p>실행할 때 마다 주소가 바뀝니다. (보안 강화를 위해 실행할 때마다 프로그램이 올라가는 주소가 바뀝니다. - ASLR 이라고 합니다.)</p>
  </li>
</ul>

<h2 id="89-메모리-주소-저장하기">89. 메모리 주소 저장하기</h2>

<hr />

<ul>
  <li>
    <p>\&amp; 연산자로 주소를 구할 수 있다는 걸 배웠습니다. 그럼 이 주소를 어떻게 변수에 저장할까요.</p>

    <ul>
      <li>
        <p>어차피 16진수 숫자니까 int에 저장하면 되지 않을까요!! 👉 컴파일 에러 납니다.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">try</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
error: incompatible pointer to integer conversion initializing 'int' with an expression of type 'int *'; remove &amp;
*/</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>앞으로 ‘주소’와 ‘값’이 계속 언급 될 텐데 둘을 잘 구분합시다. 주소는 값의 메모리 위치.</p>
  </li>
  <li>
    <p>주소를 저장하기 위한 특별한 변수가 있습니다.</p>

    <ul>
      <li>그 변수가 바로 <strong>포인터</strong>입니다.</li>
      <li>포인터 is 변수</li>
    </ul>
  </li>
</ul>

<h2 id="90-포인터의-의미">90. 포인터의 의미</h2>

<hr />

<ul>
  <li>포인터란 주소를 저장하기 위한 변수<strong>형</strong>입니다.</li>
  <li>포인터는 변수입니다. 메모리 주소를 저장하는 변수요.</li>
  <li>포인터를 다른 복잡한 정의로 이해하면 앞으로 더 복잡해집니다. 포인터는 그냥 변수에요.</li>
</ul>

<h2 id="91-메모리-주소에-저장된-자료형">91. 메모리 주소에 저장된 자료형</h2>

<hr />

<ul>
  <li>주소에 저장된 자료형은 뭘까요?
    <ul>
      <li>하드웨어는 신경쓰지 않습니다. 비트패턴을 char로 읽으면 char고, int로 읽으면 int고, float으로 읽으면 float입니다.</li>
    </ul>
  </li>
  <li>근데, 해당 주소에서부터 몇 바이트를 읽어야 하는지(나는 이 주소에서 몇 바이트를 갈거야! 같은것)는 하드웨어에게 알려줘야 합니다.</li>
  <li>포인터 변수를 선언할 때 그 주소에 어떤 형의 데이터가 있는지 명시해줘야 합니다.
    <ul>
      <li>int 포인터, float 포인터, char 포인터 이런 식입니다.</li>
      <li>어떤 변수에 주소가 있는데 그걸 int 로 읽어라, float으로 읽어라, char로 읽어라</li>
    </ul>
  </li>
</ul>

<h2 id="92-포인터-변수를-선언하는-방법">92. 포인터 변수를 선언하는 방법</h2>

<hr />

<ul>
  <li>
    <p>자료형 뒤에 *를 붙여 포인터 변수를 선언합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">save_address</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">num_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>int*, char*, float* 모두 가능합니다.</li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">int *variableName;</code> 으로 써도 되지만 우리는 <code class="highlighter-rouge">int* variableName;</code>을 씁시다.</p>
  </li>
</ul>

<h2 id="93-포인터-변수를-부르는-방법">93. 포인터 변수를 부르는 방법</h2>

<hr />

<ul>
  <li>한국에선 보통 ‘int 포인터’ 라고 부릅니다.</li>
  <li>영어로는 ‘pointer to an int’ 라고 부릅니다.</li>
  <li>포인터 읽는 법은 중요합니다. 뒤에 포인터를 어떻게 읽느냐에 따라 중요해지는 부분이 있습니다. 선생님은 영어식 표현을 선호하는 것 같습니다.</li>
  <li>포인터는 메모리 주소를 저장하는 변수.
    <ul>
      <li>그럼 포인터의 내용은 어디에 저장되죠? 👉 당연히 메모리 어딘가에</li>
      <li>다른 위치를 가리키는 변수여서 ‘포인터’라고 부릅니다.</li>
    </ul>
  </li>
  <li>처음 공부할 때 모눈종이 사서 메모리 그려보면서 하시길 추천합니다.
    <ul>
      <li>눈으로만 보면서 편하게 하면 머리에 안남습니다. 걸렸네..😅</li>
    </ul>
  </li>
</ul>

<h2 id="94-포인터-변수의-실제-메모리-뷰">94. 포인터 변수의 실제 메모리 뷰</h2>

<hr />

<ul>
  <li>디버거와 오브젝트 코드를 까서 실제 메모리 보는 중..</li>
  <li>메모리 보다보면 주소가 뒤집혀 보이는걸 볼 수 있습니다.</li>
  <li>데이터가 끝나는 마지막 단위를 가장 작은 메모리 주소에 위치해 메모리 주소를 뒤집어 저장하는 방식을 ‘리틀 엔디언’ 이라고 합니다. <a href="https://ko.wikipedia.org/wiki/엔디언">참고</a>
    <ul>
      <li>요즘 나오는 인텔, amd 리틀 엔디언 방식입니다.  빅 엔디언은 옛날 cpu들입니다.</li>
      <li>POCU 학생이라면 ‘소프트웨어 공학용 수학’ 시간에 배웠습니다.</li>
      <li>들어야 되나..</li>
    </ul>
  </li>
</ul>

<h2 id="95-포인터의-비유--현실-세계-예">95. 포인터의 비유 : 현실 세계 예</h2>

<hr />

<ul>
  <li>기술적인 설명은 위에 나온 것으로 끝입니다. 현실 세계로 비유를 한 번 해보겠습니다.</li>
  <li>패쓰</li>
</ul>

<h2 id="96-다른-포인터의-예">96. 다른 포인터의 예</h2>

<hr />

<ul>
  <li>
    <p>int 포인터 말고 다른 포인터도 쓸 수 있습니다.</p>
  </li>
  <li>
    <p>각 코드들을 디버그 찍어서 값 뽑아보고, 오브젝트 코드 열어서 주소 구경해봅시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">save_address</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">char</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">num_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">save_address</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">short</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">short</span><span class="o">*</span> <span class="n">num_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">save_address</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">float</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">float</span><span class="o">*</span> <span class="n">num_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">save_address</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">double</span><span class="o">*</span> <span class="n">num_addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="97-포인터에-저장된-주소도-바꿀-수-있나요">97. 포인터에 저장된 주소도 바꿀 수 있나요?</h2>

<hr />

<ul>
  <li>포인터도 변수니까 당연히 변경 가능합니다.</li>
  <li>포프 선생님 강의는 하나 하나가 굉장히 짧으십니다. <del>(대신 총 동영상수 342개…)</del></li>
</ul>

<h2 id="98-역-참조-연산자-">98. 역 참조 연산자 *</h2>

<hr />

<ul>
  <li>
    <p>포인터도 변수이기 때문에 변수가 쓰이는 것처럼 거의 사용 가능합니다.</p>
  </li>
  <li>
    <p>매개변수로 전달할 수도 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">addr</span><span class="p">){</span>
	<span class="cm">/* do someting */</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">do_something</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>주소를 받았다면 그 주소를 역으로 추적해서 값을 찾을 수도 있습니다. 그때 사용하는 게 역 참조 연산자 *입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">addr</span><span class="p">){</span>
	<span class="cm">/* do someting */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"num : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="o">*</span><span class="n">addr</span><span class="p">)</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">do_something</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>곱하기 아니에요. 포인터 변수 앞에 달려서 그 포인터 주소에 있는 곳으로 가 값을 읽어와라!</p>
  </li>
</ul>

<h2 id="99-참조와-역-참조">99. 참조와 역 참조</h2>

<hr />

<ul>
  <li>‘참조’라는 단어는 언급하지 않았지만 포인터가 계속 하고 있던일을 ‘참조’라고 합니다.
    <ul>
      <li>변수의 값을 직접 가져다 쓰는게 아니라 그게 어디 있다고 ‘참조’만 하는 것입니다.</li>
    </ul>
  </li>
  <li>역 참조는 반대로 직접 그 주소로 가서 값에 접근하는 것입니다.</li>
  <li>이 ‘역 참조’를 ‘간접(indirect) 연산자’라고도 합니다. 값에 직접 접근하는게 아니라 주소를 타고 한 번 거쳐서 간다는 뜻으로말입니다.</li>
  <li>indirection은 프로그래머의 자질을 알아보는 요소중 하나로 보는 곳도 있습니다.
    <ul>
      <li>컴퓨터 구조에서 데이터를 오래 메모리에 저장하는 방법이기도 하고.. 추상적 개념을 이해할 수 있는지 알아보는 것이기도 하고…</li>
    </ul>
  </li>
</ul>

<h2 id="100-역-참조를-이용한-값-변경-예">100. 역 참조를 이용한 값 변경 예</h2>

<hr />

<ul>
  <li>
    <p>역 참조를 이용해 값을 바꿀 수 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
	<span class="n">pritnf</span><span class="p">(</span><span class="s">"origin : %d"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
  
	<span class="kt">int</span><span class="o">*</span> <span class="n">addr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>
	<span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"modified : %d"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
      
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
origin : 50
modified : 100
*/</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>포인터 변수 선언할 때랑 역 참조 걸때랑 헷갈릴 수도 있으니 포인터 변수 선언할 땐 반드시 <code class="highlighter-rouge">int *num</code> 하지 말고 <code class="highlighter-rouge">int* num</code> 합시다.</p>
  </li>
</ul>

<h2 id="101-포인터로-두-변수의-값-바꾸기">101. 포인터로 두 변수의 값 바꾸기</h2>

<hr />

<ul>
  <li>
    <p>모두가 작성해 봤을 법한 swap()메서드</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>	
	<span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
10, 20
10, 20
*/</span>
</code></pre></div>    </div>

    <ul>
      <li>이게 안되는 이유는 말 안해도 알죠잉 C#에선 이거할 때 매개변수에 ref 를 붙이므로써 가능 했습니다.</li>
    </ul>
  </li>
  <li>
    <p>C에선 이때 포인터를 쓰는 겁니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">b</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>	
	<span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
10, 20
20, 10
*/</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="102-값에-의한-전달-vs-참조에-의한-전달">102. 값에 의한 전달 vs 참조에 의한 전달</h2>

<hr />

<ul>
  <li>이건 그냥 용어에 대한 논쟁입니다. 포인터를 매개변수로 전달할 때
    <ol>
      <li>원본이 바뀐다 👉 ‘참조에 의한 전달’ 이라고 부르자!</li>
    </ol>
    <ol>
      <li>메모리 주소를 복사했다 👉 ‘값에 의한 전달’ 이라고 부르자!</li>
    </ol>
  </li>
  <li>아주 엄밀히 말하면 C에서 함수를 호출할 땐 항상 변수를 복사합니다. 따라서 ‘값에 의한 전달’이란 용어가 맞습니다. 단, 포인터를 사용해 참조에 의한 전달을 흉내낼 뿐입니다.</li>
  <li>근데 사실 저건 말장난입니다. 어쨌든 프로그래머 입장에선 원본이 바뀌는지 안 바뀌는지가 중요합니다. 따라서 원본이 바뀌니까 프로그래머의 의도상 ‘참조에 의한 전달’이라고 하는게 맞습니다.</li>
</ul>

<h2 id="103-코드보기--min-max-한-번에-구하기">103. 코드보기 : Min, Max 한 번에 구하기</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* min_max.h */</span>
<span class="cp">#ifndef MIN_MAX
#define MIN_MAX
</span><span class="kt">void</span> <span class="nf">getMinMax</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">out_min</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">out_max</span><span class="p">);</span>
<span class="cp">#endif
</span></code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* min_max.c */</span>
<span class="cp">#include "min_max.h"
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
</span><span class="cm">/* length &gt;= 1 때만 */</span>
<span class="kt">void</span> <span class="nf">getMinMax</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">out_min</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">out_max</span><span class="p">){</span>
    
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="cm">/* 디버그 모드에서만 검사하는 함수 */</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">length</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">);</span>

    <span class="o">*</span><span class="n">out_min</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="o">*</span><span class="n">out_max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">out_min</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
            <span class="o">*</span><span class="n">out_min</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">out_max</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
            <span class="o">*</span><span class="n">out_max</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>
<span class="cp">#include &lt;stdio.h&gt;
#include "min_max.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">num_min</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num_max</span><span class="p">;</span>
    <span class="n">getMinMax</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">num_min</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_max</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"min : %d, max : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num_min</span><span class="p">,</span> <span class="n">num_max</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="104-포인터와-함수-반환-값">104. 포인터와 함수 반환 값</h2>

<hr />

<ul>
  <li>
    <p>포인터도 변수니까 함수의 리턴 값으로 사용할 수도 있습니다.</p>
  </li>
  <li>
    <p>단, 주의할 점이 있는데 지역변수의 주소를 반환하는건 매우 위험한 코드입니다. 컴파일러에 따라서 waring을 띄워주는 컴파일러도 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>함수의 지역 변수는 스택메모리에 저장됩니다. 함수의 작업이 끝나면 함수의 스택 프레임은 사라지고 전에 쓰던 데이터 값은 그 자리에 남아있습니다. 그리고 그 자리 위에 다른 함수의 스택 프레임이 들어오고 다른 변수가 들어옵니다. 그렇게 다른 데이터가 덮어 씌워질 수 있습니다.</p>
  </li>
</ul>

<h2 id="105-댕글링-포인터dangling-pointer">105. 댕글링 포인터(dangling pointer)</h2>

<hr />

<ul>
  <li>컴파일러가 warning을 뱉은 이유는 <strong>유효하지 않은 주소</strong>를 가리켜서 나는 것입니다.</li>
  <li>위와 같은 코드는 절대 작성하면 안됩니다.</li>
  <li>실제 가리키는 대상이 없는 포인터를 ‘댕글링 포인터’라고 부르고 100에 99.9는 문제를 일으킵니다.</li>
  <li>단, 포인터를 안전하게 반환할 수 있는 경우가 있습니다.
    <ul>
      <li>전역 변수 - 전역 변수의 주소는 프로그램이 도는 동안 바뀌지 않습니다.</li>
      <li>함수 내 static 변수 - 함수 안에서만 접근하지만, static 변수는 데이터 섹션에 들어가 주소가 바뀌지 않습니다.</li>
      <li>힙 메모리에 생성한 데이터</li>
      <li>즉, 스택프레임에 들어가는 데이터가 아니라 힙이나 데이터 섹션에 들어가는 메모리는 주소를 반환해도 좋습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="106-널null-포인터">106. 널(NULL) 포인터</h2>

<hr />

<ul>
  <li>
    <p>아무 것도 가리키지 않는 포인터를 ‘널 포인터’라고 부릅니다.</p>

    <ul>
      <li>Null 포인터의 값은 ‘0’인 정수 상수 혹은 void*로 캐스팅된 표현식입니다.</li>
      <li>널 포인터를 만들려면 <code class="highlighter-rouge">int* ptr=NULL</code> 혹은 <code class="highlighter-rouge">int* ptr = 0</code> 하면 됩니다.</li>
      <li>근데 보통 전용 매크로 <code class="highlighter-rouge">#define NULL ((void*)0)</code>를 사용합니다.
        <ul>
          <li>0도 대입하고 0을 void* 로 캐스팅도 하네요.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>포인터 변수와 NULL은 비교 가능합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  
<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span><span class="o">~~</span><span class="p">};</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>포인터 변수 NULL 비교할 때 <code class="highlighter-rouge">ptr==0</code>을 써도 되긴 하는데… 그냥 <code class="highlighter-rouge">NULL</code>쓰도록 합시다.</p>
  </li>
</ul>

<h2 id="107-null이-가지는-문제들">107. NULL이 가지는 문제들</h2>

<hr />

<ul>
  <li>
    <p>함수의 매개변수로 포인터가 쓰일 땐 해당 포인터에 NULL이 들어올 수도 있기 때문에 문제가 됩니다. 받은 변수가 NULL일 때, 아닐 때 구분해줘야 합니다.</p>
  </li>
  <li>
    <p>기본적으로 함수를 작성할 때 NULL이 안들어 온다고 가정하고 함수를 작성하면 코드가 깔끔해집니다. (실무에서도 이렇게 내부 규약을 만들어 놓는 곳이 많습니다.)</p>
  </li>
  <li>
    <p>대신, NULL이 들어올 수 있는 함수는 매개변수에 알 수 있도록 표시를 해줍시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">get_score</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">student_id_or_null</span><span class="p">){</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>NULL이 안들어온다고 가정하고 코드 짠뒤 테스트 할 때 assert()를 사용해 검증합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">get_score</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">student_id</span><span class="p">){</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">student_id</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>매개변수로 올 때 뿐아니라, 리턴할 때도 NULL일 수 있습니다. 마찬가지로, 기본적으로 NULL을 리턴하지 않는다고 가정하고 작성합시다. 반환 할 수 있으면 함수 이름 자체에 작성합시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">get_score_or_null</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">student_id</span><span class="p">){</span>
  	
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>NULL을 받거나 리턴하면 함수 내, 외부에 분기문이 많아집니다. 분기문이 많아지며 코드가 지저분해지는건 개발시에도, 유지보수시에도 안좋습니다.</p>
  </li>
</ul>

<h2 id="108-널-포인터는-언제-사용하나요">108. 널 포인터는 언제 사용하나요?</h2>

<hr />

<ul>
  <li>
    <p>NULL 포인터는 다음과 같을 때 사용하면 좋습니다.</p>

    <ul>
      <li>
        <p>포인터 변수를 초기화 하고 싶을 때 (선언 및 초기화는 해야 하는데 아직 참조할 주소가 없을 때)</p>

        <ul>
          <li>
            <p>일단 아무거나 잡아놓겠다고 아무 주소나 넣을 수 있는데, 만약 그 아무 주소가 os나 프로그램에 의해 보호받고 있는 메모리면 에러가 납니다.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="o">:</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">g_count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>
        <p>포인터가 유효한 주소를 참조하는 지 확인할 때</p>

        <ul>
          <li>
            <p>아무것도 가리키지 않는 포인터(NULL 포인터)를 역참조 하는건 undefined behavior에어서 크랙이 납니다.</p>
          </li>
          <li>
            <p>다음과 같이 널 포인터 인지 확인 합니다.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">g_num</span><span class="p">;</span>
	<span class="o">:</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span>
	<span class="o">:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>
        <p>댕글링 포인터를 막기 위해</p>

        <ul>
          <li>
            <p>동적 메모리 참조하고 있던 포인터가 있는데 해당 동적 메모리를 더 이상 사용하지 않아 메모리는 해제 했는데 포인터가 아직 동적 메모리를 보고 있으면 댕글링 포인터가 생깁니다.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="cm">/* 동적메모리 할당 */</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
	<span class="o">:</span>
	<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="cm">/* 동적 메모리 해제, 아직 ptr에 주소는 있음 */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* 댕글링 포인터 방지 */</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>존재하지 않는 메모리 주소에서 값을 읽거나 쓰려고 하면 문제가 터집니다! 컴파일 할 때 에러가 안나고, 런타임시 c 프로그램 안에서가 아니라 밖의 프로그램이나 os단에서 터질 수 있기 때문에 정말정말 위험합니다.</p>
  </li>
</ul>

<h2 id="109-포인터의-비교">109. 포인터의 비교</h2>

<hr />

<ul>
  <li>
    <p>포인터도 비교할 수 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">num1</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">num2</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num1</span> <span class="o">==</span> <span class="n">num2</span><span class="p">){</span> <span class="cm">/* 주소 비교 */</span>
		<span class="o">:</span>
	<span class="p">}</span>
<span class="p">}</span>
  
<span class="kt">void</span> <span class="nf">foo2</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">num1</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">num2</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">num1</span> <span class="o">==</span> <span class="o">*</span><span class="n">num2</span><span class="p">){</span> <span class="cm">/* 값 비교 */</span>
		<span class="o">:</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>==, &gt;, &lt;, &lt;=, &gt;=, != 같은 비교들도 가능합니다.</p>

    <ul>
      <li>배열 같은 메모리 블록에서 사용할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="110-포인터의-크기">110. 포인터의 크기</h2>

<hr />

<ul>
  <li>모든 포인터는 동일한 크기를 갖습니다. 컴파일하는 시스템의 아키텍처에 따라 결정됩니다.</li>
  <li>보통 cpu가 한 번에 처리할 수 있는 데이터의 크기(워드, word)와 동일합니다.
    <ul>
      <li>32bit cpu는 4바이트, 64bit cpu는 8바이트 (항상 그런건 아닙니다.)</li>
      <li>char의 경우 값은 1바이트, char*는 4바이트(32비트의 경우)</li>
      <li>int 값은 4바이트, int*는 4바이트(32비트의 경우)</li>
      <li>double 값은 8바이트, double*는 4바이트(32비트의 경우)</li>
    </ul>
  </li>
  <li>저번에 매개변수로 온 배열을 sizeof() 했을 때 4바이트 나온 걸 기억 하실겁니다. <a href="/posts/study/c_kim_pope/C3/#57-배열의-요소-개수-구하는-방법">여기</a>
    <ul>
      <li>매개변수로 배열을 넘겼을 때 배열 자체를 넘긴게 아니라 배열 시작지점 주소를 전달한 것이기 때문입니다. 시작 주소. 주소는 4바이트.</li>
    </ul>
  </li>
</ul>

<h2 id="111-포인터와-배열의-비교">111. 포인터와 배열의 비교</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo_arr</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[]){</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span> <span class="cm">/* 4바이트 */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo_ptr</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="cm">/* 4바이트 */</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>둘이 매우 비슷합니다. 그럼 배열을 포인터로 대입할 수 있지 않을까요??</li>
</ul>

<h2 id="112-배열-포인터에-대입하기">112. 배열 포인터에 대입하기</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">ptr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> <span class="cm">/* 컴파일 됨 */</span>
</code></pre></div></div>

<ul>
  <li>arr를 &amp;arr로 넣은게 아니라 그냥 arr를 대입해도 컴파일이 됩니다.</li>
  <li>디버거로 arr와 ptr의 값을 보면 값은 주소값을 가지고 있습니다.</li>
  <li>단, 주의할 점이 있습니다. 배열의 시작 주소는 그럼 배열의 첫번째 요소의 주소랑 같지 않나요?
    <ul>
      <li>위 상황에서 ptr = arr[0]는 안 될 까요? 안됩니다. int와 int* 차이로 컴파일 에러가 납니다.</li>
      <li>대신, ptr = &amp;arr[0] 로 하면 컴파일도 되고, 주소 값도 같습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="113-배열-속-각-요소의-위치-각-요소의-위치-계산하기">113. 배열 속 각 요소의 위치, 각 요소의 위치 계산하기</h2>

<hr />

<ul>
  <li>
    <p>배열에서 각 요소 사이의 간격은 일정합니다.</p>
  </li>
  <li>
    <p>배열들의 각 요소들의 주소는, 첫 번째 요소의 주소와 자료형의 크기만 알면 알 수 있습니다.</p>

    <ul>
      <li>첫 번째 요소의 주소 addr, 자료형의 크기 gap이라면</li>
      <li>두 번째 요소 주소는 addr + 1*gap, 세 번째 요소는 addr + 2*gap 이런 식으로…</li>
    </ul>
  </li>
  <li>
    <p>단, 주의할게 있습니다. 포인터에서 연산은 단순하게 ‘주소 + 정수’로 계산되지 않습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span> <span class="cm">/* ptr = 0x100 가정 */</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>위에서 ptr + 3은 0x100 + 0x003이 아닙니다.</li>
      <li>해당 자료형의 크기(0x004)를 3번 더하라는 뜻입니다.</li>
      <li>0x100 + (0x004 + 0x004 + 0x004) = 0x10C</li>
    </ul>
  </li>
  <li>
    <p>마찬가지로 short* 였다면 0x100 + (0x002 + 0x002 + 0x002) = 0x106 으로 계산 될 겁니다.</p>
  </li>
  <li>
    <p>++, –도 마찬가지 입니다.</p>
  </li>
  <li>
    <p>그래서 포인터로 배열 요소를 다룰 땐 index를 더하듯이 더해줘야 합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">nums</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="cm">/* ptr1 == ptr2 */</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="114-배열-요소에-포인터로-접근하기">114. 배열 요소에 포인터로 접근하기</h2>

<hr />

<ul>
  <li>
    <p>그럼 아래와 같이 배열 요소를 포인터[ ] 로 접근할 수 있을까요?</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nums</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span>
  
<span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>정답은 yes입니다. 배열에도 첨자 연산자 [ ]를 사용할 수 있습니다. 위 세 가지(<code class="highlighter-rouge">nums[1], ptr[1], *(ptr+1)</code>)는 컴파일러에게 같은 의미입니다.</p>
  </li>
  <li>
    <p>저 세 가지가 같다면 편한 nums[1]를 계속 쓰면 되지 않나요?</p>

    <ul>
      <li>포인터를 쓰는 방식이 약~간 빠릅니다.</li>
    </ul>
  </li>
</ul>

<h2 id="115-포인터-중간-정리-포인터의-캐스팅">115. 포인터 중간 정리, 포인터의 캐스팅</h2>

<hr />

<ul>
  <li>
    <p>포인터에 들어가는 값은 주소다!</p>

    <ul>
      <li>주소연산자(&amp;)로 가져오기</li>
      <li>배열의 이름으로 가져오기</li>
    </ul>
  </li>
  <li>
    <p>포인터에 정수를 더하면 주소 이동이다!</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span>
<span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">2</span>
<span class="cm">/* ptr값(주소) + sizeof(int)*2 */</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>근데, 주소를 자료형 만큼 움직이지 말고, 딱 1 바이트만 움직이고 싶다면 어떻게 할까요?</p>

    <ul>
      <li>
        <p>char* 로 캐스팅합니다.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">int_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">int_ptr</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>int* 👉 char* 캐스팅의 의미는 무엇일까요?</p>

    <ul>
      <li>그 메모리 주소에 어떤 type이 들어있는지 알려주는 것입니다. 일반 자료형의 캐스팅과는 의미가 조금 다릅니다.</li>
    </ul>
  </li>
</ul>

<h2 id="116-딱-한-바이트만-옮기기">116. 딱 ‘한’ 바이트만 옮기기</h2>

<hr />

<ul>
  <li>
    <p>어떤 포인터형(int*, char*, short*) 든 크기는 같다고 했습니다.</p>
  </li>
  <li>
    <p>포인터형에 타입을 주는건 해당 포인터에 있는 주소로 가서 데이터를 읽을 때 어떤 타입으로 읽어야 하는지 알려주는 것입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>
  
<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>이런걸 이용하면 프로그래머가 이상한 짓을 할 수 있습니다. int는 4바이트씩 몰려다녀야 하는데 그 4바이트 사이에 들어가 조작을 할  수 있습니다.</p>

    <ul>
      <li>능력이 된다면 불가능 한 것도 가능해지지만, 잘못 다루면 😈😈</li>
    </ul>
  </li>
</ul>

<h2 id="117-코드보기--int-메모리-뷰어">117. 코드보기 : int 메모리 뷰어</h2>

<hr />

<ul>
  <li>
    <p>잘 쓰면 이렇게 쓸 수 있다는 것의 예시 입니다. int 메모리 뷰어 프로그램입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">NUM</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span> <span class="cm">/* 주소가 아니라 정수 값 */</span>
	<span class="n">cost</span> <span class="kt">char</span><span class="o">*</span> <span class="n">NUM_ADDRESS</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">NUM</span><span class="p">;</span> <span class="cm">/* 해당 정수를 1바이트씩 볼것이다. */</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  	
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">NUM</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
		<span class="n">print</span><span class="p">(</span><span class="s">"%hhx "</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">NUM_ADDRESS</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
		<span class="cm">/* 78 56 34 12 (리틀 엔디언) */</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  	
	<span class="n">printf</span><span class="p">(</span><span class="s">"NUM in hex form : 0x%x"</span><span class="p">,</span> <span class="n">NUM</span><span class="p">);</span> 
  	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="118-코드보기--두-배열이-겹치는가">118. 코드보기 : 두 배열이 겹치는가?</h2>

<hr />

<ul>
  <li>
    <p>다른 재밌는 예시입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* memory.h */</span>
<span class="cp">#ifndef MEMORY_H
#define MEMORY_H
</span>  
<span class="cp">#define TRUE (1)
#define FALSE (0)
</span>  
<span class="cp">#define ARRAY_LENGTH(arr) (sizeof(arr)/sizeof(arr[0]))
</span>  
<span class="kt">int</span> <span class="nf">is_overlap</span><span class="p">(</span><span class="kt">int</span> <span class="n">nums1</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">length1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nums2</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">length2</span><span class="p">);</span>
  
<span class="cp">#endif
</span></code></pre></div>    </div>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* memory.c */</span>
<span class="cp">#include "memory.h"
</span>  
<span class="kt">int</span> <span class="nf">is_overlap</span><span class="p">(</span><span class="kt">int</span> <span class="n">nums1</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">length1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nums2</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">length2</span><span class="p">){</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">nums1</span> <span class="o">&lt;=</span> <span class="n">nums2</span> 
            <span class="o">?</span> <span class="n">nums1</span> <span class="o">+</span> <span class="n">length1</span> <span class="o">&gt;</span> <span class="n">nums2</span> 
            <span class="o">:</span> <span class="n">nums2</span> <span class="o">+</span> <span class="n">length2</span> <span class="o">&gt;</span> <span class="n">nums1</span><span class="p">);</span>
<span class="p">}</span>
  
<span class="cm">/*
nums1의 시작 위치가 nums2보다 작다면, nums1의 끝나는 위치(nums1+length1)가 nums2와 nums2+length2 사이에 있으면 두 배열이 겹치는 것. 
*/</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="119-두-주소-간의-사칙연산">119. 두 주소 간의 사칙연산</h2>

<hr />

<ul>
  <li>
    <p>포인터의 연산에선 정수만 가능합니다. 2.5 이런거 더하면 안됩니다. “나는 바이트를 쪼개 비트 단위로 다루겠어!!” 이건 안됩니다.</p>
  </li>
  <li>
    <p>두 주소 간의 사칙연산</p>

    <ul>
      <li>
        <p>뺄셈만 가능합니다.</p>
      </li>
      <li>
        <p>덧셈, 곱, 나눗셈은 의미 없습니다. 가능하지 않습니다.</p>
      </li>
      <li>
        <p>뺄셈은 두 주소 사이의 offset이 몇이냐 같은걸 구할 수 있습니다. 한 배열의 두 주소를 빼서 두 주소 사이에 몇 개의 요소가 있는지 등을 찾을 수 있습니다.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sub</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* 4 */</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>이를 이용해, 배열의 첫 번째 요소와 마지막 요소의 주소를 알면 배열의 크기를 구할 수 있습니다.</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="120-자바와-c에서는-모든-것이-포인터다">120. 자바와 C#에서는 모든 것이 포인터다.</h2>

<hr />

<ul>
  <li>자바, C#은 원시타입을 제외한 모든 자료형은 포인터입니다.</li>
  <li>이걸 java에서 참조로 먼저 배우고 포인터로 돌아오다니..</li>
  <li>java, C#에서 이렇게 포인터로 집어오는걸 기본으로 삼았다는건, C에서도 포인터를 많이 쓸 거라는 복선인가..</li>
</ul>

<h2 id="121-포인터를-사용한-안전하지-않은-코드">121. 포인터를 사용한 안전하지 않은 코드</h2>

<hr />

<ul>
  <li>
    <p>가장 많이 하는 실수는 배열에서 index에러입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">nums</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">34</span><span class="p">,</span> <span class="mi">135</span><span class="p">,</span> <span class="mi">49</span> <span class="p">};</span>
  
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span>
  
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%p: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">ptr</span><span class="o">+</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
<span class="cm">/*
i = -1을 찍는 사람은 사실 거의 없습니다.
00000007838FF7CF: 7
정상값
00000007838FF7D0: 34
00000007838FF7D1: 135
00000007838FF7D2: 49
nums에 없는 값. 다른 언어에선 OutOfIndex에러이지만 C에선 그냥 찍어줍니다.
00000007838FF7D3: 1024
*/</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>위험하다고 안쓰기엔 너무 강력합니다.</p>
  </li>
  <li>
    <p>C/C++ 잘 쓰는 사람은 정말 많은 존경을 받습니다.</p>
  </li>
</ul>

<h2 id="122-포인터와-배열의-차이">122. 포인터와 배열의 차이</h2>

<hr />

<ul>
  <li>
    <p>지금까지 봤으면 ‘포인터랑 배열 완전 같네!’라고 생각할 수 있는데 다른 점도 있으니 짚고가겠습니다.</p>
  </li>
  <li>
    <p>배열 변수에 sizeof 하면 배열 사이즈가 나옵니다. 포인터 사이즈 안나옵니다.</p>
  </li>
  <li>
    <p>문자열 초기화</p>

    <ul>
      <li>
        <p>C엔 문자열(string) 자료형이 없습니다. char 배열로 표현합니다. 예를들어, “Friday”를 표현할 때 총 6(+1)개 char 배열을 만듭니다. +1은 문자열이 끝나는 지점이란걸 알려주기 위한 null character 입니다. ‘\0’를 씁니다.</p>
      </li>
      <li>
        <p>F r i d a y \0</p>
      </li>
      <li>
        <p>근데 이를 초기화하는 방법이 두 가지입니다.</p>

        <ul>
          <li>
            <p><code class="highlighter-rouge">char day1[] = "Monday"</code> 마지막에 ‘\0’가 알아서 들어갑니다. 함수 안에서 사용하면 스택 메모리에 저장되고, 밖에서 사용되면 데이터섹션에 들어가게 됩니다.</p>
          </li>
          <li>
            <p><code class="highlighter-rouge">char* day2 = "Monday";</code>  포인터 변수 day2 자체는 스택에 저장되고 “Monday” 자체는 데이터 섹션에 저장됩니다. day2 포인터가 데이터 섹션을 가리키게 됩니다. 실제 문자열이 스택에 들어오는 게 아닙니다.</p>
          </li>
          <li>
            <p>스택에 들어온 문자열은 바꿔도 되지만, 데이터 섹션에 저장된 문자열을 수정할 경우는 ‘undefined behavior’ 입니다. 기기에 따라 크래쉬 날 수도 있습니다.(데이터 섹션은 변경되면 안 되는 값들이 들어갑니다.)</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char day1[] = "Monday"; /* 스택에 저장 */
char* day2 = "Monday"; /* 데이터 섹션에 저장 */
      
day1[0] = 'P' /* ok */
day2[0] = 'P' /* undefined behavior */
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>포인터 변수에 값을 대입할 수 있으나 배열 변수에는 대입할 수 없습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">ptr1</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">arr1</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">arr2</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  
<span class="n">ptr1</span> <span class="o">=</span> <span class="n">arr1</span><span class="p">;</span> 
<span class="n">arr1</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span> <span class="cm">/* 컴파일 에러 */</span>
  
<span class="n">ptr1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> 
<span class="n">arr1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> <span class="cm">/* 컴파일 에러 */</span>
  
<span class="n">ptr1</span> <span class="o">=</span> <span class="n">ptr2</span><span class="p">;</span>
<span class="n">arr1</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">;</span> <span class="cm">/* 컴파일 에러 */</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>포인터는 산술 연산 가능, 배열은 불가능</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
<span class="n">arr</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* 컴파일 에러 */</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="123-다시-만나는-연산자-결합-법칙">123. 다시 만나는 연산자 결합 법칙</h2>

<hr />

<ul>
  <li>
    <p>연산자 결합 법칙은 익숙한건 그냥 쓰고 잘 모르겠으면 괄호를 치면 됩니다. 사실 별로 고민할 필요가 없습니다.</p>
  </li>
  <li>
    <p>주의할 건 연산자 결합 법칙이 동일한 연산자들끼리 있을 때 👉 방향인지, 👈 방향인지 입니다. 대부분 👉 방향이고 흔히 생각하는 👈는 대입 연산자입니다. <code class="highlighter-rouge">a=b=c=d</code></p>
  </li>
  <li>
    <p>그런데 다른 언어에 없는 *, \&amp; 들과 같이 연산자들이 사용되기 시작하면 복잡해집니다.</p>
  </li>
  <li>
    <p>퀴즈</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">134</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">47856</span><span class="p">};</span> <span class="cm">/* nums 주소는 0x104 */</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span>
<span class="cm">/* 아래 각 라인을 따로 실행한다고 했을 때 num과 p는? */</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*++</span><span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">++*</span><span class="n">p</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="124-포인터와-연산자-우선순위-및-결합-법칙">124. 포인터와 연산자 우선순위 및 결합 법칙</h2>

<hr />

<ul>
  <li>
    <p>우선순위, 결합법칙 <a href="/posts/study/c_kim_pope/C2/#29-연산자">참조</a>하면서 불었습니다..</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">134</span><span class="p">,</span> <span class="mi">68</span><span class="p">,</span> <span class="mi">47856</span><span class="p">};</span> <span class="cm">/* nums 주소는 0x104 */</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span>
<span class="cm">/* 아래 각 라인을 따로 실행한다고 했을 때 num과 p는? */</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* num:134, p:0x108 */</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">*++</span><span class="n">p</span><span class="p">;</span> <span class="cm">/* num:68 , p:0x108 */</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="o">++*</span><span class="n">p</span><span class="p">;</span> <span class="cm">/* num:135 , p:0x104 */</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="o">/*</span> <span class="n">num</span><span class="o">:</span><span class="mi">134</span> <span class="p">,</span> <span class="n">p</span><span class="o">:</span><span class="mh">0x104</span> <span class="o">*</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>헷갈리면 괄호를 써줍시다.</p>
  </li>
</ul>

<h2 id="125-동일한-우선순위를-갖는-연산자들">125. 동일한 우선순위를 갖는 연산자들</h2>

<hr />

<ul>
  <li>동일 우선순위 연산자들은 결합 방향이 같습니다.</li>
  <li>C를 자주 쓰는/쓸 사람이면 암기하고 아니라면 괄호를 씁시다!</li>
</ul>

<h2 id="126-조금-더-빠른-배열의-요소-더하기-함수">126. 조금 더 빠른 배열의 요소 더하기 함수</h2>

<hr />

<ul>
  <li>
    <p>앞서 포인터로 배열 접근하는 게 조금 더 빠르다고 했습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">end</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
  	
	<span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">&lt;</span><span class="n">end</span><span class="p">){</span>
		<span class="n">result</span> <span class="o">+=</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
  	
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">nums</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
      
	<span class="n">printf</span><span class="p">(</span><span class="s">"result : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>위와 같이 포인터로 접근하는게 아래와 같이 배열 주소와 요소 갯수를 넘겨서 for문 도는것 보다 아주 조금 빠릅니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">nums</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  	
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
  	
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">nums</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
      
	<span class="n">printf</span><span class="p">(</span><span class="s">"result : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="127-왜-p이-더-빠르죠">127. 왜 *p++이 더 빠르죠?</h2>

<hr />

<ul>
  <li>왜 아주 조금 빠른지 시각적인 설명</li>
  <li>요즘 컴파일러는 성능이 좋아서 포인터 두개를 넘기는 방식이나, 배열과 크기를 넘기는 방식이나 거의 비슷하고, 어셈블리어는 같게 나올 수도 있습니다.</li>
  <li>그러나 포팅을 고려해 포인터를 사용하는 경향도 있습니다.</li>
</ul>

<h2 id="128-포인터와-const">128. 포인터와 const</h2>

<hr />

<ul>
  <li>포인터에서 const를 쓸 때 헷갈리는 부분이 있습니다. 보호해야 할 게 가리키는 주소, 가리키는 주소의 값 두 가지가 있기 때문입니다.</li>
</ul>

<h2 id="129-주소를-보호하는-const-포인터">129. 주소를 보호하는 const 포인터</h2>

<hr />

<ul>
  <li>기본 자료형에 const를 붙이면 저장 값을 바꿀 수 있습니다.
    <ul>
      <li>근데, 이게 반드시 필요하진 않습니다. 실수의 가능성도 적고 함수 안에서 끝나기 때문입니다.</li>
    </ul>
  </li>
  <li>const를 포인터에 쓰면 포인터의 값. 즉, 포인터가 가리키는 주소를 보호합니다. 해당 변수가 갖는 값을 보호한다는 맥락에서 다른 변수의 const와 같습니다.</li>
  <li>그럼 <code class="highlighter-rouge">const int* ptr;</code> 이라고 쓰면 되겠죠?</li>
  <li>아닙니다. 위 의미를 표현하기 위해서, 포인터 변수는 오른쪽에서 왼쪽으로 읽기 때문에 <code class="highlighter-rouge">int* const ptr;</code> 이라고 해야 합니다.😲😲
    <ul>
      <li>영어로 “p is a const pointer to int” 라고 합니다. ‘ptr은 const인데 자료형은 int*야’ 라고 이해하면 편할 것 같습니다.</li>
    </ul>
  </li>
  <li>근데 이걸 유의해야 하는 이유는 <code class="highlighter-rouge">const int* ptr;</code>이 가리키는건 따로 있기 때문입니다.</li>
</ul>

<h2 id="130-값을-보호하는-const를-가리키는-포인터">130. 값을 보호하는 const를 가리키는 포인터</h2>

<hr />

<ul>
  <li>
    <p>const 변수는</p>

    <ul>
      <li>생성과 동시에 초기화해야 합니다.</li>
      <li>초기화 이후 다른 값으로 변경이 불가합니다.</li>
      <li>const가 아닌 변수에 const변수를 대입할 수는 있습니다.</li>
      <li>(포인터 전용) const 포인터가 가리키는 대상의 값은 변경 가능합니다.</li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">const int* ptr;</code>은 포인터가 가리키는 주소의 값을 보호하는 것입니다.</p>

    <ul>
      <li><strong>이걸 잘못 쓰면 함수 내부 뿐만 아니라 전역적으로 문제가 발생합니다.</strong>
        <ul>
          <li><code class="highlighter-rouge">int* const ptr;</code>의 경우 실수를 해도 해당 포인터가 사용된 함수 내부에서 끝나지만 <code class="highlighter-rouge">const int* ptr;</code>은 함수 밖에 있는 주소를 잠그기 때문에 사용한 함수 밖에서도 문제가 발생할 수 있습니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>그런데 <code class="highlighter-rouge">const int* ptr;</code>를 표현하는 다른 방법도 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>  <span class="cm">/* 방법 1 */</span>
<span class="kt">int</span> <span class="k">const</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span> <span class="cm">/* 방법 2 */</span>
</code></pre></div>    </div>

    <ul>
      <li>방법 1은 영어로 “p is a pointer to int, which is const”</li>
      <li>방법 2는 영어로 “p is a pointer to const int” 입니다.</li>
      <li>논리적으로 읽을 때 ‘p는 포인터인데 const int다’에서 방법 2가 더 맞는거 같지만(개인적으론 공감 x) 흔히 방법 1로 씁니다. (포인터로 가리켜진 int가 아닌 일반 int를 가리킬 때 const int를 많이 써서)</li>
      <li>POCU에서도 방법 1을 표준으로 합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="131-두-const의-정리와-예">131. 두 const의 정리와 예</h2>

<hr />

<ul>
  <li><code class="highlighter-rouge">int* const p;</code>
    <ul>
      <li>메모리 주소 변경을 금지</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">const int* p;</code>
    <ul>
      <li>메모리 주소가 가리키는 값 변경을 금지</li>
    </ul>
  </li>
</ul>

<h2 id="132-주소와-값-모두-지키는-const">132. 주소와 값 모두 지키는 const</h2>

<hr />

<ul>
  <li>
    <p>둘을 합체할 수도 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>그런데 이건 생각보다 쓸 일은 없습니다. 전역변수, 구조체 멤버 변수중 절대 바뀌지 말아야 할 것들에서만 좀 쓰입니다.</p>
  </li>
</ul>

<h2 id="133-const-포인터-읽는-방법-정리">133. const 포인터 읽는 방법 정리</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span> <span class="cm">/* 주소에 저장된 값 변경 불가 */</span>
<span class="kt">int</span> <span class="k">const</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span> <span class="cm">/* 주소에 저장된 값 변경 불가 */</span>
<span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span> <span class="cm">/* p가 가리키는 주소 변경 불가 */</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">p</span><span class="p">;</span> <span class="cm">/* 둘다 불가 */</span>
</code></pre></div></div>

<ul>
  <li>헷갈리면 오른쪽에서 왼쪽으로 읽읍시다.</li>
</ul>

<h2 id="134-const는-절대-제거하지-말자">134. const는 절대 제거하지 말자</h2>

<hr />

<ul>
  <li>
    <p>C에선 한 번 붙은 const도 제거할 수 있습니다. 캐스팅만 하면 가능합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span><span class="p">){</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>하지만 <strong>절. 대. 하. 지. 마. 세. 요.</strong></p>
  </li>
  <li>
    <p>저렇게 할 일이 생겼다는 건 애초에 설계가 잘못된 것입니다.</p>
  </li>
  <li>
    <p>const 의 좋은 활용</p>
    <ul>
      <li>const는 최대한 다 붙이되, const가 없어야 하는 상황에서 만 떼라</li>
      <li>const 캐스팅은 하지 말것.</li>
    </ul>
  </li>
</ul>

<h2 id="135-코드보기--벡터-덧셈">135. 코드보기 : 벡터 덧셈</h2>

<hr />

<ul>
  <li>패스</li>
</ul>

<h2 id="136-포인터의-용도">136. 포인터의 용도</h2>

<hr />

<ul>
  <li>용도 1 : 큰 데이터를 매개변수로 전달해줍니다. 매번 복사하면 데이터 낭비..</li>
  <li>용도 2 : 반환 값이 둘 이상일 때 포인터로 반환 값들을 넘겨주고 포인터로 변경해줍니다.</li>
  <li>용도 3 : 동적 메모리 할당
    <ul>
      <li>함수 범위에 상관 없이 한동안 사용하고자 하는 데이터들을 힙 메모리에 동적 할당합니다.</li>
      <li>스택 메모리로 가능하면 스택을 쓰는데 좋습니다. 빠르기 때문에</li>
    </ul>
  </li>
  <li>용도 4 : 그외 - 데이터 구조를 구현할 때(연결 리스트, 트리 등), 임베디드 프로그래밍에서 하드웨어 메모리에 직접 접근해야 할 때</li>
</ul>

<h2 id="137-포인터-배열">137. 포인터 배열</h2>

<hr />

<ul>
  <li>
    <p>포인터도 변수이니까 배열 가능할까요? 일단 가능합니다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">int* ptr_arr[3];</code> 이런식으로 사용 가능합니다. 그런데 재밌는 점은, 포인터 배열은 일반 2중 배열과 유사하게 사용할 수 있습니다. 아래와 같이 말입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nums1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">nums3</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
  
<span class="kt">int</span><span class="o">*</span> <span class="n">arr_ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">arr_ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">;</span>
<span class="n">arr_ptr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">;</span>
<span class="n">arr_ptr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums3</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="138-2차원-포인터-배열">138. 2차원 포인터 배열</h2>

<hr />

<ul>
  <li>
    <p>위 처럼 포인터 배열로 2중 배열을 다루기 위해선 각 내부 배열의 길이를 알려주는 size_t 배열도 필요합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">lengths</span><span class="p">[]);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>2중 배열을 포인터로 넘길 땐 주의를 해야 합니다.  아래 코드는 컴파일 에러가 납니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">5</span><span class="p">]){</span>
    <span class="o">:</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>아래와 같이 알려줘야 합니다.</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">matrix</span><span class="p">[][</span><span class="mi">3</span><span class="p">],</span> <span class="kt">size_t</span> <span class="n">m</span><span class="p">){</span>
	<span class="o">:</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>컴파일러가 매개변수가 2차원 배열이라는걸 알고, matrix[1][ ],matrix[2][ ] 같은거 할 때 한번에 건너 뛰어야 할 갯수를 알 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="139-코드보기--2d-배열을-배열의-배열로-바꾸기">139. 코드보기 : 2D 배열을 배열의 배열로 바꾸기</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">nums</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">}</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">nums2</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    
    <span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">nums2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">nums2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums[0] address : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums[1] address : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums[2] address : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums[2]'s offser from nums[0]' : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="cm">/* 10 */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums[1]'s offser from nums[0]' : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="cm">/* 5 */</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums2[0] address : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums2[1] address : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nums2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums2[2] address : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nums2</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>    

    <span class="n">printf</span><span class="p">(</span><span class="s">"nums2[0] value : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums2[1] value : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">nums2</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums2[2] value : %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">nums2</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>  	
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums2[2]'s offser from nums2[0]' : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nums2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-&amp;</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="cm">/* 2 */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"nums2[1]'s offser from nums2[0]' : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nums2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&amp;</span><span class="n">nums2</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="cm">/* 1 */</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="140-정리">140. 정리</h2>

<hr />

<ul>
  <li>포인터에 대해 다음과 같은 것들을 배웠습니다.
    <ul>
      <li>포인터</li>
      <li>주소 연산자, 역 참조 연산자</li>
      <li>널 포인터</li>
      <li>포인터와 const</li>
      <li>포인터 산술 연산</li>
      <li>포인터와 배열</li>
      <li>포인터 배열</li>
    </ul>
  </li>
  <li>포인터에 대해 전부 배운 것은 아닙니다. 더 복잡한건 추후에 더 알려드리겠습니다.</li>
</ul>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
