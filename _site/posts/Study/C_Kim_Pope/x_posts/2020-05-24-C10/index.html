<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      C Unmanaged Programming 10 - 자료구조 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/About Me">About Me</a>
      
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Sagyo_Reboot">Sagyo_Reboot</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Twitch_Chat_Analysis">Twitch_Chat_Analysis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/java">java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/jekyll">jekyll</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/linux">linux</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">C Unmanaged Programming 10 - 자료구조</h1>
  <span class="post-date"></span>
  
<h2 id="242-자료구조-기초">242. 자료구조 기초</h2>

<hr />

<ul>
  <li>
    <p>사실 여기까지 했으면 C 강의 자체는 끝났습니다. 다만, 자료구조를 구현하면서 C를 사용해봅시다.</p>
  </li>
  <li>
    <p>자료구조의 기초만 배울겁니다.</p>
  </li>
  <li>자료 구조란?
    <ul>
      <li>컴퓨터에서 여러 자료들을 조직적, 체계적으로 저장하는 방법</li>
      <li>보통 동일한 자료형을 여럿 저장하는 구조를 의미</li>
      <li>자료구조에 따라 요소들 사이의 관계를 정의하는 규칙이 있음</li>
      <li>상황마다 효율적인 자료구조가 존재
        <ul>
          <li>데이터에 접근하는 빈도</li>
          <li>데이터에 접근하는 방법(삽입, 검색, 읽기, 지우기 등)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>자료구조의 효율성
    <ul>
      <li>보통 시간 복잡도를 말합니다.</li>
      <li>공간 복잡도를 포함하는 경우도 있지만, 기본적으론 시간 복잡도라고 생각합시다.</li>
      <li>효율성을 논할 땐 보통 하드웨어 최적화를 고려하지 않고 말합니다.
        <ul>
          <li>대용량 데이터에선 거의 맞지만 적은 용량 데이터를 다룰 땐 하드웨어 최적화가 큰 영향을 미칩니다.</li>
        </ul>
      </li>
      <li>효율성 n^2 부턴 느린 알고리즘입니다. nlogn은 아슬아슬 하고 n은 soso, logn은 훌륭.</li>
    </ul>
  </li>
  <li>
    <p>자료구조들의 시간 복잡도</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: center">자료구조</th>
          <th style="text-align: center">검색-평</th>
          <th style="text-align: center">삽입-평</th>
          <th style="text-align: center">삭제-평</th>
          <th style="text-align: center">검색-최악</th>
          <th style="text-align: center">삽입-최악</th>
          <th style="text-align: center">삭제 - 최악</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: center">배열</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(n)</td>
        </tr>
        <tr>
          <td style="text-align: center">스택</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(1)</td>
        </tr>
        <tr>
          <td style="text-align: center">큐</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(1)</td>
        </tr>
        <tr>
          <td style="text-align: center">연결 리스트</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(1)</td>
        </tr>
        <tr>
          <td style="text-align: center">해시 테이블</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(1)</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(n)</td>
          <td style="text-align: center">O(n)</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h2 id="243-배열-배열의-삽입">243. 배열, 배열의 삽입</h2>

<hr />

<ul>
  <li>
    <p>가장 간단한 자료구조입니다.</p>
  </li>
  <li>
    <p>색인(index)로 접근 가능합니다.</p>

    <ul>
      <li>위치 = 시작주소 + sizeof(자료형)*색인</li>
    </ul>
  </li>
  <li>
    <p>배열 삽입 코드 보는중..</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="p">{</span> <span class="n">MAX_NUMS</span> <span class="o">=</span> <span class="mi">8</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">s_nums</span><span class="p">[</span><span class="n">MAX_NUMS</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">s_num_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* 현재 배열 요소 갯수 */</span>
  
<span class="kt">void</span> <span class="nf">insert_at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
      
    <span class="cm">/* 범위 확인 */</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;=</span> <span class="n">s_num_count</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">s_num_count</span> <span class="o">&lt;</span> <span class="n">MAX_NUMS</span><span class="p">);</span>
      
    <span class="cm">/* 배열 앞쪽 index에 insert_at 하면 뒤로 한 칸씩 미는 for문 */</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">s_num_count</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">index</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">){</span>
        <span class="n">s_nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
      
    <span class="cm">/* 다 밀고나면 index에 넣고 갯수 증가 */</span>
    <span class="n">s_nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="o">++</span><span class="n">s_num_count</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">insert_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">insert_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">insert_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">insert_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">insert_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">insert_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="n">insert_at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
    <span class="n">insert_at</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>배열의 삽입엔 크게 두 가지 경우가 있습니다.</p>

    <ul>
      <li>맨 뒤에 삽입
        <ul>
          <li>그냥 넣기만 하면 끝</li>
        </ul>
      </li>
      <li>맨 뒤가 아닌 곳
        <ul>
          <li>넣을 자리 뒤의 요소들을 뒤로 한 칸씩 밀어야 합니다.</li>
          <li>O(n) 의 연산</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="244-배열의-삭제">244. 배열의 삭제</h2>

<hr />

<ul>
  <li>
    <p>삭제 코드 (위 코드에 이어서)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">remove_at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  	
	<span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">s_num_count</span><span class="p">);</span>
  	
    <span class="cm">/* 요소 갯수 줄이고 */</span>
	<span class="o">--</span><span class="n">s_num_count</span><span class="p">;</span>
    <span class="cm">/* index 뒤의 것들을 앞으로 한 칸씩 당김 */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s_num_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
		<span class="n">s_nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>삭제하는 index를 기준으로 뒤의 값들을 한 칸씩 앞으로 당깁니다.</p>

    <ul>
      <li>O(n)의 연산</li>
    </ul>
  </li>
</ul>

<h2 id="245-배열의-검색-배열의-접근">245. 배열의 검색, 배열의 접근</h2>

<hr />

<ul>
  <li>
    <p>배열 검색 코드</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">find_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  	
	<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s_num_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">s_nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">n</span><span class="p">){</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
	<span class="p">}</span>
  	
	<span class="k">return</span> <span class="n">INVALID_INDEX</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>배열의 요소를 차례로 훑으며 찾고자 하는 값이 있는지 찾고 있으면 해당 index를 반환, 없으면 -1을 반환합니다.</p>

    <ul>
      <li>O(n)의 연산</li>
    </ul>
  </li>
  <li>
    <p>index로 바로 배열의 요소의 접근하는 경우엔 O(1) 입니다.</p>

    <ul>
      <li>빈틈 없이 줄 세워놓는 가장 간단한 자료구조이기에 가능합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="246-코드보기--빠른-배열">246. 코드보기 : 빠른 배열</h2>

<hr />

<ul>
  <li>
    <p>배열에서 느린 연산을 빠르게 바꿔주는 꼼수를 알아봅시다.</p>
  </li>
  <li>
    <p>O(n)인 삭제연산을 O(1)으로 줄이는 방법을 알아봅시다.</p>
  </li>
  <li>
    <p>다만, 삭제한 뒤에 순서가 바뀐다는 단점이 있습니다. 원하는 index 부분의 값에 끝의 값을 넣어주면 됩니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">remove_at_unordered</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">){</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">s_num_count</span><span class="p">);</span>
  
    <span class="n">s_nums</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_nums</span><span class="p">[</span><span class="o">--</span><span class="n">s_num_count</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="247-스택stack">247. 스택(Stack)</h2>

<hr />

<ul>
  <li>스택은 기본적이고 유용한 자료구조입니다.</li>
  <li>LIFO (Last In First Out), FILO (First In Last Out) 자료구조입니다.</li>
  <li>중간에 있는 값에 접근할 수 없습니다. 접근 가능해지면 더이상 스택이 아니게 됩니다.. 그냥 배열.</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="p">{</span> <span class="n">TRUE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FALSE</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">MAX_NUMS</span> <span class="o">=</span> <span class="mi">8</span> <span class="p">};</span>

<span class="kt">int</span> <span class="n">s_nums</span><span class="p">[</span><span class="n">MAX_NUMS</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">s_num_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="248-스택의-삽입">248. 스택의 삽입</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">s_num_count</span> <span class="o">&lt;</span> <span class="n">MAX_NUMS</span><span class="p">);</span>
    <span class="n">s_nums</span><span class="p">[</span><span class="n">s_num_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="249-스택의-제거">249. 스택의 제거</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pop</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">is_sumpty</span><span class="p">()</span><span class="o">==</span><span class="n">FALSE</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">s_nums</span><span class="p">[</span><span class="o">--</span><span class="n">s_num_count</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>제거할 땐 실제로 데이터를 비우는게 아니라 인덱스만 옮겨줍니다. 이전 데이터는 쓰레기값이 되는 겁니다.</li>
</ul>

<h2 id="250-스택의-검색">250. 스택의 검색</h2>

<hr />

<ul>
  <li>스택에서 검색이??</li>
  <li>스택에선 일반적으로 중간에 있는 데이터데 접근하는걸 허용하지 않습니다. 그러면 중간에 있는 값을 어떻게 검색할까요? 👉 다른 빈 스택에 다 뽑으면서 확인 후에 다시 다 넣어줍니다.. ㅜㅜ</li>
  <li>검색한 값까지 빼는데 O(n), 다시 넣는데 O(n)이기 때문에 O(2n)이지만 Big-O 표기법에선 그냥 O(n)으로 씁니다.</li>
</ul>

<h2 id="251-스택의-용도">251. 스택의 용도</h2>

<hr />

<ul>
  <li>스택은 자료들의 순서를 뒤집는데 유용합니다.</li>
  <li>배열을 뒤집을때 사용할 수도 있습니다.</li>
  <li>계산기 만들때도 사용가능합니다.
    <ul>
      <li><code class="highlighter-rouge">2*(4+15)-15/3</code> 같은 것들을 ‘중위 표기법’이라고 합니다. 사람에겐 매우 익숙하지만 컴퓨터가 알아듣긴 너무 힘듭니다. 컴퓨터는 후위 표기법으로 작성해주면 스택을 이용해 아주 쉽게 계산할 수 있습니다.</li>
      <li><code class="highlighter-rouge">2 4 5 + * 15 3 / -</code> 위 중위 표기식을 후위식으로 바꾸면 이렇게 됩니다. 바꾸는 알고리즘은 알아서 찾아보시길!</li>
      <li>후위 표기법으로 바꾸고 난다면 앞에서 부터 한 글자씩 읽습니다. 피연산자면 스택에 넣고, 연산자면 스택 맨 위에서 피연산자 두개를 꺼내 연산하고 결과를 다시 스택에 넣습니다. 글자를 다 읽었으면 마지막에 스택에 남아있는 값이 결과값입니다.</li>
    </ul>
  </li>
  <li>재귀함수를 제거하는 데에도 사용할 수 있습니다.
    <ul>
      <li>재귀함수는 각 호출마다 새로 스택 프레임을 잡고 중간 결과를 저장합니다. 스택 자료구조를 사용하면 꽤 많은 재귀함수를 재귀없이 작성할 수 있습니다.</li>
      <li>작성은 직접 해보시길!</li>
    </ul>
  </li>
</ul>

<h2 id="252-큐queue">252. 큐(queue)</h2>

<hr />

<ul>
  <li>뀨는 스택과 다르게 출입구가 2개 입니다. FIFO (First In First Out) 구조!</li>
  <li>뀨 역시 중간자료엔 임의로 접근할 수 없어야 합니다.</li>
  <li>enqueue(삽입), dequeue(삭제)가 존재합니다. 배열을 기본으로 단순하게 구현하면 enqueue는 O(1)이지만 dequeue는 O(n)이 될 수 있습니다. (빼면 앞으로 한칸씩 당기는 방식으로 구현한다면)</li>
  <li>하지만, 큐는 삽입, 삭제 모두 O(1)일 수 있습니다. 내부적으로 배열을 사용하되 원형 버퍼(ring buffer) 개념을 이용하면 가능합니다. 구현할 땐 인덱스를 더 세심히 다뤄야 하지만(enqueue할 index, dequeue할 index를 모두 다뤄야 함.) 그래도 O(1)을 사수하는게 더 큰 일입니다.</li>
</ul>

<h2 id="253-큐의-삽입">253. 큐의 삽입</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="p">{</span> <span class="n">MAX_NUMS</span> <span class="o">=</span> <span class="mi">8</span> <span class="p">};</span>

<span class="kt">int</span> <span class="n">s_nums</span><span class="p">[</span><span class="n">MAX_NUMS</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">s_front</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">s_back</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">s_num_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">enqueue</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="cm">/*assert(s_num_count &lt; MAX_NUMS);*/</span>

    <span class="n">s_nums</span><span class="p">[</span><span class="n">s_back</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">s_back</span> <span class="o">=</span> <span class="p">(</span><span class="n">s_back</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">MAX_NUMS</span><span class="p">;</span>

    <span class="o">++</span><span class="n">s_num_count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="254-큐의-삭제">254. 큐의 삭제</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">dequeue</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="cm">/*assert(is_empty() == FALSE);*/</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">s_nums</span><span class="p">[</span><span class="n">s_front</span><span class="p">];</span>

    <span class="o">--</span><span class="n">s_num_count</span><span class="p">;</span>
    <span class="n">s_front</span> <span class="o">=</span> <span class="p">(</span><span class="n">s_front</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">MAX_NUMS</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="255-큐의-검색">255. 큐의 검색</h2>

<hr />

<ul>
  <li>
    <p>큐도 중간에 있는걸 검색할 수 있게 하려면 스택처럼 뺐다가 다시 넣어야 합니다. 하지만, 스택과 다르게 한번 뺐다면 다 빼야 합니다 ㅜㅜ</p>
  </li>
  <li>
    <p>큐의 용도</p>

    <ul>
      <li>대기줄이 필요한 모든 경우에 사용할 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="256-연결-리스트-연결-리스트의-삽입제거검색">256. 연결 리스트, 연결 리스트의 삽입/제거/검색</h2>

<hr />

<ul>
  <li>
    <p>지금까지 봤던 배열, 스택, 큐는 메모리상에서 연속되게 데이터들이 늘어져 있었습니다. 하지만 지금부터 볼 연결 리스트는 메모리들이 일렬로 늘어져 있지 않습니다. 힙 메모리상에 산재되어 있습니다.</p>
  </li>
  <li>
    <p>연결리스트는 메모리 관리 능력, 이중 포인터 사용 능력을 볼 수 있는 좋은 면접 문제입니다.</p>
  </li>
</ul>

<h2 id="257-연결-리스트--전체-출력-예--노드-메모리-해제-예-헤드-노드">257. 연결 리스트 : 전체 출력 예 &amp; 노드 메모리 해제 예, 헤드 노드,</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print_node</span><span class="p">(</span><span class="k">const</span> <span class="n">node_t</span><span class="o">*</span> <span class="n">head</span><span class="p">){</span>
    <span class="n">node_t</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">node_t</span><span class="o">*</span> <span class="n">head</span><span class="p">){</span>
    <span class="n">node_t</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="n">node_t</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="258-연결-리스트--삽입하기-예">258. 연결 리스트 : 삽입하기 예</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insert_front</span><span class="p">(</span><span class="n">node_t</span><span class="o">**</span> <span class="n">phead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">node_t</span><span class="o">*</span> <span class="n">new_node</span><span class="p">;</span>

    <span class="n">new_node</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node_t</span><span class="p">));</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">phead</span><span class="p">;</span>
    <span class="o">*</span><span class="n">phead</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>맨 앞에 insert</li>
</ul>

<h2 id="259-연결-리스트--오름차순으로-삽입하기-예">259. 연결 리스트 : 오름차순으로 삽입하기 예</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">insert_sorted</span><span class="p">(</span><span class="n">node_t</span><span class="o">**</span> <span class="n">phead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">node_t</span><span class="o">**</span> <span class="n">pp</span><span class="p">;</span>
    <span class="n">node_t</span><span class="o">*</span> <span class="n">new_node</span><span class="p">;</span>

    <span class="n">new_node</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node_t</span><span class="p">));</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

    <span class="n">pp</span> <span class="o">=</span> <span class="n">phead</span><span class="p">;</span>

    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">){</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
    <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>삽입한 결과 리스트가 오름차순을 유지할 수 있게 만드는 insert</li>
</ul>

<h2 id="260-연결-리스트--노드-삭제">260. 연결 리스트 : 노드 삭제</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">remove_value</span><span class="p">(</span><span class="n">node_t</span><span class="o">**</span> <span class="n">phead</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">node_t</span><span class="o">**</span> <span class="n">pp</span><span class="p">;</span>

    <span class="n">pp</span> <span class="o">=</span> <span class="n">phead</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">==</span><span class="n">n</span><span class="p">){</span>
            <span class="n">node_t</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>
            <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="261-연결-리스트의-용도">261. 연결 리스트의 용도</h2>

<hr />

<ul>
  <li>스택/큐는 알고리즘 공부하다보면 자주 만날 수 있는데 연결리스트는 자주 보진 못합니다.</li>
  <li>연결 리스트는 크기가 고정되는 배열을 한계를 넘으려고 사용하는 자료구조 입니다. 최대 길이를 미리 특정할 수 없고 삽입/삭제가 빈번할 경우 사용하면 좋은 자료구조입니다.</li>
  <li>그런데 요즘은 잘 쓰진 않습니다. 오히려 동적 할당 배열을 더 자주 사용합니다.(배열이 꽉차면 더 큰 배열 잡아서 복사하는 방식) 동적 할당 배열 방식이 최신 하드웨어에 더 적합하기 때문입니다. (향상된 메모리 지역성 때문에 - 인접한 메모리를 사용할 때 빠름)</li>
  <li>하지만 아직 커널 모드 프로그래밍에선 많이 사용합니다.
    <ul>
      <li>메모리 지역성을 해치지 않게 충분히 큰 메모리 (약 4KB)를 미리 할당 받아 사용합니다.</li>
      <li>필요에 따라 메모리들을 연결 리스트의 노드로 사용합니다.(메모리 풀)</li>
    </ul>
  </li>
  <li>배열 다음으로 많이 사용하는 자료형은 해시맵입니다.</li>
</ul>

<h2 id="262-해시-테이블">262. 해시 테이블</h2>

<hr />

<ul>
  <li>해시 테이블은 개발자로서의 기본기를 평가하는 매우 좋은 자료구조입니다.</li>
  <li>배열과 더불어 가장 많이 쓰는 자료구조이기도 합니다.</li>
  <li>해시 테이블은 검색, 삽입, 삭제 모두 평균적으로 O(1)입니다. (최악의 경우 O(n)이긴 합니다.)</li>
  <li>검색에서 O(1)이 가능하려면 어떤 메모리주소에 어떤 데이터가 있는지 한방에 알 수 있어야 합니다.</li>
</ul>

<h2 id="263-해시-테이블의-크기는-2배인-소수로">263. 해시 테이블의 크기는 2배인 소수로</h2>

<hr />

<ul>
  <li>어떤 자료값을 입력하면 그 자료값에 대한 색인을 만드는 함수를 사용하면 해시 테이블을 만들 수 있습니다.</li>
  <li>가장 간단한 방법을 생각해보면 mod 연산을 사용하는 것입니다.</li>
  <li>그런데 단순히 mod 연산을 사용하면 중복 색인이 발생할 수 있습니다.(13 -&gt; 3, 43 -&gt; 3)</li>
  <li>mod 100을 사용해 색인을 더 늘려 중복 색인을 줄일 수는 있지만 완전히 없을 순 없습니다.</li>
  <li>가장 좋은 방법은 소수를 사용하는 것입니다.
    <ul>
      <li>배열의 크기는 최소 2배로 잡습니다.</li>
      <li>크기에는 소수를 사용합니다.</li>
      <li>소수로 나눠야 동일한 색인이 안나올 가능성이 높습니다.</li>
    </ul>
  </li>
  <li>하지만 소수를 사용하는건 중복을 줄이는 방법이지 중복을 완전히 해결하는 방법은 아닙니다.</li>
</ul>

<h2 id="264-중복-색인-문제의-해결">264. 중복 색인 문제의 해결</h2>

<hr />

<h3 id="개방-주소-방법">개방 주소 방법</h3>

<ul>
  <li>중복 색인을 해결하는 방법중 하나는 색인 위치를 구하고 충돌이 나면 다음 빈 공간을 찾아 저장하는 것입니다. (개방주소방법)</li>
  <li>배열 안이 비었는지 아닌지를 파악하는 방법중 하나는 동일한 크기의 bool 배열을 만들어 배열안에 요소 존재 여부를 표기합니다.</li>
  <li>다른 bool 배열을 만들지 않는 방법으론 int max나 int min 같은 극한 값을 저장하는 것입니다.</li>
</ul>

<h3 id="연결-리스트">연결 리스트</h3>

<ul>
  <li>중복 색인을 해결하는 다른 방법중 하나는 연결 리스트를 사용하는 겁니다.</li>
  <li>해시 테이블 배열이 값을 저장하는게 아니라 노드의 포인터를 저장합니다. 중복 색인이 발생하면 기존 배열에 있던 노드 뒤로 연결 리스트를 만들어줍니다.</li>
  <li>대신 연결리스트를 사용하면 동적 할당을 계속 해야 하기 때문에 시간이 더 걸릴 수도 있습니다.</li>
</ul>

<h3 id="동적-할당-배열">동적 할당 배열</h3>

<ul>
  <li>연결 리스트를 사용하기 때문에 노드를 매번 동적할당 하는 것을 줄이고자 한다면 이중 배열을 사용할 수 있습니다. 연결 리스트 대신 일정 길이의 배열을 이용합니다.</li>
  <li>중복 색인이 많이 발생해 이중 배열이 다 차면 더 큰 배열을 동적 할당 해줍니다.</li>
</ul>

<h2 id="265-해시란-무엇인가">265. 해시란 무엇인가?</h2>

<hr />

<ul>
  <li>지금까진 ‘해시 테이블’중 ‘해시’를 사용하지 않았습니다. 이제 ‘해시’에 대해 알아봅시다.</li>
  <li>해시 값이란 어떤 데이터를 해시 함수에 넣어서 나온 결과입니다.</li>
  <li>해시 함수란 임의의 크기를 가진 데이터를 ‘고정 크기’의 값에 대응하게 만들어 주는 함수 입니다.</li>
  <li>해시 함수는 입력 값이 달라도 같은 해시 값이 나올 수 있습니다. 이런 경우를 해시 충돌 (hash colision)이라고 합니다.</li>
  <li>해시 값은 어떤 데이터를 대표하는 하나의 값이라고 생각할 수 있습니다. 그래서 영어로는 해시 값을 hash id 라고도 합니다.</li>
</ul>

<h2 id="266-해시-테이블에-문자열-저장하기">266. 해시 테이블에 문자열 저장하기</h2>

<hr />

<ul>
  <li>
    <p>문자열을 해시 테이블에 넣고 싶습니다. mod 연산은 문자열 자체에 사용할 순 없었습니다.</p>
  </li>
  <li>
    <p>문자열을 정수형으로 변환하는 해시 함수가 있으면 해시 테이블에 사용할 수 있습니다.</p>
  </li>
  <li>
    <p>문자열은 아스키 코드 정수 값들의 배열이니 이걸 잘 합쳐서 쓰면 될 것 같습니다.</p>
  </li>
  <li>
    <p>Teemo -&gt; 84 101 101 109 111</p>
  </li>
  <li>
    <p>아래는 충돌이 잦아 실제로 사용될 순 없지만 어쨌든 해시 함수이긴 한 함수입니다. 문자열의 아스키 코드 값들을 산술적으로 모두 더합니다. Teemo -&gt; 84 + 101 + 101 + 109 + 111 -&gt;506 같이. 더한 값이 int 범위만 넘지 않는다면 모든 문자열을 정수의 범위로 만들어 낼 수 있습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">hash_function</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">){</span>
        <span class="n">code</span> <span class="o">+=</span> <span class="o">*</span><span class="n">c</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
      
    <span class="k">return</span> <span class="n">code</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>그런데 이렇게 만들면 해시 값을 만들기 위해서 O(문자열길이) 만큼 돌아야 합니다. O(1)이 아닙니다. O(1)으로 만들고 싶겠죠?</p>
  </li>
  <li>
    <p>해시 함수를 한 번만 호출하고 결과를 기억해둡니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">hash_id</span> <span class="o">=</span> <span class="n">hash_function</span><span class="p">(</span><span class="err">문자열</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>필요할 때마다 이 변수로 해시 테이블 함수를 호출합니다. (이래도 결국 hash_function(문자열) 돌려야 되니까 O(문자열길이)은 도는거 아닌가…?)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add</span><span class="p">(</span><span class="n">hash_id</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>지금까지 본건 엄밀히 말하면 Hash Set 입니다. 데이터를 중복 없이 저장한게 전부입니다.</p>
  </li>
  <li>
    <p>Set도 많이 사용하지만 보통 해쉬 테이블을 말할때는 Key-Value를 저장하는 Map을 의미합니다. 알아보러 갑시다!</p>
  </li>
</ul>

<h2 id="267-해시-맵">267. 해시 맵</h2>

<hr />

<ul>
  <li>일반적으로 말하는 해시 테이블은 해시 맵으로 Key - Value를 저장합니다.</li>
  <li>key 배열과 value 배열, 두 개의 배열을 사용해 해시 맵을 만듭니다.</li>
</ul>

<h2 id="268-해시-충돌과-훌륭한-해시-함수">268. 해시 충돌과 훌륭한 해시 함수</h2>

<hr />

<ul>
  <li>충돌은 두가지 충돌일 발생할 수 있습니다.
    <ul>
      <li>해시 충돌 : 키가 다른데 같은 해시 값이 나오는 경우</li>
      <li>색인 충돌 : 해시 값이 다른데 같은 색인이 나옴</li>
    </ul>
  </li>
  <li>색인 충돌을 해결하는 방법은 앞에서 세 가지 알아봤습니다.</li>
  <li>앞에서 설명한 문자열의 각 아스키 값을 산술적으로 더해 만드는 해시 함수는 해시 충돌은 자주 일으킵니다.</li>
  <li>근데 사실 해시 충돌 문제는 해결 안해도 되긴 합니다. 해시 충돌이 나면 색인 충돌은 당연히 날 것이고, 색인 충돌을 해결하는 방법으로 해시 충돌을 같이 해결해 버리면 되니까요.</li>
  <li>하지만 해시 충돌을 방지할 수 있다면?
    <ul>
      <li>char*를 복사해서 키로 저장할 이유가 없어집니다. (해시 충돌이 있다면 충돌된 두 문자열을 가리기 위해 char* 를 복사해 키로 저장해야하기 때문입니다. 해시 충돌이 방지되는게 보장된다면 문자열 자체를 key로 저장하지 않고 해쉬 값을 키로 저장하면 됩니다.)</li>
      <li>char* 저장하려고 동적 메모리할당 같은거 안해도 됩니다.</li>
    </ul>
  </li>
  <li>훌륭한 해시 함수만 있다면 해시 충돌을 방지할 수 있습니다.</li>
  <li>훌륭한 해시 함수란?
    <ul>
      <li>어떤 경우에도(어떤 자료형, 데이터에 길이에 상관 없이) 고정된 크기의 값으로 변환 가능</li>
      <li>해시 충돌이 거의 없음(이게 핵심)</li>
      <li>해시 변환이 빠름</li>
    </ul>
  </li>
</ul>

<h2 id="269-해시-충돌-방지와-성능-향상">269. 해시 충돌 방지와 성능 향상</h2>

<hr />

<ul>
  <li>
    <p>충돌이 아예 안나는 해시 함수란 없습니다. 하지만 아주 덜 나는 함수는 있습니다. 포프님도 20년 동안 본 실제 해시 충돌은 딱 2번이랍니다. 32비트 해시에서. 64비트 해시에서는 아직 20년동안 충돌을 한 번도 못봤다고 합니다.</p>
  </li>
  <li>
    <p><a href="https://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed">https://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed</a> 에 여러 해쉬 함수들을 테스트한 귀중한 자료가 있습니다.</p>
  </li>
  <li>
    <p>간단하고 꽤 성능도 좋은 65599 해시 함수를 소개해드립니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">hash_65599</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hash</span><span class="p">;</span>
  	
	<span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="mi">65599</span> <span class="o">*</span> <span class="n">hash</span> <span class="o">+</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
  	
	<span class="k">return</span> <span class="n">hash</span> <span class="o">^</span> <span class="p">(</span><span class="n">hash</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>완전히 충돌을 없앨 수는 없지만 특정 조건 하에선 해시 충돌을 확실히 방지 가능합니다.</p>

    <ul>
      <li>실행 중에 해시 테이블에 저장될 수 있는 데이터를 모두 알고 있는 경우 (즉, 유저들에게 임의로 데이터를 받는 경우가 아닌 경우. 고성능을 요하는 게임 개발시에 많이 사용됩니다.)</li>
    </ul>
  </li>
  <li>
    <p>문자열 char*를 해시 맵으로 표현할 수 있다면 다른 자료형은 어려울 것 없습니다. 어떤 데이터도 char 배열로 표현가능하기 때문입니다.</p>
  </li>
  <li>
    <p>저장하려는 데이터에 맞는 해시 함수를 찾아 사용합시다!!</p>
  </li>
  <li>
    <p>자료구조 선택 베스트 프랙티스</p>

    <ul>
      <li>기본적으로 배열 사용합시다.
        <ul>
          <li>가장 간단하고, 캐시 메모리 덕분에 Big-O 표기법에 간관없이 제일 빠른 경우가 많습니다.(데이터가 적을경우)</li>
        </ul>
      </li>
      <li>데이터 삽입 삭제가 빈번하다면
        <ul>
          <li>연결리스트</li>
        </ul>
      </li>
      <li>데이터 양이 많은데 검색을 자주하는 경우, 배열에 넣기 힘든 데이터의 경우
        <ul>
          <li>해시 기반 자료구조</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="270-코드-보기--여러-데이터형과-해시-함수">270. 코드 보기 : 여러 데이터형과 해시 함수</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stddef.h&gt;
</span>
<span class="kt">size_t</span> <span class="nf">hash_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* float의 비트패턴을 size_t 처럼 그냥 읽어서 가져와라 */</span>
<span class="kt">size_t</span> <span class="nf">hash_float</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">){</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">((</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 문자열 65599로 해시 -&gt; 이걸이용하면 구조체 같은것도 해시값 뽑을 수 있습니다. 어차피 char 배열이기 때문에 */</span>
<span class="kt">size_t</span> <span class="nf">hash_data</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">){</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">hash</span><span class="p">;</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="mi">65599</span> <span class="o">*</span> <span class="n">hash</span> <span class="o">+</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">hash</span> <span class="o">^</span> <span class="p">(</span><span class="n">hash</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">age</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="p">}</span> <span class="n">employee_t</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">employee_t</span> <span class="n">person</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">hash</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">fvalue</span><span class="p">;</span>

    <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_int</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"int  %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>

    <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_int</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"int  %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>

    <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_int</span><span class="p">(</span><span class="sc">'A'</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"char  %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>

    <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_float</span><span class="p">(</span><span class="mi">3</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"float  %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>   

    <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_data</span><span class="p">(</span><span class="s">"Teemo"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">"Teemo"</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"string  %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span> 

    <span class="n">fvalue</span> <span class="o">=</span> <span class="mi">3</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fvalue</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"float  %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>

    <span class="cm">/* 구조체 변수 자리에 쓰레기 값이 끼면 어떤 쓰레기가 끼냐에 따라 해시 값이 달라질 수 있으므로 초기화 하고 씁니다. */</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">employee_t</span><span class="p">));</span> 
    <span class="n">person</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
    <span class="n">person</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">21314</span><span class="p">;</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="s">"Teemo"</span><span class="p">);</span>

    <span class="n">hash</span> <span class="o">=</span> <span class="n">hash_data</span><span class="p">(</span><span class="o">&amp;</span><span class="n">person</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">employee_t</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"struct %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
int  10
int  4294967286
char  65
float  1078774989
string  15341118
float  2077161318
struct 524849085
*/</span>
</code></pre></div></div>

<h2 id="271-정리">271. 정리</h2>

<hr />

<ul>
  <li>지금까지 기초 자료구조를 쭉 봤습니다. 이건 기초중에 기초입니다. 더 복잡한 자료구조들이 많이 많이 있습니다.</li>
</ul>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
