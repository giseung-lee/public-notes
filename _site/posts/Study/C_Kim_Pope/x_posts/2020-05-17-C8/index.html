<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      C Unmanaged Programming 8 - 가변 인자 함수, 올바른 오류 처리 방법 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/About Me">About Me</a>
      
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Sagyo_Reboot">Sagyo_Reboot</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Twitch_Chat_Analysis">Twitch_Chat_Analysis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Algorithm">Algorithm</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/java">java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/jekyll">jekyll</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/linux">linux</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">C Unmanaged Programming 8 - 가변 인자 함수, 올바른 오류 처리 방법</h1>
  <span class="post-date"></span>
  
<h2 id="214-가변-인자-함수">214. 가변 인자 함수</h2>

<hr />

<ul>
  <li>
    <p>가변인자함수는 말 그대로 매개변수가 변할 수 있는 함수입니다. 예를들어 printf 함수!!</p>
  </li>
  <li>
    <p>가변 인자 함수는 아래와 같이 선언합니다.</p>

    <ul>
      <li>
        <반환형> <함수명> (<자료형이 정해진="" 매개변수="" 목록="">, ...)
</자료형이></함수명></반환형>
      </li>
      <li>최소 한 개의 정해진 자료형의 매개변수는 필요합니다.</li>
      <li>가변 인자는 ‘…‘으로 표현합니다.</li>
    </ul>
  </li>
  <li>
    <p>자주 사용되진 않지만 유용한 경우가 있습니다.</p>

    <ul>
      <li>메모리에 블록을 크게 잡아 두고 거기에 여러 자료형을 저장하는 함수에서 사용합니다.</li>
      <li>printf / scanf 가 대표적입니다.</li>
    </ul>
  </li>
  <li>
    <p>사용 예시입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdarg.h&gt;
</span>  
<span class="kt">int</span> <span class="nf">add_ints</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="p">...){</span>
    <span class="cm">/* va_list 타입*/</span>
	<span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
      
    <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="cm">/* va_start 매크로 함수 */</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="p">{</span><span class="cm">/* 가독성을 위한 의미 없는 중괄호. 없어도 됩니다. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="cm">/* va_arg 매크로 함수 */</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* va_end 매크로 함수 */</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
      
    <span class="k">return</span> <span class="n">sum</span>
<span class="p">}</span>
  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
      
    <span class="n">result</span> <span class="o">=</span> <span class="n">add_ints</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"result: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="cm">/* result: 16 */</span>
      
    <span class="n">result</span> <span class="o">=</span> <span class="n">add_ints</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"result: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="cm">/* result: 10 */</span>
      
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <h2 id="215-va_로-시작하는-매크로-함수들">215. va_로 시작하는 매크로 함수들</h2>
  </li>
</ul>

<hr />

<ul>
  <li>
    <p>va_list 타입</p>

    <ul>
      <li>가변 인자 목록</li>
      <li>va_start, va_arg, va_end <strong>매크로 함수</strong>를 사용할 때 필요한 정보가 포함됩니다.</li>
      <li>표준에서 언급은 됐지만 정확히 정의하진 않았습니다. 즉, 컴파일러마다 다르게 해석할 수 있습니다.</li>
    </ul>
  </li>
  <li>va_start(<가변인자목록>, <가변 인자="" 시작하기="" 직전="" 매개변수="">);
</가변></가변인자목록>    <ul>
      <li>매크로 함수입니다.</li>
      <li>가변 인자들에 접근하기 전에 반드시 호출해야 합니다.</li>
      <li>va_list에 필요한 초기화를 수행합니다.
        <ul>
          <li>가변 인자가 스택 메모리의 어디서부터 시작하는 지 등..</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>va_end(<가변 인자="" 목록="">);
</가변>    <ul>
      <li>매크로 함수입니다.</li>
      <li>사용했던 가변 인자 목록을 정리합니다.</li>
      <li>가변 인자 접근이 끝나면 반드시 호출해야 합니다.</li>
    </ul>
  </li>
  <li>va_arg(<가변 인자="" 목록="">, <얻어올 가변="" 인자의="" 자료형="">);
</얻어올></가변>    <ul>
      <li>매크로 함수입니다.</li>
      <li>가변 인자 목록에서 다음 가변 인자를 가져옵니다.</li>
      <li>표준상 문제로 가변 인자 목록의 기본 자료형은 아래와 같이 승격(promotion) 됩니다.
        <ul>
          <li>모든 정수형은 int 형이 됩니다.</li>
          <li>모든 부동소수점은 double이 됩니다.</li>
        </ul>
      </li>
      <li>즉, 두번째 매개변수에는 int나 double이 오게 됩니다.</li>
      <li>기본 자료형 말고도 구조체도 가변 인자로 넣을 수 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>하드웨어가 가변 인자 목록에서 자료를 읽을 때 어떤 형으로 읽을 지 알아야 합니다. 컴파일러가 이를 알려줘야 합니다. 어떤 자료형으로 읽을지.  근데 방금 전에 위 예시 코드에선 그런걸 한 적이 없습니다. 그걸 전처리기가 해줍니다.</p>
  </li>
  <li>
    <p>개발자는 va_arg라는 매크로 함수를 썼고, 이를 보고 전처리기가 va_arg를 바꿔줍니다. 바꾼 코드를 컴파일러가 컴파일해 줍니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li>위와 같은 개발자의 코드를 아래와 같이 바꿔줍니다.</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">val</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
<span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="p">.</span><span class="n">data</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="216-가변-인자-함수가-인자를-읽어오는-방법">216. 가변 인자 함수가 인자를 읽어오는 방법</h2>

<hr />

<ul>
  <li>매개 변수가 다른데 어떻게 매번 스택에 맞게 넣을까요?</li>
  <li>가변 인자 함수를 호출하는 함수는 몇개의 매개변수가 필요한 지 알고 있습니다. 해당 갯수만큼 넣어주면 됩니다.</li>
  <li>근데 그럼 그 가변 인자 함수는 자기가 몇개의 매개변수를 받았는지 어떻게 알까요? 호출된 가변 인자 함수의 스택 프레임에서도 매개 변수 갯수를 알아야 연산을 할텐데요.</li>
  <li>그때 사용되는게 <code class="highlighter-rouge">va_start(ap, count)</code>입니다. 가변인자 시작 직전 매개변수(처음 매개변수)의 타입에 기초해 메모리를 계산해줍니다. 위 예시에서 <code class="highlighter-rouge">va_start(ap, count)</code>를 하게 되면 <code class="highlighter-rouge">ap.data = (char*)&amp;count + sizeof(count);</code> 가 수행 됩니다.</li>
  <li>이후 <code class="highlighter-rouge">va_arg(ap, int);</code>가 호출될 때마다 int 크기만큼 주소를 옮겨가며 데이터를 읽습니다. 즉, <code class="highlighter-rouge">val = *(int*)ap.data; </code>와 <code class="highlighter-rouge">((int*)ap.data)++;</code>가 수행됩니다.</li>
  <li>이 모든 건 va_list 타입이 스택 메모리를 가리키는 포인터 같은 것을 가지고 있어서 가능한 일입니다.</li>
  <li>음.. 사실 잘 이해가 안됩니다..</li>
</ul>

<h2 id="217-함수에서-매개변수로-가변-인자만-받을-수-있을까">217. 함수에서 매개변수로 가변 인자만 받을 수 있을까?</h2>

<hr />

<ul>
  <li>
    <p>위에서 살펴본 가변 인자 함수를 사용할 땐 맨 처음으로 자료형이 특정된 매개 변수가 있어야 합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">do_something</span><span class="p">(...,</span> <span class="kt">int</span><span class="p">);</span> <span class="cm">/* 컴파일 에러 */</span>
<span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="p">...,</span> <span class="kt">int</span><span class="p">);</span> <span class="cm">/* 컴파일 에러 */</span>
<span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* 성공 */</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>가변 인자 아닌 것을 읽고, 가변 인자 직전의 인자를 가지고 포인터를 옮길 offset을 정하고, 해당 주소를 어떤 타입으로 읽어야 하는지 알려줘야 합니다.</p>
  </li>
  <li>
    <p>가변인자의 갯수도 반드시 넘겨주고, 가변인자의 타입을 알려줄 인자도 넘겨줍시다.</p>
  </li>
  <li>
    <p>그런데 printf 함수를 생각해봅시다. <code class="highlighter-rouge">printf("%s %d\n", msg, count);</code>와 같이 가변 인자가 몇개인지도 안알려주고 타입도 다릅니다.</p>

    <ul>
      <li>하지만, printf 함수 안에서 첫 번째 인자를 가지고 가변인자 몇 개가 들어오는지, 어떤 타입들이 들어오는지 알아내는 로직을 구현해 놓은 것입니다.</li>
    </ul>
  </li>
</ul>

<h2 id="218-코드보기--초간단-서식-지정자">218. 코드보기 : 초간단 서식 지정자</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* main.c */</span>

<span class="cp">#include "simpleio.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="n">printf_simple</span><span class="p">(</span><span class="s">"c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">);</span>
    <span class="n">printf_simple</span><span class="p">(</span><span class="s">"d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">printf_simple</span><span class="p">(</span><span class="s">"s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span>
    
    <span class="n">printf_simple</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf_simple</span><span class="p">(</span><span class="s">"c d s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="sc">'B'</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">"Hi"</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* simpleio.c */</span>

<span class="cp">#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="cp">#include "simpleio.h"
</span>
<span class="cm">/* static을 붙인건 이 파일 안에서만 쓸 함수이기 때문 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_int_recursive</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    
	<span class="n">print_int_recursive</span><span class="p">(</span><span class="n">val</span><span class="o">/</span><span class="mi">10</span><span class="p">);</span>
    <span class="cm">/* ASCII 코드 문자 '0'에 해당하는 숫자 30을 더해도 되지만 가독성을 위해 '0'을 더해줍니다. */</span>
    <span class="cm">/* '0'을 써도 컴파일할때 30으로 바꿔줍니다. */</span>
    <span class="n">putchar</span><span class="p">(</span><span class="sc">'0'</span> <span class="o">+</span> <span class="n">val</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printf_simple</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...){</span>
    <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span>
    
    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">){</span>
            <span class="kt">unsigned</span> <span class="n">val</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">;</span>
            
            <span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span><span class="p">){</span>
                <span class="k">case</span> <span class="sc">'s'</span><span class="p">:</span>
                    <span class="n">str</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
                    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="o">!=</span><span class="sc">'\0'</span><span class="p">){</span>
                        <span class="n">putchar</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="o">++</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'c'</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
                    <span class="n">putchar</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'d'</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
                    <span class="n">print_int_recursive</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="nl">default:</span>
                    <span class="n">putchar</span><span class="p">(</span><span class="o">*</span><span class="n">format</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<h2 id="219-오류-처리">219. 오류 처리</h2>

<hr />

<ul>
  <li>C엔 기본적으로 예외 처리가 없습니다. 그런데 운영체제도 C로 만들었고.. C로 만든 훌륭한 소프트웨어들이 많습니다. 사실, 예외 처리가 프로그래밍 언어의 필수 요소는 아닙니다. 개발자가 오류 처리만 잘 해준다면 말이죠.</li>
  <li>다른 언어에선 try ~ exception으로 가볍게 처리하면 되지만, C에선 발생할 수 있는 오류들을 세심히 다뤄줘야 합니다.</li>
  <li>보통 설계할 때 happy path만 고려하고 설계합니다. 그리고 개발중 예외가 발생해도 제대로 안고치가 유야무야 덮어두고 넘어가기도 합니다. 또, 테스트 중에 예외를 발견해도 잘 발생하지 않으면 모른척 하고 넘어가기도 합니다.</li>
  <li>크래시(아예 프로그램이 뻑나는 상황)가 나면 답이 없습니다.
    <ul>
      <li>하지만, 크래시가 미리 날 수록 프로그램 품질이 올라갑니다</li>
    </ul>
  </li>
  <li>예외를 대충 고치면 나중에 더더더 힘들어집니다.</li>
</ul>

<h2 id="220-안-좋은-오류-처리의-예">220. 안 좋은 오류 처리의 예</h2>

<hr />

<ul>
  <li>
    <p>안좋은 오류 처리의 예를 보여드리겠습니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">b</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
  	
	<span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 코드에서 null 포인터 에러가 난다는 항의가 들어오면 아무 생각 없이 이렇게 고치곤 합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">b</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">temp</span><span class="p">;</span>
  	
    <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="nb">NULL</span> <span class="o">||</span> <span class="n">b</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
      
	<span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
	<span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 예외처리의 문제는 swap 함수를 호출한 사람이 swap이 제대로 됐는지, 중간에 예외처리가 됐는지 알 수 없습니다.</p>
  </li>
  <li>
    <p>그리고, 이렇게 함수 마다 예외처리를 두는건 바람직하지 않습니다. 예를들어, 프로그래밍보다 더 오랜 역사를 가지고 있는 전기 회로를 생각해봅시다. 집에 누전차단기는 1개만 있습니다. 위 처럼 끝의 함수마다 예외처리를 모두 하는 건 콘센트 마다 누전차단기 두는 거랑 비슷합니다.</p>
  </li>
  <li>
    <p>문제는 한 군데에서만 찾는게 효율적입니다.</p>
  </li>
  <li>
    <p>오류처리에도 원칙이 있어야 합니다. 어떤 원칙이 올바른 오류처리의 원칙인지 알아봅시다.</p>
  </li>
</ul>

<h2 id="221-버그와-오류의-차이-올바른-오류-처리-전략">221. 버그와 오류의 차이, 올바른 오류 처리 전략</h2>

<hr />

<ul>
  <li>
    <p>버그와 오류는 다릅니다.</p>
  </li>
  <li>
    <p>버그</p>

    <ul>
      <li>예외적인 상황에서도 존재하면 안됩니다. 개발자가 의도하지 않은, 일어날 수 없다고 가정한 상황입니다.</li>
      <li>선조건 및 후조건이 성립하지 않고 assert에 실패하는 경우
        <ul>
          <li>선조건, 후조건은 함수 이름이나 변수 이름으로 유추할 수 있어야 합니다. 그렇게 설정할 수 없다면 주석이라도 달아야 합니다.</li>
          <li>선조건, 후조건이 참인지 검사하는 assert를 넣어줍시다.</li>
        </ul>
      </li>
      <li>더 이상 발생하지 않도록 프로그램을 수정해야 합니다.</li>
    </ul>
  </li>
  <li>
    <p>오류</p>

    <ul>
      <li>실제 실행 중 일어날 수 있는 예측 가능한 예외 상황들</li>
      <li>실행 중에 발생해도 프로그램이 대처하게 해줘야 합니다.</li>
    </ul>
  </li>
  <li>
    <p>버그는 잡았다고 가정하고 코드를 작성합니다. 즉, 내 함수에 들어오는 데이터는 모두 유효하다고 가정합니다. 유효하지 않은 데이터를 걸러주는 곳이 필요합니다. 이를 ‘경계(boundary)’ 라고 부릅니다.</p>

    <ul>
      <li>매 함수마다 입력 받은 데이터를 검증하는 과정을 거치는 건 비효율적입니다.</li>
    </ul>
  </li>
  <li>
    <p>널 포인터를 받을 수 있는 함수들은 함수명, 변수명에 알 수 있게 해줍시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">moster_t</span><span class="o">*</span> <span class="nf">spawn_monstart_or_null</span><span class="p">(</span><span class="k">const</span> <span class="n">moster_t</span><span class="o">*</span> <span class="n">special_monster_or_null</span><span class="p">){</span>
	<span class="cm">/* 코드 */</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>오류를 처리해주는 함수/코드에선 오류가 있음을 알려줘야 합니다. 가장 좋은 방법은 함수에서 오류 코드를 반환하도록 하는 것입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">libabc_error_t</span> <span class="nf">try_get_student</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">student_info_t</span><span class="o">*</span> <span class="n">out_student</span><span class="p">){</span>
	<span class="kt">size_t</span> <span class="n">idx</span><span class="p">;</span>
  	
	<span class="cm">/* 코드 생략 */</span>
  	
	<span class="k">if</span><span class="p">(</span><span class="n">idx</span><span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
		<span class="cm">/* 오류 코드 반환 */</span>
		<span class="k">return</span> <span class="n">ERROR_STUDENT_NOTFOUND</span><span class="p">;</span> 
	<span class="p">}</span>
  	
	<span class="cm">/* 코드 생략 */</span>
  	
	<span class="cm">/* 오류 없음 코드 */</span>
	<span class="k">return</span> <span class="n">ERROR_NONE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>C에선 모든 오류 코드를 하나의 enum으로 만드는 게 좋습니다.</p>

    <ul>
      <li>C에선 enum끼리 막 대입이 돼서 오류 코드를 구분해서 여러 enum으로 했다가 실수할 수 있습니다.
        <ul>
          <li>다른 enum끼리 == 비교를 했는데 값이 같아서 같다고 나오는 경우</li>
        </ul>
      </li>
      <li>구조체로 해도 되긴 하는데 보통 열거형을 많이 씁니다.</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">enum</span><span class="p">{</span>
	<span class="n">ERROR_ONE</span><span class="p">;</span>
	<span class="n">ERROR_TWO</span><span class="p">;</span>
	<span class="o">:</span>
	<span class="n">ERROR_TEN</span><span class="p">;</span>
<span class="p">}</span> <span class="n">libabc_error_t</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>함수에서 errno 에 에러코드를 저장하는 방법도 있으나 좋은 방법은 아닙니다. errno을 잘 안쓰기 때문에 해당 함수에서 errno을 쓰는걸 알아야 하는데 문서를 잘 안봅니다.</p>
  </li>
  <li>
    <p>정리</p>

    <ul>
      <li>기본적으로 내가 작성하는 모든 함수에 들어오는 데이터는 유효하다고 가정하고 assert를 많이 쓸 것</li>
      <li>그렇지 않은 함수는 매개변수나 함수 이름에서 그렇지 않다는 사실을 명백히 표시할 것</li>
      <li>오류 상황을 처리하는 장소는 최소한으로 할 것</li>
      <li>어떤 함수가 오류 처리를 한다는 사실을 반환형 등을 통해 확실히 보여줄 것</li>
    </ul>
  </li>
</ul>

<h2 id="222-오류-처리-후에도-발생하는-예외-상황">222. 오류 처리 후에도 발생하는 예외 상황</h2>

<hr />

<ul>
  <li>오류 처리했는데도 발생하는 예외들은 버그입니다. 코드를 다시 써야 합니다.</li>
  <li>소프트웨어 품질은 테스트/QA 프로세스의 문제입니다.</li>
  <li>C에는 try/catch가 없지만 운영체제에서 비슷한걸 해주긴 합니다.
    <ul>
      <li>윈도우 - SEH(구조적 예외 처리)</li>
      <li>리눅스 - POSIX 신호, Faluts, Traps, Aborts</li>
    </ul>
  </li>
</ul>

<h2 id="223-정리">223. 정리</h2>

<hr />

<ul>
  <li>이번 섹션에서 배운 가변 인자 함수, 올바른 오류처리 방법은 지금 당장 막 활용하고 이런건 아니지만, C를 계속하다보면 언젠가는 만나는, 나중에 쓸 때 기억나면 찾아볼만한 내용들입니다.</li>
</ul>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
