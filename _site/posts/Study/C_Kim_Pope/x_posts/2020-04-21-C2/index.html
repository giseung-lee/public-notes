<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      C Unmanaged Programming 2 - C언어 기본 문법1 &middot; 이기승의 끄적끄적..
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item sidebar-profile-box">
    <img class="sidebar-profile-image" src="/public/image/About Me/sidebar_profile.png" >
    <div class="sidebar-profile-description">
      <span>
        &nbsp;잡기에 능한 개발자입니다. 잡기보다 개발 실력이 좋아야 할 텐데 걱정입니다.
      </span>
    </div>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/About Me">About Me</a>
      
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/Daily Thoughts">Daily Thoughts</a>
      
    
      
        <input id="Projects" class="toggle" type="checkbox">
        <label for="Projects" class="lbl-toggle sidebar-nav-item" tabindex="0">Projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Sagyo_Reboot">Sagyo_Reboot</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Twitch_Chat_Analysis">Twitch_Chat_Analysis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/Hwangmaesan">Hwangmaesan</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Projects/The_Oyster_Mine">The_Oyster_Mine</a>
          
        
        </div>
      
    
      
        <input id="Study" class="toggle" type="checkbox">
        <label for="Study" class="lbl-toggle sidebar-nav-item" tabindex="0">Study</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Short_Books">Short_Books</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Algorithm">Algorithm</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/Http The Definitive Guide">Http The Definitive Guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/C_Kim_Pope">C_Kim_Pope</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Study/MSA_Ken_Krueger">MSA_Ken_Krueger</a>
          
        
        </div>
      
    
      
        <input id="Googling" class="toggle" type="checkbox">
        <label for="Googling" class="lbl-toggle sidebar-nav-item" tabindex="0">Googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Java">Java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Spring">Spring</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Data_Structure">Data_Structure</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/Googling/Network">Network</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title" style="font-weight: normal;">
            <a href="/" title="Home">이기승의 끄적끄적..</a>
            <small>개발 및 잡다한 포스팅</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">C Unmanaged Programming 2 - C언어 기본 문법1</h1>
  <span class="post-date"></span>
  
<ul>
  <li>
    <p>해당 포스팅은 <a href="https://www.udemy.com/course/c-unmanaged-programming-by-pocu/">Kim Pope 선생님의 C 언매니지드 프로그래밍 강의</a>를 정리하며 사견을 붙인 것입니다.</p>
  </li>
  <li>
    <p>포스팅 내 목차는 동영상강의 기준입니다.</p>
  </li>
</ul>

<h2 id="12-c89-표준">12. C89 표준</h2>

<hr />

<ul>
  <li>가장 먼저 배울 표준은 C89/ANSI-C 입니다. 사실상 C의 70~80%를 차지할 정도로 기본이 되는 표준입니다.</li>
  <li>전부터 C는 있었는데 1989년에 ANSI에서 처음으로 표준을 만들었습니다. 30년이 지났지만 대부분 컴파일러가 지원하는 표준입니다.</li>
  <li>많은 임베디드 시스템은 C89만 지원하는 경우가 많습니다.
    <ul>
      <li>소형 임베디드 기기에선 그 기기 전용 OS를 사용하기 때문입니다. 윈도우, 리눅스 처럼 다양한 기능을 갖춘 범용 OS를 탑재하긴 힘듭니다.</li>
    </ul>
  </li>
</ul>

<h2 id="13-hello-world">13. Hello World</h2>

<hr />

<ul>
  <li>코드를 배울땐 당연히 Hello World 한 번 찍어야 하지 않겠습니까</li>
  <li>강의 너무 쪼개신거 아닙니까</li>
</ul>

<h2 id="14-include-stdioh">14. #include, stdio.h</h2>

<hr />

<ul>
  <li><code class="highlighter-rouge">#include</code>
    <ul>
      <li><code class="highlighter-rouge">#include</code>는 C#에서 <code class="highlighter-rouge">using</code>과 같은 역할을 합니다.</li>
      <li>다른 파일에 구현된 함수, 변수를 사용하게 해줍니다.</li>
      <li>단, C# 처럼 알아서 함수, 변수를 찾아주진 않습니다. 뒤에서 더 자세히 알아봅니다.</li>
      <li>#include는 <strong><em>전처리기(preprocessor) 지시문 중 하나</em></strong>입니다.
        <ul>
          <li><strong><em>컴파일 하기 전에 무언가</em></strong>를 해주는 일입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">#include &lt;stdio.h&gt;</code>
    <ul>
      <li><code class="highlighter-rouge">&lt; &gt;</code>안에는 디스크에 있는 실제 파일 이름이 들어갑니다. (실제로 stdio.h 라는 파일이 존재합니다.)</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">#include &lt;stdio.h&gt;</code> 동작과정
    <ol>
      <li>헤더파일(*.h)를 열어 내용을 복사합니다.</li>
      <li><strong>메모리 상에서 <code class="highlighter-rouge">#include &lt;stdio.h&gt;</code>를 지우고 복사한 내용을 그대로 붙입니다.</strong></li>
      <li>컴파일 하기 전에 이 복붙 작업을 해서 <strong>컴파일 하기 전에 필요한 함수를 실제로 텍스트로 가져와 붙여놓고 같이 컴파일 하는 것입니다.</strong></li>
    </ol>
  </li>
  <li>
    <p>최신 언어들은 이런 복붙, 컴파일 방식을 사용하진 않습니다.</p>
  </li>
  <li><code class="highlighter-rouge">#include 'stdio.h'</code>는 컴파일 오류가 납니다. <code class="highlighter-rouge">#include "stdio.h"</code>는 맞는 방법이긴 하지만, 추천하진 않습니다. 추후 더 알아봅니다.</li>
  <li><code class="highlighter-rouge">&lt;stdio.h&gt;</code> 는 C 표준 라이브러리 중 일부입니다.
    <ul>
      <li>C 표준 라이브러리는 문자열 처리, 계산, 입출력 처리, 메모리 관리 등에 필요한 기본 매크로, 자료형, 함수를 모아 놓은 것입니다.</li>
      <li>그 중 stdio.h는 Standard Input and Output 입니다. 스트림 입출력에 관련한 함수를 포함합니다.</li>
      <li>printf(), scanf(), fopen(), fclose() 같은 함수들이 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="15-mainvoid-함수">15. main(void) 함수</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>main(void) 함수는 프로그램의 진입점(entry point)입니다.</p>
  </li>
  <li>
    <p>C 코드를 빌드해 나온 실행 파일을 실행하면 main(void)함수가 실행되도록 약속되어 있습니다.</p>
  </li>
  <li>
    <p>java에서의 main 함수는 void를 리턴하지만, C는 int를 리턴합니다.</p>

    <ul>
      <li>return 0 : 프로그램에 문제가 없다.</li>
    </ul>
  </li>
  <li>
    <p>그런데 cmd에서 c 프로그램 실행시켜 보면 마지막 return 0;을 볼 수 없는데 어디갔죠?</p>

    <ul>
      <li>실행이 끝난 뒤 <code class="highlighter-rouge">echo %errorlevel%</code> 을 해보시면 마지막 리턴 값이 나옵니다.</li>
      <li>Shell에선 <code class="highlighter-rouge">echo $?</code>를 찍어보면 됩니다.</li>
    </ul>
  </li>
  <li>
    <p>이 강의에선 굳이 IDE를 안써도 됩니다. 메모장과 cmd로 해도 충분한 강의 입니다. cmd에서 컴파일러 옵션 줘가면서 하는 방법도 알아둡시다.</p>

    <ul>
      <li>윈도우용 c 컴파일러인 clang을 찾아서 설치해줍니다.</li>
      <li>cmd에서 컴파일 결과 파일 이름 안정해주면 <code class="highlighter-rouge">a.exe</code>로 만들어집니다.</li>
      <li>C는 클라식하게 배워주는 맛이 있습니다.</li>
      <li>이번 강의에선 디버깅도 눈버깅, 뇌버깅으로 하니다.</li>
    </ul>
  </li>
  <li>
    <p>main(void) 함수 : (void)</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="o">(</span><span class="kt">void</span><span class="o">)</span>
<span class="o">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <ul>
      <li>void를 생략한다고 매개변수가 없다는 뜻이 아닙니다.</li>
      <li>C에선 함수 선언과 함수 정의가 따로 있습니다.
        <ul>
          <li>함수 선언은 <code class="highlighter-rouge">int sum(void);</code> 와 같은 식으로 변수 선언 하듯이 선언만 해주는 것이고, 함수 정의는 위에 있는 main 함수 처럼 <code class="highlighter-rouge">{}</code>를 열어 함수를 작성해주는 것입니다.</li>
          <li>함수 선언에서 void 생략 👉 매개변수를 받겠다.(하지만 아직 갯수나 자료형을 모른다)</li>
          <li>함수 정의에서 void 생략 👉 매개변수가 없다.</li>
        </ul>
      </li>
      <li>위와 같이 void 생략시 헷갈릴 수 있으므로 매개변수 안 받을 땐 void를 항상 써줍시다.
        <ul>
          <li>필수는 아니지만, 약속입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="16-printf-함수">16. printf() 함수</h2>

<hr />

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf('hellow world\n')
</code></pre></div></div>

<ul>
  <li>
    <p>이건 뭐 간단하지. printf에서 f는 format, \n은 개행</p>
  </li>
  <li>
    <p>근데 C는 조금 불친절 합니다. C#이나 기타 언어에선 string formatting에서 아래와 같이 다양한 방법을 지원합니다.</p>

    <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="n">name</span> <span class="p">=</span> <span class="s">"Kiseung"</span><span class="p">;</span>
  
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"hello, "</span> <span class="p">+</span> <span class="n">name</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"hello, {0}"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span> 
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"hello, </span><span class="p">{</span><span class="n">name</span><span class="p">}</span><span class="s">"</span><span class="p">);</span> <span class="c1">// 문자열 보간</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>하지만 C엔 이런거 없습니다. ‘%s’, ‘%d’, ‘%f’ 같은 서식 문자(format specifier)만 사용합니다. 자바에서 많이 본 친구네요.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Kiseung"</span><span class="p">;</span>
  
<span class="n">printf</span><span class="p">(</span><span class="s">"hello, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="17-주석comment">17. 주석(comment)</h2>

<hr />

<ul>
  <li>C89에서 주석은 <code class="highlighter-rouge">/* */</code>만 지원한다고 합니다. 아 이건 조금 충격적입니다.</li>
  <li>이후 표준에선 <code class="highlighter-rouge">//</code>도 지원하지만, 많은 컴파일러가 C89를 표준으로 삼기 때문에 그냥 맘 편히 <code class="highlighter-rouge">/* */</code>를 사용합시다.</li>
</ul>

<h2 id="18-c언어의-기본-문법">18. C언어의 기본 문법</h2>

<hr />

<ul>
  <li>이 강의는 프로그래밍을 할 줄 아는 사람들을 대상으로 하기 때문에, C언어 기본 문법 파트는 빠르게 후딱 지나갈 겁니다.</li>
  <li>C는 순수하게 절차적 언어입니다.</li>
  <li>C 코드는 데이터보다 프로세스에 중점이 맞춰져 있습니다.
    <ul>
      <li>프로세스는 CPU의 레지스터 수준에서 일어나는 빠른 작업이고, 프로세스가 끝난 데이터들이 메모리에 저장됩니다.</li>
      <li>C는 컴퓨터가 돌아가는 대로 작성하면 되기 때문에 코딩 방법론에 대한 논쟁이 크지 않습니다.</li>
      <li>객체지향 같은 경우엔 추상적인 개념이 많기 때문에 박터지게 논쟁합니다.</li>
    </ul>
  </li>
  <li>C에선
    <ul>
      <li>클래스 👉 없음!</li>
      <li>함수 👉 모두 global 함수, 어디서나 호출 가능!</li>
      <li>변수 👉 함수 밖에 있으면 전역 변수, 함수 안에 있으면 지역 변수!</li>
    </ul>
  </li>
</ul>

<h2 id="19-자료형-unsigned와-signed">19. 자료형, unsigned와 signed</h2>

<hr />

<ul>
  <li>C89의 기본 자료형
    <ul>
      <li>char</li>
      <li>short</li>
      <li>int</li>
      <li>long</li>
      <li>float</li>
      <li>double</li>
      <li>long double</li>
    </ul>
  </li>
  <li>C#에선 unsigned 자료형을 표시하기 위해 접두사 u를 붙였었습니다.
    <ul>
      <li>int 👉 uint 등등..</li>
      <li>단, byte는 기본이 unsigned이기 때문에, sbyte로 signed 를 표시</li>
    </ul>
  </li>
  <li>C에선 unsigned 단어를 붙여줘야 합니다.
    <ul>
      <li>int 👉 unsigned int</li>
    </ul>
  </li>
  <li>signed 인걸 명시해줘도 되지만, 생략하면 기본이 signed입니다.
    <ul>
      <li>int == signed int</li>
      <li>단, char는 예외입니다.
        <ul>
          <li>C에서 char는 1byte 정수로 표현되기 때문인데, 바로 다음 동영상에서 알아봅니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="20-char-형">20. char 형</h2>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>char는 최소 8비트인 정수형입니다.</p>
  </li>
  <li>
    <p>표준에선 ‘8비트 이상’이라고 정의합니다.</p>
  </li>
  <li>
    <p>표준에 따르면 1백만 비트인 char도 가능합니다.</p>
  </li>
  <li>
    <limits.h> 헤더를 포함한 뒤, CHAR_BIT 를 찍어보면 몇 비트를 쓰는지 알 수 있습니다. (보통 8bit가 나오긴 합니다.)

```c
#include <limits.h>
  
int main(void)
{
	char char_size = CHAR_BIT;
	return 0;
}
```

</limits.h></limits.h>
  </li>
  <li>
    <p>근데 여기서 부터가 좀 이상합니다.</p>

    <ul>
      <li>c 표준에선 기본자료형의 정확한 바이트 수를 강요하지 않습니다.(컴파일러 재량으로 맡깁니다.)</li>
      <li>그리고 1Byte==8bit가 아니라 c에서 1Byte는 CHAR_BIT 만큼이라고 말합니다.
        <ul>
          <li>즉, CHAR_BIT이 16bit 라면, 그 기기에선 1Byte==16bit 가 됩니다 😳😳😳 이게 뭔소리여</li>
          <li>반대로 말하면, char의 크기 == 1Byte 라고 표현 할 수 있습니다.</li>
        </ul>
      </li>
      <li>char라는건, 기기에서 표현 가능한 가장 작은 단위의 메모리입니다. 어떤 기기에선 저장 가능한 최소 단위가 8bit일수도, 16bit 일수도 있다는 겁니다.</li>
    </ul>
  </li>
  <li>
    <p>기본 ASCII는 0~127 숫자로 표현 가능합니다. char가 8bit라고 해도 7bit만 가지고도 표현 가능합니다.</p>

    <ul>
      <li>즉, 첫 비트는 안쓰입니다.</li>
      <li>그런데, 정수형이니 일단 signed/unsigned가 있습니다.</li>
      <li>그럼 명시하지 않으면 char의 기본 부호는 무엇일까요?
        <ul>
          <li>C 표준에서 정하지 않고 있습니다. 이 역시 컴파일러 재량에 맡기게 됩니다.</li>
          <li>char의 기본 부호를 signed를 볼 수도, unsigned를 볼 수도 있습니다.</li>
          <li>강의에서 쓰는 clang은 char를 signed로 간주합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>char를 숫자로 다루고 싶은 경우엔 signed, unsigned를 명시해서 써줍시다.</p>
  </li>
  <li>
    <p>signed, unsigned를 고려하지 않았다면, char값은 signed/unsigned 구분 안해도 되는 0~127에서 놀도록 잘 관리해줍시다. C는 참 재밌네.</p>
  </li>
  <li>
    <limits.h> 헤더파일에서 char의 최솟 값인 CHAR_MIN을 찍어보면 signed인지, unsigend 인지 알 수 있음.

</limits.h>
  </li>
  <li>
    <p>포팅에 문제 없는 범위</p>

    <ul>
      <li>unsinged char 👉 0~255</li>
      <li>char 👉 0~127</li>
      <li>signed char 👉 -127~127
        <ul>
          <li>-128을 포함안하는 이유는 1의 보수를 사용하는 옛날 기계가 -128을 컴파일하면 -128이 사라지기 때문입니다. 1의 보수를 사용하는 시스템에선 0이 +0, -0 2개를 갖기 때문에 -128 를 표현하지 못합니다.</li>
          <li>물론 그런 기계는 거의 없지만 혹시 모르니 그냥 -127까지만 쓰도록 합시다.</li>
          <li>추가로, 보수는 컴퓨터에서 뺄셈을 하기 위해서 사용되는 것입니다. 컴퓨터는 기본적으로 가산기만 사용합니다. <code class="highlighter-rouge">A + B</code>만 가능한 컴퓨터에서 <code class="highlighter-rouge">A - B</code>를 하기 위해선 <code class="highlighter-rouge">B</code>를 음수로 만들어 줘야 하는데 이때 사용되는게 보수입니다. <a href="https://ndb796.tistory.com/4">참고할 만한 포스팅</a>입니다.
            <ul>
              <li>제가 알고있는 뺄샘 방법은 B의 2의 보수(1의 보수 + 1)인 C를 A에 더하는 건데, 지금 POCU님이 말하는 +0, -0이 있는 옛날 시스템은 뭔지 잘 모르겠습니다.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>보통 많이 따르는 char 표현 범위</p>

    <ul>
      <li>크기 : 8bit</li>
      <li>부호 생략시 👉 signed</li>
      <li>범위 : unsigned 👉 0~255 / signed 👉 -128~127</li>
    </ul>
  </li>
</ul>

<h2 id="21-short-형">21. short 형</h2>

<hr />

<ul>
  <li>short 표준
    <ul>
      <li>최소 16 비트이고 char크기 이상인 정수형</li>
      <li>포팅 문제 없는 범위
        <ul>
          <li>unsigned short 👉 0 ~ 65,535</li>
          <li>signed short 👉 -32,767 ~ 32,767</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>int 보다 메모리를 적게 쓰고 싶을 때 사용</li>
  <li>하지만, 대부분 cpu가 int를 기준으로 삼기 때문에 cpu가 int와 short를 변환하는 과정에서 더 느려질 수 있음</li>
  <li>표준은 아니지만 보통 많이 따르는 short 범위
    <ul>
      <li>크기 : 16 bit</li>
      <li>unsigned short 👉 0 ~ 65,535</li>
      <li>signed short 👉 -32,76<strong>8</strong> ~ 32,767</li>
    </ul>
  </li>
</ul>

<h2 id="22-int-형-long-형">22. int 형, long 형</h2>

<hr />

<h3 id="int">int</h3>

<ul>
  <li>int 표준
    <ul>
      <li>최소 16비트이고 short 크기 이상인 정수형</li>
    </ul>
  </li>
  <li>다른 언어는 다 32비트던데…</li>
  <li><strong>int는 기본 정수입니다. CPU가 생각하는 크기의 정수.</strong> 👉👉👉 중요! 컴퓨터를 이해합시다.
    <ul>
      <li>CPU의 레지스터(산술 논리장치 ALU)에 정수 크기가 있는데 이 크기랑 맞으면 그대로 정수 넣어서 계산, 안맞으면 변환해줘야 합니다.</li>
      <li>이 데이터를 워드(word)라고 하고, 크기를 워드 크기라고 합니다.</li>
      <li>워트 크기 == 레지스터 크기</li>
      <li>CPU에 따라 달라집니다.
        <ul>
          <li>예전엔 16비트 CPU가 흔했습니다. C언어는 그때부터 있던 언어이기에 최소 16비트입니다.</li>
          <li>그 뒤로, 32비트 컴퓨터가 대중화되어  int의 크기는 32비트로 많이 굳어졌습니다.</li>
          <li>64비트 CPU가 대중화 됐지만 아직 32비트 컴파일러를 많이 사용합니다.</li>
          <li>근데 64비트 컴파일러를 사용해도 int는 32비트로 찍히는데, 호환성을 위해 32비트로 남겨두는 것입니다.</li>
          <li>그리고 int를 64비트 쓴다고 해도 프로그램이 빨라지는건 아닙니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>포팅에 안전한 범위  :short와 같음</li>
  <li>표준은 아니지만 보통 int
    <ul>
      <li>크기 : 32비트</li>
      <li>unsigned 👉 0 ~ 4,294,967,295</li>
      <li>signed 👉 -2,147,483,648 ~ 2,147,483,647</li>
    </ul>
  </li>
  <li>int 리터럴
    <ul>
      <li>‘u’, ‘U’를 써줘 unsigned 라고 명시해주는 접미사입니다.</li>
      <li>unsigned int num = 23445667; 👉 경고 나옴</li>
      <li>unsigned int num = 23445667u; 👉 경고 안나옴. 주로 소문자 u를 사용.</li>
    </ul>
  </li>
</ul>

<h3 id="long">long</h3>

<ul>
  <li>long 표준
    <ul>
      <li>최소 32비트이고 int 이상의 크기</li>
      <li>C에서 long은 보통 32비트 (다른 언어는 64비트)</li>
    </ul>
  </li>
  <li>
    <p>C에서 long은 int와 거의 같게 사용됩니다.(항상 그런건 아니고, 보통의 경우)</p>
  </li>
  <li>long 리터럴
    <ul>
      <li>long을 쓰고 싶으면 접미사 ‘l’, ‘L’을 붙입니다. (1과 l이 헷갈리기 때문에 L을 쓰라는 곳도 있습니다.)
        <ul>
          <li>long num = 123123123l;</li>
        </ul>
      </li>
      <li>unsigned long은 ‘ul’을 붙입니다.
        <ul>
          <li>unsigned long num = 123123; 👉 경고</li>
          <li>unsigned long num = 123123ul; 👉 경고 없음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="23-float-형-double-형-long-double-형">23. float 형, double 형, long double 형</h2>

<hr />

<h3 id="float">float</h3>

<ul>
  <li>보통 많은 언어에서 부동 소수점 자료형은 <strong>IEEE 754</strong>로 거의 통일 되었습니다.
    <ul>
      <li>float 👉 IEEE 754 Single (32비트)</li>
      <li>double 👉 IEEE 754 Double (64비트)</li>
    </ul>
  </li>
  <li>하지만! C는 IEEE 754 이전부터 쓰이던 언어입니다. 후…</li>
  <li>float 표준
    <ul>
      <li>IEEE 754가 아닐 수 있습니다. 컴파일러 재량</li>
      <li>크기는 char 이상</li>
      <li>unsigned 없음</li>
    </ul>
  </li>
  <li>표준은 아니지만 일반적인 float
    <ul>
      <li>크기 : 32비트</li>
      <li>범위 : IEEE 754 Single</li>
    </ul>
  </li>
  <li>float.h 헤더파일을 열면 float과 관려난 사항들을 확인 가능합니다.</li>
  <li>f 리터럴 ‘f’, ‘F’ 가능한데 거의 ‘f’만 씁니다.
    <ul>
      <li>float num = 3.3f;</li>
      <li>float num = 3.f;</li>
    </ul>
  </li>
</ul>

<h3 id="double">double</h3>

<ul>
  <li>double 표준
    <ul>
      <li>CPU가 계산에 사용하는 기본 데이터 크기</li>
      <li>크기는 float 이상(같을 수도 있음), 컴파일러 재량</li>
    </ul>
  </li>
  <li>double이 기본이기 때문에 리터럴 x</li>
  <li>unsigend  없음</li>
  <li>표준은 아니지만 보통의 double
    <ul>
      <li>크기 : 64비트</li>
      <li>범위 : IEEE 754 Double과 동일</li>
    </ul>
  </li>
  <li>double도 float.h 파일열면 나옵니다.</li>
</ul>

<h3 id="long-double">long double</h3>

<ul>
  <li>double보다 정밀도가 높습니다.</li>
  <li>double 이상의 크기</li>
  <li>unsigend  없음</li>
  <li>float.h 헤더 파일.</li>
  <li>다른 언어에선 보기 힘든 자료형입니다.</li>
</ul>

<h3 id="유의할-점">유의할 점</h3>

<ul>
  <li>데스크탑 환경에선 다른 언어들과 거의 비슷합니다.</li>
  <li>소형기기에선 해당 매뉴얼에서 자료형 크기를 확인해야 합니다.</li>
  <li>데스크탑, 소형기기 범용적으로 사용할 것이라면 포팅이 보장되는 범위 안에서 해야합니다.
    <ul>
      <li>float/double은 플랫폼에 따라 다른 값이 나올 수도 있으니 대비해야 합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="24-코드보기--기본-자료형">24. 코드보기 : 기본 자료형</h2>

<hr />

<ul>
  <li>POCU 아카데미 학생들에겐 코드를 한 줄 한 줄 보여주는 코드 슬라이드가 제공됩니다. 😥😥</li>
</ul>

<h2 id="25-c언어의-bool-형">25. C언어의 bool 형</h2>

<hr />

<ul>
  <li>
    <p>C89엔 boolean이 없습니다! (충격) C99에선 들어오긴 합니다만, 대부분 C 개발자들은 bool을 안씁니다.</p>
  </li>
  <li>
    <p>bool 대신 정수를 사용합니다. 0이면 false, 0이 아니면 true</p>
  </li>
  <li>
    <p>하드웨어에도 bool이란 없습니다. 정말 안 믿어진다면 어셈블리어를 까보면 됩니다.</p>

    <ul>
      <li>C는 중간에 어셈블리어로 컴파일됩니다.</li>
      <li>어셈블리 명령어 cmp(compare) a b , je(jump equal) ~~은 사실 sub a b, jz(jumb if zero)와 같습니다.</li>
      <li>0 대입하는 것보다 xor 연산으로 0만드는 게 빠릅니다.</li>
      <li>어셈블리에서 eax는 리턴 값을 저장하는 레지스터입니다.</li>
    </ul>
  </li>
  <li>
    <p>bool을 숫자로 쓰기 때문에 while문에 숫자를 넣을 수도 있습니다. (좋은 코딩은 아닙니다.)</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int count = 5;
while (count--)
{
	printf('%d', count);
}
</code></pre></div>    </div>
  </li>
  <li>
    <p>C에선 보통 거짓일 땐 0을 반환, 참일 땐 1을 반환합니다.</p>

    <ul>
      <li>그런데 참일 때 1이 아닌 다른 수를 반환 하는 경우도 있습니다. 그래서 어떤 반환값이 참이냐, 거짓이냐를 할땐 (  ) != 0을 쓰면 참에 1 아닌 다른 수를 쓸 때를 거를 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="26-열거형enum">26. 열거형(enum)</h2>

<hr />

<ul>
  <li>
    <p>C의 열거형은 다른 언어들의 enum과는 좀 다릅니다.</p>

    <ul>
      <li>int와 섞어 사용 가능합니다.</li>
      <li>int -&gt; enum, enum-&gt;int, enum-&gt;다른 enum 이 가능합니다</li>
    </ul>
  </li>
  <li>
    <p>C에서 enum은 정수에 별명 붙이는 정도입니다.</p>
  </li>
  <li>
    <p>C#의 경우입니다.</p>

    <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">EDay</span> <span class="p">{</span> <span class="n">MON</span><span class="p">,</span> <span class="n">TUE</span><span class="p">,</span> <span class="n">WED</span> <span class="p">};</span>
<span class="k">enum</span> <span class="n">EMonth</span> <span class="p">{</span> <span class="n">JAN</span><span class="p">,</span> <span class="n">FEB</span><span class="p">,</span> <span class="n">MAR</span> <span class="p">};</span>
  
<span class="n">EDay</span> <span class="n">day</span> <span class="p">=</span> <span class="n">EDay</span><span class="p">.</span><span class="n">TUE</span><span class="p">;</span>
<span class="n">EMonth</span> <span class="n">month</span> <span class="p">=</span> <span class="n">day</span><span class="p">;</span> <span class="c1">// -&gt; 컴파일 에러. enum도 타입을 가지고 있음.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>C의 경우입니다. 사용 방법도 조금 다릅니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">day</span> <span class="p">{</span> <span class="n">DAY_MON</span><span class="p">,</span> <span class="n">DAY_TUE</span><span class="p">,</span> <span class="n">DAY_WED</span> <span class="p">};</span>
<span class="k">enum</span> <span class="n">month</span> <span class="p">{</span> <span class="n">MONTH_JAN</span><span class="p">,</span> <span class="n">MONTH_FEB</span><span class="p">,</span> <span class="n">MONTH_MAR</span> <span class="p">};</span>
  
<span class="k">enum</span> <span class="n">day</span> <span class="n">day</span> <span class="o">=</span> <span class="n">TUE</span><span class="p">;</span>
<span class="k">enum</span> <span class="n">month</span> <span class="n">month</span> <span class="o">=</span> <span class="n">day</span><span class="p">;</span> <span class="cm">/* 정상 작동. enum은 단지 정수의 별명 정도 */</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>C에서 enum은 실수의 여지가 크기 때문에 POCU 아카데미에선 enum을 사용할 때의 코딩 표준을 정해 놓았습니다.</p>
  </li>
</ul>

<h2 id="27-코드보기--열거형">27. 코드보기 : 열거형</h2>

<hr />

<ul>
  <li>POCU 아카데미 학생들은 좋겠습니다. 스마트한 슬라이드도 있고.</li>
</ul>

<h2 id="28-변수-선언">28. 변수 선언</h2>

<hr />

<ul>
  <li>변수 선언은 블럭의 시작 부분에서 해야 합니다. 중간에 선언하면 컴파일 에러 납니다. 😲😲😲
    <ul>
      <li>미리 메모리를 확보하기 위해 그런 것 같습니다.(선생님 뇌피셜)</li>
      <li>어메이징한 고대 언어라는 생각이 듭니다.</li>
    </ul>
  </li>
</ul>

<h2 id="29-연산자">29. 연산자</h2>

<hr />

<ul>
  <li>
    <p>연산자 우선순위, 연산자 결합 법칙을 잘 알아 둡시다.</p>

    <ul>
      <li>
        <p>결합법칙은 동일한 우선순위 연산자들을 어떤 순서로 처리 할 것인지를 말합니다.</p>

        <table>
          <thead>
            <tr>
              <th>우선순위</th>
              <th>연산자</th>
              <th>설명</th>
              <th>결합법칙</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1</td>
              <td>++ –<br />()<br />[]<br />.<br />-&gt;</td>
              <td>후위 증감 연산자<br />함수 호출<br />배열 첨자<br />구조차, 공용체 멤버 접근자<br />구조체, 공용체 멤버 접근자(포인터)</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>2</td>
              <td>++ –<br />+ -<br />! ~<br />(자료형)<br />*<br />&amp;<br />sizeof</td>
              <td>전위 증감 연산자<br />단항(unary) 연산자<br />논리/비트 부정 연산자<br />자료형 캐스팅<br />역 참조(간접참조)<br />주소(address-of)<br />크기 알려주는 연산자</td>
              <td>👈</td>
            </tr>
            <tr>
              <td>3</td>
              <td>* / %</td>
              <td>곱, 나누기(몫), 나누기(나머지)</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>4</td>
              <td>+ -</td>
              <td>덧셈, 뺄셈</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>5</td>
              <td>« »</td>
              <td>비트 쉬프트</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>6</td>
              <td>&lt; &lt;= &gt; &gt;=</td>
              <td>비교 연산자</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>7</td>
              <td>== !=</td>
              <td>비교 연산자</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>8</td>
              <td>&amp;</td>
              <td>비트 AND</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>9</td>
              <td>^</td>
              <td>비트 XOR</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>10</td>
              <td>|</td>
              <td>비트 OR</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>11</td>
              <td>&amp;&amp;</td>
              <td>논리 AND</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>12</td>
              <td>||</td>
              <td>논리 OR</td>
              <td>👉</td>
            </tr>
            <tr>
              <td>13</td>
              <td>? :</td>
              <td>삼항(tenary) 연산자</td>
              <td>👈</td>
            </tr>
            <tr>
              <td>14</td>
              <td>=<br />+= -=<br />*= /= %=<br />«= »=<br />&amp;= ^= |=</td>
              <td>대입 연산자<br />덧셈/뺄셈 후 대입<br />곱/나눗셈 후 대입<br />비트 쉬프트 후 대입<br />비트 연산 후 대입</td>
              <td>👈</td>
            </tr>
            <tr>
              <td>15</td>
              <td>,</td>
              <td>콤마</td>
              <td>👉</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <p>뒤에서 볼건데 우선순위와 평가(함수 호출) 순서는 다릅니다.</p>
    <ul>
      <li>f( ) + g( )*h( ) 일때, g( )를 호출하고, h( )를 호출하고, 곱한다음에, f( )를 호출해 더한다고 단언할 수없다는 겁니다.</li>
      <li>어떤 순서로 함수들을 부를 지는 뒤에서 알아봅니다.</li>
    </ul>
  </li>
</ul>

<h2 id="30-sizeof-연산자">30. sizeof 연산자</h2>

<hr />

<ul>
  <li>
    <p>피 연산자의 크기를 바이트(엄밀히 말하면 char의 크기)로 반환해줍니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char ch = 'a';
int num = 100;
char char_arr(30);
  
size_t size_char = sizeof(ch);     /* 1 */
size_t size_int = sizeof(int);     /* 4 */
size_t size_float = sizeof(float); /* 4 */
size_t size_char = sizeof(ch);     /* 30 */
</code></pre></div>    </div>
  </li>
  <li>
    <p>함수가 아니라 연산자인걸 유의해야 합니다.</p>

    <ul>
      <li>컴파일 중에 sizeof를 실행해 값을 알아냅니다.</li>
      <li>즉, 컴파일 할 때 크기를 모르는 값은 sizeof를 할 수 없습니다.</li>
    </ul>
  </li>
  <li>
    <p>정의상 char타입을 넣으면 1이 반환됩니다.</p>

    <ul>
      <li>C에서 1바이트는 char의 크기입니다. (보통 8비트)</li>
    </ul>
  </li>
  <li>
    <p>반환 값은 unsigned 정수인 size_t 타입을 반환합니다.</p>
  </li>
</ul>

<h2 id="31size_t">31.size_t</h2>

<hr />

<ul>
  <li>
    <p>부호 없는 정수형이지만, 실제 데이터 타입은 아닙니다.</p>
  </li>
  <li>
    <p>C에서 _t 나온 얘들은 typedef 를 했다는 뜻입니다.</p>

    <ul>
      <li>typedef는 자료형에 별칭을 붙였다는 뜻입니다.</li>
    </ul>
  </li>
  <li>
    <p>C89 표준에선 size_t의 크기를 명시하지 않습니다.</p>

    <ul>
      <li>C99에선 최소 16비트입니다.</li>
      <li>보통은 unsigned int입니다.</li>
    </ul>
  </li>
  <li>
    <p>크기를 나타내야 할 때 사용됩니다.</p>
  </li>
  <li>
    <p>반복문, 배열에 인덱스로 종종 사용됩니다. (음수가 필요 없을 때)</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">int_arr</span><span class="p">[</span><span class="mi">30</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">30</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">int_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>size_t와 -1 부분, 뒤로 다시 듣기</p>
  </li>
  <li>
    <p>다른 언어 string에 있는 IndexOf() 함수를 C에선 size_t를 가지고 할 수 있습니다.</p>

    <ul>
      <li>IndexOf() 는 입력 문자를 못찾으면 -1을 반환 합니다. 근데, size_t는 unsigned인데 -1을 어떻게 표현할까요?</li>
      <li>-1과 4,294,967,295 의 비트배턴이 같다는 걸 이용합니다. 원하는 인덱스를 찾지 못하면 size_t의 최댓값을 돌려주는 식입니다.</li>
      <li>그럼 실제로 찾는 인덱스가 4,294,967,295 면 어떻게 하죠?
        <ul>
          <li>어차피 signed int를 써도 4,294,967,295는 표현 못합니다. 저런 상황이라면 signed int여도 다른 방법을 생각해야 합니다. 기우입니다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>C엔 Exception, Try-Catch 없습니다.</p>
  </li>
</ul>

<h2 id="32-역-참조-연산자">32. 역 참조 연산자</h2>

<hr />

<h3 id="역-참조-연산자-">역 참조 연산자 *</h3>

<ul>
  <li>
    <p>이 부분은 포인터를 배워야 제대로 이해할 수 있어서 간단하게 하고 넘어갑니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int num = 10; 
int* p = &amp;num; /* 여긴 역 참조 연산자가 아니라 포인터 변수 선언 */
int num1 = *p; /* 여기가 역 참조 연산자 */
  
int result = num1*num2 /* 여긴 곱셈 */
</code></pre></div>    </div>
  </li>
  <li>
    <p>역 참조 연산자는 포인터형 변수에 사용가능합니다.</p>
  </li>
  <li>
    <p>메모리를 다룰 때 사용합니다.</p>
  </li>
  <li>
    <p>포인터가 성능을 다루는 핵심입니다. 포인터 배울 땐 마음을 굳게 먹으시고..</p>
  </li>
</ul>

<h3 id="주소-연산자-">주소 연산자 &amp;</h3>

<ul>
  <li>어떤 변수의 메모리 주소를 반환합니다.</li>
  <li>주소는 포인터 변수에 담아둡니다.</li>
</ul>

<h2 id="33-구조체공용체-멤버-접근자">33. 구조체/공용체 멤버 접근자</h2>

<hr />

<h3 id="-연산자">. 연산자</h3>

<ul>
  <li>.은 거의 모든 언어에서 볼 수 있던 연산자입니다. “클래스.메소드” 이런식으로 사용했습니다. 근데 앞서 말했듯이 C에는 클래스가 없습니다. 즉, C에선 함수 호출에쓰지 않습니다.
    <ul>
      <li>구조체(데이터만 가지고 있는 것) -&gt; 클래스(데이터, 함수 가지고 있는 것)</li>
      <li>C엔 구조체는 있습니다. 그리고 나중에 배우겠지만 공용체라는 것도 있습니다.</li>
      <li>C의 . 연산자는 구조체와 공용체의 멤버 변수에 접근할 때 사용됩니다.</li>
    </ul>
  </li>
</ul>

<h3 id="--연산자">-&gt; 연산자</h3>

<ul>
  <li>’.’ 와 ‘*’ 를 합친 것입니다.</li>
  <li>역시 구조체, 공용체의 멤버 변수에 접근할 때 사용합니다.</li>
  <li>포인터, 구조체 배울 때 알아보겠습니다.</li>
</ul>

<h2 id="34-비교-연산자-논리-연산자-조건-연산자">34. 비교 연산자, 논리 연산자, 조건 연산자</h2>

<hr />

<ul>
  <li>다른 언어와 같습니다. 패스!</li>
</ul>

<h2 id="35-조건문과-반복문-if-문-switchcase-문">35. 조건문과 반복문, if 문, switch/case 문</h2>

<hr />

<h3 id="if-문">if 문</h3>

<ul>
  <li>C에는 bool이 없습니다. 비교, 조건 연산자를 사용한 결과는 참일 경우 1, 거짓일 경우 0을 반환합니다.</li>
  <li>패스!</li>
</ul>

<h3 id="switchcase">switch/case</h3>

<ul>
  <li>
    <p>C switch-case에서 비교할 수 있는 건 정수형(int, char, enum) 밖에 없습니다.</p>
  </li>
  <li>
    <p>C에서 break안 쓰면 다음 case까지 실행시킵니다.(fall-through 방식) 자바랑은 같고, C#이랑은 다릅니다. (C#은 case에 break 없으면 컴파일 에러)</p>

    <ul>
      <li>
        <p>break 없이 fall-through를 의도했을 땐  intentional fallthrough를 주석으로 표시해줍시다.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">fruit</span> <span class="p">{</span> <span class="n">FRUIT_APPLE</span><span class="p">,</span> <span class="n">FRUIT_BANANA</span> <span class="p">};</span>
<span class="k">enum</span> <span class="n">fruit</span> <span class="n">fruit</span> <span class="o">=</span> <span class="n">FRUIT_APPLE</span><span class="p">;</span>
    
<span class="k">switch</span> <span class="p">(</span><span class="n">fruit</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">case</span> <span class="n">FRUIT_APPLE</span><span class="p">:</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"apple"</span><span class="p">);</span>
	<span class="cm">/* intentional fallthrough */</span>
<span class="k">case</span> <span class="n">FRUIT_BANANA</span><span class="p">:</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"banana"</span><span class="p">);</span>
	<span class="k">break</span><span class="p">;</span>
<span class="nl">default:</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"fruit"</span><span class="p">);</span>
	<span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>case 안의 값은 컴파일 할 때 결정될 수 있는 상수만 넣습니다!</p>

    <ul>
      <li>어차피 상수 아니면 컴파일 에러 납니다.</li>
    </ul>
  </li>
</ul>

<h2 id="36-코드보기--switchcase">36. 코드보기 : switch/case</h2>

<hr />

<ul>
  <li>POCU 학생들은 좋겠습니다.</li>
</ul>

<h2 id="37-for-문-while-문-do-while-문">37. for 문, while 문, do while 문</h2>

<hr />

<h3 id="for-문">for 문</h3>

<ul>
  <li>
    <p>C에선 foreach 없습니다.</p>
  </li>
  <li>
    <p>다른 언어들 처럼 for문 안에서 변수 선언하면 안됩니다. (컴파일 에러남)</p>

    <ul>
      <li>앞에서 봤듯이, 변수 선언을 맨 위에서 해 주어야 합니다.</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="cm">/* 컴파일 에러 */</span>
	<span class="n">sum</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="while-do-while-문">while, do while 문</h3>

<ul>
  <li>특이 사항 없습니다.</li>
  <li>continue는 해당 회차를 종료하고 다음 회차를 바로 시작합니다. (잘 안써서 초면인줄..)</li>
</ul>

<h3 id="유의사항">유의사항</h3>

<ul>
  <li>C에선 bool이 없기 때문에 for, while 조건 안에 변수 하나만 넣는 경우가 있는데<code class="highlighter-rouge">for (num--)</code>, 틀린 방법은 아니지만 POCU에선 추천하지 않습니다. <code class="highlighter-rouge">==</code>나 <code class="highlighter-rouge">!=</code>를 명시해줍시다.</li>
</ul>

<h2 id="38-코드보기--조건문반복문">38. 코드보기 : 조건문/반복문</h2>

<hr />

<ul>
  <li>패스</li>
</ul>


</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
