<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      웹 호스팅 &middot; 이기승의 개발일지
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <!-- Profile -->
  <div class="sidebar-item">
    <p>A reserved <a href="http://jekyllrb.com" target="_blank">Jekyll</a> theme that places the utmost gravity on content with a hidden drawer. Made by <a href="https://twitter.com/mdo" target="_blank">@mdo</a>.</p>
  </div>
  <!-- Profile End -->

  <nav class="sidebar-nav">
    <!-- Home -->
    <a class="sidebar-nav-item" href="/">Home</a>
    <!-- Home End -->
    <!-- Posts -->
    
    
      
        <!-- 1 depth post -->
        <a class="sidebar-nav-item" href="http://localhost:4000/posts/about">about</a>
      
    
      
        <input id="projects" class="toggle" type="checkbox">
        <label for="projects" class="lbl-toggle sidebar-nav-item" tabindex="0">projects</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/projects/twitch_chat_anaylsis">twitch_chat_anaylsis</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/projects/sagyo_reboot">sagyo_reboot</a>
          
        
        </div>
      
    
      
        <input id="study_book" class="toggle" type="checkbox">
        <label for="study_book" class="lbl-toggle sidebar-nav-item" tabindex="0">study_book</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/study_book/http_the_definitive_guide">http_the_definitive_guide</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/study_book/algorithm">algorithm</a>
          
        
        </div>
      
    
      
        <input id="study_googling" class="toggle" type="checkbox">
        <label for="study_googling" class="lbl-toggle sidebar-nav-item" tabindex="0">study_googling</label>
        <div class="collapsible-content subcategories">
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/study_googling/etc">etc</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/study_googling/java">java</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/study_googling/jekyll">jekyll</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/study_googling/linux">linux</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/study_googling/network">network</a>
          
        
          
            <!-- 2 depth post -->
            <a class="sidebar-nav-item" href="http://localhost:4000/posts/study_googling/python">python</a>
          
        
        </div>
      
    
    <!-- Posts End -->
  </nav>

  <!-- sidebar bottom -->
  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
  <!-- sidebar bottom end -->
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">이기승의 개발일지</a>
            <small>문서화에 맛들리는 중...</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">웹 호스팅</h1>
  <span class="post-date">30 Mar 2020</span>
  
<h3 id="들어가며">들어가며</h3>

<hr />

<ul>
  <li>웹 호스팅이란 콘텐츠 리소스를 저장, 중개, 관리하는 일을 통틀어 이르는 말입니다.</li>
  <li>웹 리소스를 직접 호스팅 할 수도 있지만 호스팅에 필요한 하드웨어, 소프트웨어를 관리해주는 호스팅 업체를 이용할 수도 있습니다.</li>
  <li>이번 장에선 웹 호스팅 서비스와 관련한 사항들을 알아보겠습니다.</li>
</ul>

<h3 id="181-호스팅-서비스">18.1. 호스팅 서비스</h3>

<hr />

<ul>
  <li>웹의 초기엔 대부분 각 회사가 직접 하드웨어와 소프트웨어를 구비해 자체 웹 서버를 구축했습니다.</li>
  <li>하지만 웹이 발전하며 이를 대신해주는 웹 호스팅 업체들이 등장했습니다.</li>
</ul>

<h4 id="1811-간단한-예--전용-호스팅">18.1.1. 간단한 예 : 전용 호스팅</h4>

<ul>
  <li>전용 호스팅이란 말 그대로 한 호스팅 의뢰자에게 하나의 서버를 전용으로 배정해주는 것입니다.</li>
  <li>호스팅업체 A에 호스팅 의뢰인 A, B가 호스팅을 맡겼다면, 의뢰인 A와 B에게 각각 서버와 IP가 할당됩니다.</li>
  <li>의뢰인 A의 도메인은 의뢰인 A의 IP로 연결이 되고 의뢰인 B의 도메인은 의뢰인 B의 IP로 연결이 됩니다.</li>
  <li>웹이 점점 커지며 이런 전용 호스팅 방식은 단점을 많이 보였습니다.
    <ul>
      <li>우선 의뢰인들에게 각각 하드웨어와 서버를 배정하니 비용이 높습니다.</li>
      <li>그리고 각 웹 사이트들은 항상 운용되는게 아니기 때문에 의뢰인들의 서버들은 놀고 있는 시간이 많이 생깁니다.</li>
    </ul>
  </li>
  <li>이를 해결하기 위해 하나의 서버에 여러 사이트를 제공하는 가상 호스팅이 등장합니다.</li>
</ul>

<h3 id="182-가상-호스팅">18.2. 가상 호스팅</h3>

<hr />

<ul>
  <li>가상 호스팅은 하나의 서버에서 여러 사이트를 호스팅 하는 것입니다.
    <ul>
      <li>쉽게 말해, 다른 도메인을 가지고 있는 두 사이트가 실제로 같은 IP를 갖고 있는 것입니다.</li>
    </ul>
  </li>
  <li>가상 호스팅된 여러 웹 사이트들은 각각 다른 서버에서 호스팅 되는 것 처럼 보이지만 사실 물리적으로 같은 서버에서 호스팅 되고 있습니다.</li>
  <li>클라이언트의 입장에선 이용중인 사이트가 가상 호스팅된 사이트인지 느낄 수 없습니다.</li>
  <li>가상 호스팅은 업체들은 한 서버에 수백, 수천개의 웹 사이트를 호스팅 합니다.
    <ul>
      <li>실제 한 PC에 수천대를 호스팅하는건 아니고 서버 팜을 만들어 각 서버에 부하를 분산시킵니다.(20장에서 자세히 알아봅니다.)</li>
    </ul>
  </li>
</ul>

<h4 id="1821-호스트-정보가-없는-가상-서버-요청">18.2.1. 호스트 정보가 없는 가상 서버 요청</h4>

<ul>
  <li>이런 가상 호스팅은 HTTP/1.0 환경에선 문제가 많았습니다.</li>
  <li>본 책의 초반부분에서 설명했듯이 HTTP/1.0은 URL의 호스트명을 보내지 않고 경로 컴포넌트만 전송합니다.
    <ul>
      <li>http://www.joes-hardware.com/index.html 을 HTTP/1.0으로 전송하면 브라우저는 www.joes-hardware.com과 커넥션을 맺지만 실제로 가는 요청은 “GET /index.html”이 전부입니다.</li>
    </ul>
  </li>
  <li>이와 같은 상황에서 만약 한 호스팅 업체에 www.joes-hardware.com과 www.marys-antiques.com이 호스팅 되어 있다고 가정합시다.</li>
  <li>클라이언트가 http://www.joes-hardware.com/index.html 를 브라우저에 입력해 브라우저가  www.joes-hardware.com에 커넥션을 맺고 “GET /index.html”을 보냈지만 호스팅하고 있는 서버의 입장에선 /index.html이  www.joes-hardware.com의 것인지, www.marys-antiques.com의 것인지 판별할 수 없습니다.</li>
  <li>위와 같은 상황이 발생한건 HTTP의 설계자들이 가상 호스팅이 일어날 것이라고 생각하지 못했기 때문입니다.</li>
</ul>

<h4 id="1822-가상-호스팅-동작하게-하기">18.2.2. 가상 호스팅 동작하게 하기</h4>

<ul>
  <li>위 상황을 해결하기 위해 차선책과 새로운 컨벤션을 개발해야 했습니다.</li>
  <li>이 문제를 간단히 해결하기 위해선 HTTP 요청에 경로 컴포넌트만이 아니라 완전한 URL을 보내도록 하면 됩니다.
    <ul>
      <li>따라서 HTTP/1.1을 지원하는 서버는 완전한 URL을 처리할 수 있어야 합니다.</li>
    </ul>
  </li>
  <li>하지만 이런 새로운 HTTP명세를 따르지 않는 기존의 어플리케이션들을 위해 아래 네 가지 방법 차선책들이 고안됐습니다.
    <ul>
      <li><strong>URL 경로를 통한 가상 호스팅</strong>
        <ul>
          <li>이 방법은 어떤 사이트를 요청하는것인지 알수 있게 URL에 특별한 경로 컴포넌트를 추가하는 것입니다.</li>
          <li>예를들어, http://www.joes-hardware.com/index.html 를 http://www.joes-hardware.com/<strong>joe</strong>/index.html로,  http://www.marys-antiques.com/index.html 를 http://www.marys-antiques.com/<strong>mary</strong>/index.html로 바꾸는 것입니다.</li>
          <li>하지만 이 방법은 우리가 생각하는 일반적인 URL과 맞지 않는 좋지 않은 방법입니다. 거의 사용되지 않습니다.</li>
        </ul>
      </li>
      <li><strong>포트 번호를 통한 가상 호스팅</strong>
        <ul>
          <li>호스팅 하고 있는 각 웹 사이트에 다른 포트 번호를 할당하면 해당 문제를 해결할 수 있습니다.</li>
          <li>하지만, 그렇다면 사용자가 항상 URL에 포트번호를 표기해야 하기 때문에 이 역시 잘 사용되지 않습니다.</li>
        </ul>
      </li>
      <li><strong>IP 주소를 통한 가상 호스팅</strong>
        <ul>
          <li>가장 많이 사용되는 방법은 각 사이트에 가상 IP를 할당하는 것입니다.</li>
          <li>www.joes-hardware.com와 www.marys-antiques.com가 실제로 가리키는 IP를 구분하는 것입니다.</li>
          <li>각 가상 IP들은 사이트들을 호스팅하고 있는 실제 서버로 연결됩니다.</li>
          <li>이렇게 가상 IP를 사용하는 방법은 규모가 커지면 다음과 같은 문제가 발생할 수 있습니다.
            <ul>
              <li>한 장비에 연결할 수 있는 IP갯수엔 제한이 있습니다.</li>
              <li>한 장비를 떠나 IP주소는 희소 상품이기 때문에 가상 IP주소를 충분히 확보하지 못할 수 있습니다.</li>
              <li>서버를 복제할 시엔 각 복제된 서버에 새로운 IP 주소를 부여해야하기 때문에 일이 더 커집니다.</li>
            </ul>
          </li>
          <li>이런 문제들이 있지만 가장 많이 사용되는 방법입니다.</li>
        </ul>
      </li>
      <li><strong>Host 헤더를 통한 가상 호스팅</strong>
        <ul>
          <li>같은 IP주소를 사용하더라도 각 사이트들을 구분할 수 있는 정보를 전달할 수 있다면 가상 호스팅을 사용할 수 있습니다.</li>
          <li>이를 위해 HTTP를 확장해 HTTP/1.0+ 에서 Host 헤더가 도입되었습니다.</li>
          <li>또한 HTTP/1.1을 따르는 애플리케이션이라면 Host헤더를 반드시 기술해야 합니다.</li>
          <li>Host 헤더는 말 그대로 호스트 명을 기술합니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="1823-http11-host-헤더">18.2.3. HTTP/1.1 Host 헤더</h4>

<ul>
  <li>
    <p>현대의 웹에선 가상 호스팅이 매우 흔하기 때문에 모든 HTTP 클라이언트는 Host 헤더를 구현해야 합니다.</p>

    <p><strong>문법과 사용 방법</strong></p>

    <ul>
      <li>
        <p>Host 헤더엔 호스트와 포트번호를 기술합니다.</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host : www.joes-hardware.com
Host : www.joes-hardware.com:80
</code></pre></div>        </div>
      </li>
      <li>
        <p>Host헤더에 포트 번호가 없으명 해당 스킴의 기본 포트를 사용합니다.(http의 경우 80, https의 경우 443)</p>
      </li>
      <li>
        <p>URL에 IP주소가 있으면 Host 헤더엔 해당 IP주소를 포함해야 합니다.</p>
      </li>
      <li>
        <p>URL에 호스트명이 있으면 Host 헤더엔 해당 호스트명을 포함해야 합니다.</p>
      </li>
      <li>
        <p>URL에 호스트명이 있다면, Host 헤더에 해당 호스트명에 할당된 IP주소가 있으면 <strong>안됩니다.</strong>가상 호스팅의 경우 한 IP가 여러 호스트명을 호스팅하고 있을 수 있기 때문입니다.</p>
      </li>
      <li>
        <p>클라이언트가 프록시 서버를 사용한다면, Host 헤더엔 프록시 서버가 아닌 원 목적지 서버의 호스트명과 포트번호를 기술해야 합니다.</p>
      </li>
      <li>
        <p>클라이언트는 모든 요청에 Host 헤더를 기술해야 합니다.</p>
      </li>
      <li>
        <p>웹 프록시는 요청을 서버에 전달하기 전에 받았던 Host 헤더를 추가해야 합니다.</p>
      </li>
      <li>
        <p>HTTP/1.1 웹 서버는 Host 명이 없는 요청 메세지를 받으면 400 상태코드로 응답해야 합니다.</p>
      </li>
    </ul>

    <p><strong>Host 헤더의 누락</strong></p>

    <ul>
      <li>만약 브라우저가 Host 헤더를 보내지 않는다면 서버는 기본 웹 페이지로 보내거나 브라우저를 업그레이드 하라는 에러 페이지를 반환합니다.</li>
      <li>이 포스팅이 쓰여지는 현재엔 거의 모든 브라우저가 Host 헤더를 전송합니다.</li>
    </ul>

    <p><strong>Host 헤더 해석하기</strong></p>

    <ul>
      <li>가상호스팅을 하지 않는 서버는 Host 헤더를 무시하면 되지만, 가상 호스팅을 하는 서버는 아래와 같은 과정을 거칩니다.
        <ul>
          <li>요청 URL이 완전한 URL이라면 Host 헤더 값은 무시하고 URL에 있는 호스트명을 사용합니다.</li>
          <li>요청 URL에 호스트명이 없고 Host 헤더가 있다면 Host 헤더를 사용합니다.</li>
          <li>요청 URL에 호스트명이 없고 Host 헤더도 없다면 400 Bad Request 응답을 반환합니다.</li>
        </ul>
      </li>
    </ul>

    <p><strong>Host 헤더와 프록시</strong></p>

    <ul>
      <li>정말 오래됐거나 잘못 만들어진 웹 클라이언트는 가끔 프록시의 주소를 Host 헤더에 담기도 하니 주의해야 합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="183-안정적인-웹-사이트-만들기">18.3. 안정적인 웹 사이트 만들기</h3>

<hr />

<ul>
  <li>서버는 다운 될 수도 있고 느려질 수도 있으며 서버를 구성하는 네트워크에 장애가 올 수도 있습니다.</li>
  <li>이번 절에선 이에 대응하는 방법들을 알아보겠습니다.</li>
</ul>

<h4 id="1831-미러링-된-서버-팜">18.3.1. 미러링 된 서버 팜</h4>

<ul>
  <li>서버 팜(서버 클러스터)은 서로를 대신할 수 있는 웹 서버들의 집합입니다.</li>
  <li>서버 팜에 있는 콘텐츠들은 한 서버에서 문제가 생기면 다른 서버에서 대신 전달할수 있도록 미러링 할 수 있습니다.</li>
  <li>원본 콘텐츠를 가지고 있는 서버를 master origin server 라고 부릅니다.</li>
  <li>master origin server로 부터 콘텐츠를 받은 미러링된 서버를 replica origin server라고 부릅니다.</li>
  <li>서버 팜을 이용한다면 다음 그림과 같은 구조를 띄게 됩니다.</li>
</ul>

<p><img src="/public/image/http_the_definitive_guide/server_farm.png" alt="server_farm.png" /></p>

<ul>
  <li>복제 서버는 스위치를 통해 마스터 서버로 부터 콘텐츠를 미러링 합니다.</li>
  <li>클라이언트가 컨텐츠를 요청할때 가리키는 IP는 스위치의 IP 주소입니다.</li>
  <li>클라이언트의 요청이 서버 팜 안의 여러 서버 중 하나로 가는 방법은 아래와 같습니다.
    <ul>
      <li>HTTP 리다이렉션 : 요청이 마스터 서버로 간뒤 마스터 서버에서 적절한 곳의 복제 서버로 리다이렉트 시킵니다.</li>
      <li>DNS 리다이렉션 : URL이 4개의 IP주소를 가리킬 수 있고 DNS 서버가 그 중 적절한 IP를 선택해줍니다.</li>
    </ul>
  </li>
  <li>더 자세한 내용은 20 장에서 이어집니다.</li>
</ul>

<p><img src="/public/image/http_the_definitive_guide/mirror.png" alt="mirror.png" /></p>

<ul>
  <li>이클립스를 다운받을때 가능한 mirror입니다. 가장 가까운 곳을 선택하면 (보통) 더 빠르게 다운 받을 수 있습니다.</li>
</ul>

<h4 id="1832-콘텐츠-분산-네트워크">18.3.2. 콘텐츠 분산 네트워크</h4>

<ul>
  <li>콘텐츠 분산 네트워크(CDN)은 콘텐츠의 분산을 목적으로 하는 네트워크 입니다.</li>
</ul>

<h4 id="1833-cdn의-대리-캐시">18.3.3. CDN의 대리 캐시</h4>

<ul>
  <li>대리 캐시는 위에서 살펴본 replica origin server를 대신해 사용될 수 있습니다.</li>
  <li>대리 캐시는 리버스 프록시라고도 불립니다.</li>
  <li>대리 캐시와 미러링 된 서버의 차이는 콘텐츠 전체를 가지고 있느냐 입니다. 대리 캐시는 콘텐츠 전체를 가지고 있진 않습니다. 수요에 따라 가지고 있을 컨텐츠를 선택합니다.</li>
</ul>

<h4 id="1834-cdn의-프록시-캐시">18.3.4. CDN의 프록시 캐시</h4>

<ul>
  <li>추후 보강</li>
</ul>

<h3 id="184-웹-사이트-빠르게-만들기">18.4. 웹 사이트 빠르게 만들기</h3>

<hr />

<ul>
  <li>이번 장에서 살펴본 내용들은 모두 웹 사이트를 빠르게 만들기 위한 방법들입니다.</li>
  <li>서버 팜이나 프록시 캐시, 대리 서버를 사용해 서버의 부하를 낮춰줍니다.</li>
  <li>콘텐츠를 분산 시켜 콘텐츠를 요청한 사용자에게 더 가까운 곳에서 콘텐츠를 제공해줍니다.</li>
  <li>앞서 살펴본 방법들 말고도 웹 사이트를 빠르게 하기 위해 콘텐츠를 인코딩 할 수도 있습니다.
    <ul>
      <li>클라이언트가 디코딩 할 수 있다는 가정하에, 콘텐츠를 인코딩해 전송할 용량 자체를 줄일 수도 있습니다.</li>
    </ul>
  </li>
</ul>

<h3 id="마치며">마치며</h3>

<hr />

<ul>
  <li>미러링과 CDN 부분은 아직 이해가 좀 부족한 것 같습니다. 조금 더 검토해봐야 할 것 같습니다.</li>
</ul>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/posts/study_book/http_the_definitive_guide/Http%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C20/">
            리다이렉션과 부하 균형
            <small>01 Apr 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/study_googling/linux/GtkWarning/">
            우분투(리눅스) GtkWarning
            <small>31 Mar 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/posts/study_googling/jekyll/%EC%9C%88%EB%8F%84%EC%9A%B0-%EC%9A%B0%EB%B6%84%ED%88%AC-%EA%B6%8C%ED%95%9C%EA%B3%B5%EC%9C%A0/">
            Samba를 이용한 윈도우 우분투 권한 공유
            <small>31 Mar 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
