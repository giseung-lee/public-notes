<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      웹 캐시 &middot; 이기승의 techlog!
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
<link rel="stylesheet" href="/public/css/ntz4kiseung.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A reserved <a href="http://jekyllrb.com" target="_blank">Jekyll</a> theme that places the utmost gravity on content with a hidden drawer. Made by <a href="https://twitter.com/mdo" target="_blank">@mdo</a>.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    
    
    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about/">About</a>
        
      
    
      
        
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
<a class="sidebar-nav-item category-closed" href="#">projects</a>
<div class="subcategories">
<a class="sidebar-nav-item" href="#">sagyo</a>
<a class="sidebar-nav-item" href="#">tca</a>
</div>
<a class="sidebar-nav-item category-closed" href="#">study-book</a>
<div class="subcategories">
<a class="sidebar-nav-item" href="#">algorithm</a>
<a class="sidebar-nav-item" href="#">http완벽가이드</a>
</div>
<a class="sidebar-nav-item category-closed" href="#">study-googling</a>
<div class="subcategories">
<a class="sidebar-nav-item" href="#">Java</a>
<a class="sidebar-nav-item" href="#">tca</a>
</div>
    <a class="sidebar-nav-item" href="/archive/v1.0.0.zip">Download</a>
    <a class="sidebar-nav-item" href="">GitHub project</a>
    <span class="sidebar-nav-item">Currently v1.0.0</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2020. All rights reserved.
    </p>
  </div>
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">이기승의 techlog!</a>
            <small>coding panchi</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">웹 캐시</h1>
  <span class="post-date">17 Mar 2020</span>
  <h3 id="들어가며">들어가며</h3>

<p>웹 캐시는 자주 쓰이는 문서들의 사본을 자동으로 보관 및 관리하는 HTTP 장치입니다. 요청이 캐시에 왔을때 원하는 리소스의 사본이 존재하면 원 서버까지 요청이 가지 않고 캐시에서 제공됩니다.</p>

<ul>
  <li>불필요한 데이터 전송을 줄일 수있다 -&gt; 네트워크 비용 감소</li>
  <li>네트워크 병목을 줄여준다 -&gt; 대역폭을 늘리지 않더라도 응답시간 줄일 수 있다.</li>
  <li>원 서버까지 가는 요청을 줄여준다 -&gt; 원 서버의 부하를 감소시킬 수 있다.</li>
  <li>지역별로 캐시를 둬 거리로 인한 지연을 줄여준다.</li>
</ul>

<p>위와 같은 혜택을 얻을 수 있는 캐시의 동작 원리 및 특징을 알아보겠습니다.</p>

<hr />

<h3 id="71-불필요한-데이터-전송">7.1. 불필요한 데이터 전송</h3>

<p>대부분의 서버는 다수의 클라이언트를 상대합니다. 다수의 클라이언트로부터 같은 요청이 온다면 서버는 같은 데이터를 반복적으로 전송하게 됩니다.</p>

<p>이런 불필요한 데이터 전송은 네트워크 대역폭을 잡아먹고, 전송을 느리게 만들며 서버에 부하를 줍니다.</p>

<p>캐시를 사용하면 서버에서 나온 응답이 캐시에 보관됩니다. 요청은 캐시로 들어가 같은 요청에 대한 응답 사본이 있다면 캐시에서 응답의 사본을 돌려줍니다.</p>

<hr />

<h3 id="72-대역폭-병목">7.2. 대역폭 병목</h3>

<p>캐시는 네트워크 병목을 줄여줍니다. 대부분의 네트워크가 <a href="test" title="툴팁되나">WAN</a>보다 LAN에서 훨씬 더 넓은 대역폭을 제공합니다.
 캐시를 LAN망 안에 두게 된다면 좁은 WAN을 통과하지 않아 네트워크 병목을 줄여 지연을 감소시킬 수 있습니다.</p>

<hr />

<h3 id="73-갑작스런-요청-쇄도flash-crowds">7.3. 갑작스런 요청 쇄도(Flash Crowds)</h3>

<p>사회적 사건 혹은 기업의 이벤트 때문에 갑작스럽게 요청이 급증하는 경우가 있습니다. 이렇게 많은 사람들의 요청이 급증할 때에 캐싱을 사용한다면 서버의 부하를 많이 줄여줄 수 있습니다.</p>

<hr />

<h3 id="74-거리로-인한-지연">7.4. 거리로 인한 지연</h3>

<p>우리가 사용하는 인터넷은 물리적인 망을 가지고 있습니다. 복잡한 페이지를 로드하기 위해 지구 반대편의 원 서버로 수십개의 요청을 보낸다면 아무리 요청이 빛의 속도로 이동한다고 해도 유의미한 지연이 발생할 수 밖에 없습니다.</p>

<p>각 지역별로 캐시를 두는 일은 대역폭을 확보하는 것 뿐 아니라 실제 물리적인 거리에 따른 지연도 줄일 수 있습니다.</p>

<hr />

<h3 id="75-적중과-부적중">7.5. 적중과 부적중</h3>

<p>캐시는 원 서버의 모든 리소스 사본을 저장하진 않습니다. 그리고 저장 한다고 하더라도, 어떤 리소스들은 자주 수정될 수 있습니다.</p>

<p>캐시에 요청이 도착했을때 요청에 대해 캐시에서 사본을 찾아 응답을 줄 수 있다면 ‘적중(cache hit)’, 캐시에 사본이 없어 원 서버로 요청이 가야 한다면 ‘부적중(cache miss)’이라고 합니다.</p>

<h4 id="751-재검사revalidation">7.5.1. 재검사(Revalidation)</h4>

<p>원 서버의 리소스는 언제든지 변경될 수 있습니다. 그렇기 때문에 캐시는 때때로 가지고 있는 사본이 최신의 사본인지 검사해야 합니다. 언제 점검할지는 캐시의 정책에 따라 달라집니다. 이런 신선도 검사를 HTTP 재검사라고 부릅니다.</p>

<p>재검사 결과 리소스가 변경되지 않았다면 캐시는 사본이 아직 신선하다고 표시한뒤 클라이언트에게 사본을 돌려줍니다. 이를 ‘재검사 적중’ 혹은 ‘느린 적중’ 이라고 부릅니다. 이는 당연히 순수 캐시 적중보단 느립니다. 하지만 서버로부터 객체를 받아올 필요가 없기 때문에 캐시 부적중 보단 바릅니다.</p>

<p>캐시의 정책상 재검사가 필요할 때, 원 서버에 작은 재검사 요청을 보냅니다. 작은 재검사 요청을 보내기 위해 쓰이는 몇 가지 방법이 있는데 가장 널리 쓰이는 방법은 ‘If-Modified-Since’헤더를 보내는 것입니다. 이때 서버의 반응은 다음과 같습니다.</p>

<p><strong>재검사 적중</strong>
 서버가 검사를 해본뒤 리소스가 변경되지 않았다면 클라이언트에게 작은 304 Not Modified 응답을 보냅니다.</p>

<p><strong>재검사 부적중</strong>
 만약 요청 받은 리소스가 변경 됐다면 서버는 변경된 리소스 전체와 함께 평범한 HTTP 200 OK응답을 보냅니다. 캐시는 응답을 받아 사본을 갱신하고 클라이언트에게 전송합니다.</p>

<p><strong>객체 삭제</strong>
 만약 요청 받은 리소스가 서버에 없다면, 서버는 404 Not Found 응답을 돌려보내고, 이를 받은 캐시는 사본을 삭제한 뒤 클라이언트에게 404 Not Found 응답을 돌려줍니다.</p>

<h4 id="752-적중률">7.5.2. 적중률</h4>

<p>캐시가 요청을 처리하는 비율을 캐시 적중률 or 캐시 적중비 라고 부릅니다. 대게 여기서 말하는 ‘적중’은 ‘재검사 적중’을 제외한 순수 ‘적중’을 말하지만 때에 따라 재검사 적중을 포함해 적중률을 계산하는 곳도 있으니 염두해 두면 좋을 것 같습니다.</p>

<p>캐시 적중률은 예측하기 어려운 것으로 악명 높습니다. 캐시 적중률은 높으면 높을수록 좋지만 적중률 40%정도면 웹 캐시로서 괜찮은 편입니다.(책이 처음 쓰여진 때가 2002년임을 감안해 수치를 너무 맹신하지 않는게 좋을 것 같습니다.)</p>

<p>엄청나게 큰 캐시가 아닌 적당한 크기의 캐시도 자주 쓰이는 문서들을 저장하기엔 충분하고 유의미하게 트래픽을 줄이고 서버 성능을 개선할 수 있는 것으로 알려져 있습니다.</p>

<h4 id="753-바이트-적중률">7.5.3. 바이트 적중률</h4>

<p>방금 살펴본 캐시 적중률은 요청의 갯수별 적중률 입니다. 하지만 이런 의문을 제기할 수 있습니다.</p>

<blockquote>
  <p>‘작은 콘텐츠와 큰 콘텐츠가 트래픽을 차지하는 비중이 다른데 둘을 같게 봐도 되나?’</p>
</blockquote>

<p>그래서 필요한 적중률이 바이트 적중률입니다. 바이트 적중률은 캐시에서 나간 바이트중 캐시에서 바로 제공된 바이트의 비율을 뜻합니다. 실제 트래픽 절감을 측정할 수 있으며, 주로 바이트별 요금을 산정해야 되는 곳에서 사용됩니다.</p>

<p>바이트 적중률 100%는 모든 요청이 서버를 거치지 않고 바로 캐시에서 나갔음을 뜻합니다.</p>

<h4 id="754-적중과-부적중의-구별">7.5.4. 적중과 부적중의 구별</h4>

<p>이런 상황에서 클라이언트는 자신이 받은 응답이 캐시에서 나온 사본인지, 원 서버에서 온 원본인지 궁금할 수 있습니다.</p>

<p>하지만 HTTP에선 이를 말해주는 엄격한 방법은 제공해주지 않습니다. 대신 아래와 같은 임시 대안들이 있습니다.</p>

<ul>
  <li>어떤 상용 프록시 캐시들은 캐시에서 무슨 일이 일어났는지 설명하기 위해 Via 헤더에 추가정보를 줍니다.</li>
  <li>응답의 Date헤더를 확인해봤을때, 응답의 생성일이 요청일보다 오래되었다면 이전에 만들어진 사본임을 알 수 있습니다.</li>
  <li>비슷한 방법으로 응답이 얼마나 오래되었는지를 말해주는 Age 헤더를 살펴볼 수도 있습니다.</li>
</ul>

<hr />

<h3 id="76-캐시-토폴로지">7.6. 캐시 토폴로지</h3>

<p>캐시는 각 사용자마다 할당될 수도 있고 수천 명의 사용자가 공유할 수도 있습니다. 사용자마다 할당된 캐시를 개인 전용 캐시(private cache), 공유된 캐시는 공용 캐시(public cache)라고 합니다.</p>

<h4 id="761-개인-전용-캐시">7.6.1. 개인 전용 캐시</h4>

<p>가장 대표적인 개인 전용 캐시는 각 웹 브라우저들이 가지고 있는 웹 캐시입니다. 사용자의 PC에 자주 쓰이는 문서를 저장해둡니다. 사용자는 브라우저의 설정을 통해 브라우저의 캐시 크기를 설정할 수 있고 캐시가 저장될 위치도 설정할 수 있습니다. 이런 캐시된 문서들을 ‘임시 파일’이라고도 부릅니다.</p>

<p>크롬의 경우 기본 캐시 경로는 아래와 같습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Users\{Username}\AppData\Local\Google\Chrome\User Data\Default\Cache
</code></pre></div></div>

<h4 id="762-공용-프록시-캐시">7.6.2. 공용 프록시 캐시</h4>

<p>공용 캐시는 캐시 프록시 서버, 프록시 캐시라고도 불립니다. 여러 사용자가 공통적으로 자주 찾는 문서들을 저장해둡니다.</p>

<p>이런 프록시 캐시들은 결국 프록시이기 때문에 6장에서 알아본 프록시의 규칙들을 따라야 합니다.</p>

<h4 id="763-프록시-캐시-계층들">7.6.3. 프록시 캐시 계층들</h4>

<p>프록시를 여러 개 거칠 수 있었듯이 캐시 역시 여러 계층으로 이루어질 수 있습니다.</p>

<p>당장 우리가 사용하는 웹 브라우저들은 모두 각자의 캐시를 가지고 있습니다. 웹 브라우저를 통해 프록시 캐시를 운영하는 웹 사이트에 접속하려 한다면 이미 [웹 브라우저 캐시 -&gt; 프록시 캐시]와 같이 두 단계의 캐시를 거칠게 됩니다.</p>

<p>큰 규모의 업체들은 지역별로 작은 프록시 캐시를 두고, 원 서버 근처에 큰 프록시 캐시를 둬서 작은 프록시 캐시에서 처리하지 못한 요청들을 큰 프록시 캐시에서 처리하게 할 수 있습니다.</p>

<p>캐시 계층이 깊어진다면 요청은 캐시의 긴 연쇄를 따라가게 됩니다. 프록시 연쇄가 길어질 수록 각 중간 프록시에서 성능저하가 발생할 수 있어 오히려 프록시 연쇄를 안 두는 것보다 느려질 수도 있습니다.</p>

<h4 id="764-캐시망-콘텐츠-라우팅-피어링">7.6.4. 캐시망, 콘텐츠 라우팅, 피어링</h4>

<p>복잡한 캐시망을 사용하는 곳도 있습니다. 자식 캐시가 처리하지 못한 요청을 어느 부모 캐시에게 전해줄지 동적으로 결정하는 캐시망도 있고 다른 조직의 프록시 캐시끼리 서로 찾아볼 수 있게 하는 캐시망도 있습니다.(피어링)</p>

<p>캐시망 안에서 콘텐츠 라우팅을 할땐 다음과 같은 방식으로 어느 곳에 라우팅 할지 결정할 수 있습니다.</p>

<ul>
  <li>URL에 근거해 부모 캐시와 원 서버 중 하나를 동적으로 선택합니다.</li>
  <li>URL에 근거해 특정 부모 캐시를 동적으로 선택합니다.</li>
  <li>부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾습니다.</li>
  <li>다른 프록시 캐시들이 자신이 가진 컨텐츠를 부분적으로 접근할 수 있게 허용하되, 그들의 캐시를 통한 인터넷 트랜짓(Internet Transit)은 허용하지 않습니다.</li>
</ul>

<p>특히, 서로 다른 조직들이 상호의 이득의 위해 캐시를 연결해 서로 찾아볼 수 있게해주는 피어링을 지원하는 캐시를 ‘형제 캐시’라고 부릅니다. HTTP에선 형제 캐시를 지원하지 않기 때문에 형제 캐시를 사용하는 곳은 인터넷 캐시 프로토콜(ICP, Internet Cache Protocol)이나 하이퍼텍스트 캐시 프로토콜(HTCP, HyperText Cache Protocol)을   이용해 HTTP를 확장 했습니다. 이는 20장에서 더 자세히 살펴볼 것입니다.</p>

<hr />

<h3 id="77-캐시-처리-단계">7.7. 캐시 처리 단계</h3>

<p>캐시가 고도화됨에 따라 세부적인 기능은 매우 복잡하지만 기본적으로 아래와 같은 절차를 거칩니다.</p>

<ol>
  <li>요청 받기 : 네트워크로부터 도착한 요청 메세지를 읽습니다.</li>
  <li>파싱 : 메세지를 파싱해 URL, 헤더들을 추출합니다.</li>
  <li>검색 : 로컬 복사본이 있는지 검사하고, 없다면 원 서버에서 사본을 받아옵니다.(로컬에 저장합니다.)</li>
  <li>신선도 검사 : 애초에 로컬 복사본이 있었다면, 그 사본이 충분히 신선한지 검사합니다. 신선하지 않다면 서버에게 변경 사항이 있는지 물어보고 변경 사항이 있다면 사본을 받아옵니다.</li>
  <li>응답 생성 : 새로운 헤더와 캐시된 본문으로 응답 메세지를 만듭니다.</li>
  <li>발송 : 네트워크를 통해 응답을 클라이언트에게 돌려줍니다.</li>
  <li>로깅 : 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남깁니다.</li>
</ol>

<p>아래와 같은 차트로 흐른다고 보면 됩니다.</p>

<p>그림요망</p>

<h4 id="771-단계1--요청-받기">7.7.1. 단계1 : 요청 받기</h4>

<p>커넥션의 활동을 감지해 들어오는 데이터를 받아들입니다. 고성능 캐시는 여러 개의 커넥션으로 부터 동시에 데이터를 받고 전체 메세지가 도착하기 전에 트랜잭션 처리를 시작합니다.</p>

<h4 id="772-단계2--파싱">7.7.2. 단계2 : 파싱</h4>

<p>요청 메세지를 파싱해 URL과 헤더를 추출합니다. 이 과정에서 파서는 헤더 부분의 대소문자, 날짜 형식 같이 사소한 차이점이 무시되도록 파싱해야 합니다.</p>

<h4 id="773-단계3--검색">7.7.3. 단계3 : 검색</h4>

<p>알아낸 URL을 토대로 캐시된 로컬 사본이 있는지 검사합니다. 메모리에 있을 수도 있고 디스크에 있을 수도 있습니다. 혹은 캐시 본인의 디스크가 아닌 근처의 다른 디스크에 있을 수도 있습니다.</p>

<p>캐시된 사본을 찾을 수 없다면 원 서버 혹은 다음 홉에 있는 부모 프록시 캐시에서 가져오거나 실패를 반환합니다.</p>

<h4 id="774-단계4--신선도-검사">7.7.4. 단계4 : 신선도 검사</h4>

<p>캐시된 사본을 찾았다고 해서 바로 클라이언트에게 보내선 안됩니다. 가지고 있는 사본이 신선한지 검사해야 합니다. 이 신선도를 검사하는 알고리즘은 매우 복잡합니다. 이 장의 다음 절들은 대부분 신선도 검사와 관계된 내용입니다.</p>

<p>신선한 것으로 판단되면 그 로컬 사본으로 응답을 준비합니다. 신선하지 않다면 서버에 변경사항이 있는지 확인하는 재검사를 실시하게 됩니다.</p>

<p>재검사 결과 변경사항이 없으면 로컬 사본으로 응답을 준비하고, 변경사항이 있다면 서버에서 다시 사본을 가져와 캐시에 사본을 갱신합니다.</p>

<h4 id="775-단계5--응답-생성">7.7.5. 단계5 : 응답 생성</h4>

<p>캐시된 응답을 원 서버에서 온것처럼 보이게 하는 것이 좋습니다. 때문에 캐시된 서버 응답 헤더를 토대로 캐시의 응답 헤더를 구성합니다.</p>

<p>캐시는 클라이언트에 맞게 헤더를 조정해야 합니다. 클라이언트가 HTTP/1.1을 바라는데 서버에서의 응답이 HTTP/1.0이라면 캐시는 헤더를 적절히 번역해줘야 합니다.</p>

<p>캐시는 원 서버의 응답 헤더에 없는 헤더들도 추가할 수 있습니다. 캐시 신선도 정보(Cache-Control, Age, Expires.. )를 삽입할 수 있습니다. 또, 요청이 프록시 캐시를 거쳤다는 걸 알려주기 위해 Via헤더를 삽입할 수도 있습니다.</p>

<p>하지만 Date헤더는 조정해선 안됩니다. Date헤더는 원 서버에서 만들어진 일시를 표현하는 것입니다.</p>

<h4 id="776-단계6--전송">7.7.6. 단계6 : 전송</h4>

<p>응답 헤더가 준비되면 캐시는 응답을 돌려줍니다.</p>

<p>어떤 고성능 캐시들은 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피해 데이터를 효과적으로 전송하기 위해 노력합니다.</p>

<h4 id="777-단계7--로깅">7.7.7. 단계7 : 로깅</h4>

<p>대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지합니다. 트랜잭션 완료 후 캐시 적중, 부적중률에 대한 통계를 갱신하고 로그파일에 어떤 요청이 왔고 어떻게 응답했는지 등을 기록합니다.</p>

<p>가장 많이 사용되는 캐시 로그 포맷은 스퀴드 로그 포맷(Squid Log Format), 넷스케이프 확장 공용 로그 포맷(Netscape Extended Common Log Format)이지만 커스텀 로그 포맷을 사용해도 상관 없습니다. 로그 파일 포맷에 대해선 21장에서 자세히 다룹니다.</p>

<h4 id="778-캐시-처리-플로-차트">7.7.8. 캐시 처리 플로 차트</h4>

<p>앞에 먼저 소개해드렸습니다.</p>

<hr />

<h3 id="78-사본을-신선하게-유지하기">7.8. 사본을 신선하게 유지하기</h3>

<p>캐시된 데이터와 서버의 데이터가 일치하도록 관리하는 방법을 알아보겠습니다. HTTP에선 ‘문서 만료’와 ‘서버 재검사’라는 단순한 메커니즘으로 캐시된 사본과 서버의 원본이 일치하도록 관리할 수 있습니다.</p>

<h4 id="781-문서-만료">7.8.1. 문서 만료</h4>

<p>Cache-Control와 Expires라는 헤더들을 이용해 각 문서들에 유효기간을 붙일 수 있습니다. 유효기간이 끝나기 전엔 문서가 ‘신선한’것으로 판단해 서버와의 접촉 없이 사본을 제공할 수 있습니다.</p>

<p>유효기간이 만료된다면, 반드시 문서에 변경사항이 있는지 다시 검사하고 변경 사항이 있다면 신선한 사본을 얻어와야 합니다.</p>

<h4 id="782-유효기간과-나이">7.8.2. 유효기간과 나이</h4>

<p>유효기간을 표시하는데엔 Cache-Control과 Expires 헤더가 있습니다. 둘의 차이는 쉽게말해 Cache-Control은 문서가 최초로 생성된 이후로 몇초간 유효한가를 나타내고, Expires헤더는 만료되는 절대적인 날짜를 명시합니다.</p>

<p>Cache-Control:max-age
 max-age값은 최대 나이를 정의합니다. 최대 나이는 문서가 처음 생성된 이후부터, 제공하기에 더 이상 신선하지 않다고 간주될 때까지 경과한 초단위 시간입니다.</p>

<blockquote>
  <p>Cahce-Control : max-age=484200</p>
</blockquote>

<p>Expires
 절대 유효기간을 명시합니다. 이 유효기간이 넘어갔다면 그 문서는 더 이상 신선하지 않습니다. 이 Expires헤더가 제대로 작오하기 위해선 컴퓨터의 시계가 올바르게 작동하고 있어야 합니다.</p>

<blockquote>
  <p>Expires : Fri, 05 Jul 2002, 05:00:00 GMT</p>
</blockquote>

<p>현재 시각이 2020년 3월 17일 화요일 20:00:00 GMT 일때, 지금 시각으로부터 딱 5일(==432,000 초)간만 진행되는 이벤트를 위한 안내 페이지를 만들고 싶다면 그 페이지엔 아래의 헤더중 하나를 선택해 사용하면 됩니다.</p>

<blockquote>
  <p>Cache-Control : max-age=432000
Expires : Sun, 22 Mar 2020, 20:00:00 GMT</p>
</blockquote>

<h4 id="783-서버-재검사">7.8.3. 서버 재검사</h4>

<p>하지만 캐시된 사본의 유효기간이 만료되었다고 해서 그 사본이 서버의 원본과 다르다는 걸 의미하진 않습니다. 이제 다시 검사할 시간이 되었다는 것을 뜻합니다. 이렇게 문서 변경 여부를 다시 검사하는걸 ‘서버 재검사’라고 합니다.</p>

<p>서버 재검사 결과 문서가 변경되었다면, 변경된 문서의 새로운 사본을 가져와 캐시된 문서를 바꿔 저장한뒤, 클라이언트에게 보내줍니다.
 서버 재검사 결과 문서가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와 캐시된 문서의 헤더를 갱신합니다.</p>

<p>HTTP는 캐시가 다음중 하나는 응답하기를 요구합니다.</p>

<ol>
  <li>충분히 신선한 캐시된 사본</li>
  <li>재검사 결과 신선하다고 할 수 있는 캐시된 사본</li>
  <li>에러 메세지(재검사에 실패한 경우)</li>
  <li>경고 메세지가 부착된 캐시된 사본(부정확하다면)</li>
</ol>

<h4 id="784-조건부-메서드와의-재검사">7.8.4. 조건부 메서드와의 재검사</h4>

<p>그렇다면, 재검사 요청을 받는 서버의 입장에선 캐시에서 온 요청이 재검사 요청인지, 일반 리소스 요청인지 어떻게 구분할까요? 이를 위해 HTTP엔 조건부 GET 요청이 존재합니다.</p>

<p>조건부 GET 요청은 조건부 요청헤더를 추가해 만들어집니다. 조건부 요청 헤더에는 아래 5가지가 있지만 유용하고 주로 사용되는 2개의 헤더에 대해서만 자세히 알아보겠습니다.</p>

<table>
  <thead>
    <tr>
      <th>헤더</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>If-Modified-Since</td>
      <td>주어진 날짜 이후로 수정되었다면 요청 메서드를 처리합니다. Last-Modified 헤더와 함께 사용됩니다.</td>
    </tr>
    <tr>
      <td>If-None-Match</td>
      <td>문서의 일련번호 및 id 처럼 문서의 버전을 나타내는 태그를 비교해 요청 메서드를 처리합니다.</td>
    </tr>
    <tr>
      <td>If-Unmodified-Since</td>
      <td>문서의 부분의 같이 전송해 문서가 변하지 않았는지를 확인합니다.</td>
    </tr>
    <tr>
      <td>If-Range</td>
      <td>불완전한 문서의 캐싱을 지원하기 위해 사용됩니다.</td>
    </tr>
    <tr>
      <td>If-Match</td>
      <td>웹 서버에 대한 동시성 제어를 할 때 유용합니다.</td>
    </tr>
  </tbody>
</table>

<h4 id="785-if-modified-since--날짜-재검사">7.8.5. If-Modified-Since : 날짜 재검사</h4>

<p>가장 많이 쓰이는 재검사 헤더는 If-Modified-Since 입니다. 이는 흔히 줄여서 IMS 요청이라고도 불립니다.</p>

<blockquote>
  <p>If-Modified-Since : Tue, 17 Mar 2020, 20:30:00 GMT</p>
</blockquote>

<p>서버가 위와 같은 IMS 요청을 받는다면, 현재 서버의 원본이 마지막 변경일을 확인합니다. If-Modified-Since가 참이라면(==변경 되었다면) 변경된 문서의 사본과 함께 평범한 GET 응답이 새로운 만료 날짜와 함께 돌아갑니다.
 If-Modified-Since가 거짓이라면(==변경되지 않았다면), 서버는 작은 304 Not Modified 응답을 돌려줍니다. 이 응답에 본문은 없습니다.</p>

<p>If-Modified-Since 헤더에 대한 응답엔 Last-Modified 헤더가 따라붙습니다. 캐시가 다음번에 같은 문서를 재검사 요청 보내게 될 땐 저번 재검사 요청의 응답으로 받은 Last-Modified 헤더의 값을 If-Modified-Since값에 넣어 보내게 됩니다.</p>

<p>주의할 점이 있습니다. 몇몇 웹 서버는 If-Modified-Since의 값을 시간으로 파싱해 비교하지 않습니다. 대신 단순 문자열 비교를 수행해 ‘이 날짜 이후로 변경되었다면’이라는 의미가 아니라 ‘정확히 이 날자에 마지막 변경이 일어난 것이 아니라면’과 같이 비교합니다.  심지어 날짜가 아닌 일련번호, id 같은 것을 If-Modified-Since에 넣어 문자열 비교를 사용하기도 합니다.</p>

<h4 id="786-if-none-match--엔터티-태그-재검사">7.8.6. If-None-Match : 엔터티 태그 재검사</h4>

<p>날짜를 기준으로한 If-Modified-Since 검사가 가장 많이 쓰이지만 날짜 비교가 적절하지 않은 콘텐츠들도 있습니다.</p>

<ul>
  <li>일정 간격으로 다시 쓰여지지만 실제 내용 변화가 없을 경우</li>
  <li>서버를 바라보는 모든 캐시들이 다시 데이터를 받기엔 변경이 사소한 경우(철자 및 주석 등)</li>
  <li>페이지에 대한 최근 변경 일시를 정확하게 판별할 수 없는 경우</li>
  <li>1초보다 작은 간격으로 갱신이 될 수 있는 경우</li>
</ul>

<p>위와 같은 경우엔 If-None-Match 헤더를 사용할 수 있습니다.</p>

<blockquote>
  <p>GET /announce.html HTTP/1.0
If-None-Match : “v2.6”</p>
</blockquote>

<p>위 헤더는 해당 문서의 버전이 ‘v2.6’이라는 것입니다. 이렇게 일련번호, 버전, id와 같이 문서가 유의미하게 변경되었다는 것을 보여줄수 있는 태그들을 사용해 재검사를 할 수 있습니다.</p>

<p>이에 대한 서버의 응답은 Etag(Entity Tag) 헤더와 함께 돌아옵니다.</p>

<blockquote>
  <p>HTTP/1.0 304 Not Modified
Date : Wed, 03 Jul 2020, 19:18:22 GMT
<strong>ETag : “v2.6”</strong>
Expires : Frie, 05 Jul 2020, 05:00:00 GMT</p>
</blockquote>

<p>위는 변경되지 않았을 때이고, 변경되었다면 200 OK 코드와 갱신된 Etag값, 엔터티 본문과 함께 응답될 것입니다.</p>

<p>캐시가 객체에 대해 여러개 사본을 가지고 있다면 If-None-Match 태그에 여러개의 엔터티 태그를 같이 보낼 수도 있습니다.</p>

<blockquote>
  <p>If-None-Match : “v2.4”, “v2.5”, “v2.6”</p>
</blockquote>

<h4 id="787-약한-검사기와-강한-검사기">7.8.7. 약한 검사기와 강한 검사기</h4>

<p>앞서 ‘서버를 바라보는 모든 캐시들이 다시 데이터를 받기엔 변경이 사소한 경우(철자 및 주석 등)’ 를 위해 엔터티 태그를 사용한다고 했습니다. 하지만 이 문제를 해결하기 위한 다른 방법도 있습니다.</p>

<p>HTTP/1.1 에선 조금 수정된 컨텐츠를 위해 “그 정도면 같은 것이다”라고 서버가 주장할 수 있게 해주는 약한 검사기(weak validator)를 지원합니다. 반대로 약한 검사기가 아닌것은 강한 검사기(strong validator)입니다.</p>

<p>약한 검사기는 엔터티 태그 앞에 ‘W/’ 접두사를 사용해 구분합니다. ‘W/’접두가사 붙은 엔터티 태그는 약한 검사를 해달라는 것입니다.</p>

<blockquote>
  <p>Etag : W/”v2.6”</p>
</blockquote>

<p>강한 엔터티 태그는 그에 대응하는 엔터티 값이 어떻게 바뀌든 매번 같이 바뀌어야 합니다. 하지만 약한 엔터티 태그는 변경중 유의미한 변경이 있을때만 같이 변경됩니다.</p>

<p>서버는 강한 엔터티, 약한 엔터티 모두 재활용해서는 안됩니다. 캐시에 요청이 잘 안들어온다면 유효기간이 엄청오래된 콘텐츠에 대해 재검사 요청이 올수 있고, 이때 요청온 엔터티 태그가 재활용된 태그라면 큰 혼란을 만들것입니다.</p>

<h4 id="788-언제-엔터티-태그를-사용하고-언제-last-modified-일시를-사용하는가">7.8.8. 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가</h4>

<p>앞서 알아본 것과 같이 서버는 문서의 유효기간을 다루기 위해 Etag 헤더 혹은 Last-Modified 헤더를 보낼 수 있습니다.</p>

<p>캐시의 입장에선, 서버가 Etag 헤더를 사용한다면 If-None-Match를, Last-Modified 헤더를 사용한다면 If-Modified-Since 헤더를 사용해야 합니다. 만약 모두 사용 가능하다면 두 가지 모두 사용하는 것을 추천합니다.(HTTP/1.0, HTTP/1.1 모두를 다룰 수 있기 때문입니다.)</p>

<p>HTTP/1.1 을 구현하고 있는 서버는 가능하다면 Etag 헤더를 보내야 합니다. Last-Modified 헤더를 같이 보내면 더 좋습니다.</p>

<hr />

<h3 id="79-캐시-제어">7.9. 캐시 제어</h3>

<h4 id="791-no-cahce와-no-store-응답-헤더">7.9.1. no-cahce와 no-store 응답 헤더</h4>

<h4 id="792-max-age-응답-헤더">7.9.2. Max-Age 응답 헤더</h4>

<h4 id="793-expires-응답-헤더">7.9.3. Expires 응답 헤더</h4>

<h4 id="794-must-revalidate-응답-헤더">7.9.4. Must-Revalidate 응답 헤더</h4>

<h4 id="795-휴리스틱-만료">7.9.5. 휴리스틱 만료</h4>

<h4 id="796-클라이언트-신선도-제약">7.9.6. 클라이언트 신선도 제약</h4>

<h4 id="797-주의할-점">7.9.7. 주의할 점</h4>

<hr />

<h3 id="710-캐시-제어-설정">7.10. 캐시 제어 설정</h3>

<h4 id="7101-아파치로-http-헤더-제어하기">7.10.1. 아파치로 HTTP 헤더 제어하기</h4>

<h4 id="7102-http-equiv를-통한-html-캐시-제어">7.10.2. HTTP-EQUIV를 통한 HTML 캐시 제어</h4>

<hr />

<h3 id="711-자세한-알고리즘">7.11. 자세한 알고리즘</h3>

<h4 id="7111-나이와-신선도-수명">7.11.1. 나이와 신선도 수명</h4>

<h4 id="7112-나이-계산">7.11.2. 나이 계산</h4>

<h4 id="7113-완전한-나이-계산-알고리즘">7.11.3. 완전한 나이 계산 알고리즘</h4>

<h4 id="7114-신선도-수명-계산">7.11.4. 신선도 수명 계산</h4>

<h4 id="7115-완전한-서버-신선도-알고리즘">7.11.5. 완전한 서버 신선도 알고리즘</h4>

<hr />

<h3 id="712-캐시와-광고">7.12. 캐시와 광고</h3>

<h4 id="7121-광고-회사의-딜레마">7.12.1. 광고 회사의 딜레마</h4>

<h4 id="7122-퍼블리셔의-응답">7.12.2. 퍼블리셔의 응답</h4>

<h4 id="7123-로그-마이그레이션">7.12.3. 로그 마이그레이션</h4>

<h4 id="7124-적중-측정과-사용량-제한">7.12.4. 적중 측정과 사용량 제한</h4>

<hr />

<h3 id="마치며">마치며</h3>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/study_googling/jekyll/%EA%B6%8C%ED%95%9C%EB%AC%B8%EC%A0%9C/">
            윈도우에서 수정한 우분투-리눅스 파일 권한 수정
            <small>17 Mar 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/study_googling/etc/Github-Page-Emoji/">
            Github Page Emoji
            <small>16 Mar 2020</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/study_googling/etc/Framework-vs-Library/">
            프레임워크(Framework) vs 라이브러리(Library)
            <small>16 Mar 2020</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
