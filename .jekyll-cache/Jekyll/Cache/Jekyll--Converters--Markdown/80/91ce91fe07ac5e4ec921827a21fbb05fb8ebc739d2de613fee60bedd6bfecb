I"ł
<ul>
  <li>
    <p>해당 포스팅은 <a href="https://www.udemy.com/course/c-unmanaged-programming-by-pocu/">Kim Pope 선생님의 C 언매니지드 프로그래밍 강의</a>를 정리하며 사견을 붙인 것입니다.</p>
  </li>
  <li>
    <p>포스팅 내 목차는 동영상강의 기준입니다.</p>
  </li>
</ul>

<h2 id="165-입력">165. 입력</h2>

<hr />

<ul>
  <li>입력은 출력보다 어렵고 귀찮고 꼼꼼해야 합니다. 후후..</li>
  <li>입력은 출력의 반대입니다. 외부의 데이터를 읽어와 프로그램에서 사용합니다.</li>
  <li>외부에서 어떤 데이터가 들어올지 몰라 괴상한 데이터가 들어옵니다.
    <ul>
      <li>정수를 받으려고 했는데 문자를 준다던가</li>
      <li>파일을 입력하고 싶은데 파일 자체가 깨져있다던가..</li>
    </ul>
  </li>
  <li>데이터 읽기에 대한 예외처리를 안하면 프로그램이 잘 터집니다.
    <ul>
      <li>따라서 모든 입력 함수에는 반환값이 있습니다. 잘 입력이 됐는지 확인해주기 위해서.</li>
      <li>대부분 입력처리 코드 문제는 반환값이 뭔지 제대로 몰라서 발생합니다.</li>
    </ul>
  </li>
  <li>입력은 어디서 올까요?
    <ul>
      <li>어딘가에 누군가 출력 했다면 거기서 읽어올 수 있다고 생각하면 편합니다.</li>
      <li>스트림 - 콘솔, 파일 등등</li>
      <li>문자열 - 문자열로 출력도 했으니 문자열에서 입력해 올 수도 있습니다.</li>
    </ul>
  </li>
  <li>입력 처리 전략엔 4가지 정도가 있습니다.
    <ul>
      <li>한 글자씩 읽기</li>
      <li>한 줄씩 읽기</li>
      <li>한 데이터씩 읽기</li>
      <li>한 블록씩 읽기(이진 데이터)</li>
    </ul>
  </li>
</ul>

<h2 id="166-한-글자씩-읽기-한-글자씩-읽는-알고리즘-1">166. 한 글자씩 읽기, 한 글자씩 읽는 알고리즘 1</h2>

<hr />

<ul>
  <li>
    <p>한 글자씩 읽는 기본 동작</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>  
<span class="cp">#define TRUE (1)
</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
        <span class="cm">/* 버퍼에 남은게 없으면 입력을 기다립니다. */</span>
        <span class="cm">/* 버퍼에 남아 있는게 있으면 버퍼에서 바로 1개를 가져옵니다.*/</span>
        <span class="n">putchar</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">int getchar(void);</code>, <code class="highlighter-rouge">int fgetc(FILE* stream);</code> 두 개는 거의 같은 입력 함수 입니다.</p>

    <ul>
      <li>그런데 왜 int를 반환할까요? 조금 있다 알아봅니다.</li>
    </ul>
  </li>
</ul>

<h2 id="167-getchar와-eof-키">167. getchar()와 EOF 키</h2>

<hr />

<ul>
  <li>강의166의 코드는 문제가 있습니다. 끝나질 않습니다. 어떻게 끝낼까요?</li>
  <li>getchar()의 <a href="https://en.cppreference.com/w/c/io/getchar">레퍼런스</a>를 보면 입력 성공시엔 문자를, 실패하면 EOF(end-of-file)을 반환합니다.</li>
  <li>주로 EOF를 입력시키는 걸로 입력을 끝냅니다.</li>
  <li>C표준에 의하면 EOF는 음수라고 합니다. 근데, C 표준에서 char는 signed일수도, unsigned일수도 있습니다. 그래서 getchar가 char가 아니라 int를 반환합니다. 음수인 EOF를 char의 부호에 관계없이 다뤄야 하기 때문입니다.</li>
</ul>

<h2 id="168-한-글자씩-읽기-알고리즘-2-eof-키는-어디-있나요">168. 한 글자씩 읽기 알고리즘 2, EOF 키는 어디 있나요?</h2>

<hr />

<ul>
  <li>
    <p>EOF를 적용해 강의166의 코드를 수정해봅시다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>  
<span class="cp">#define TRUE (1)
</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="k">while</span><span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">putchar</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="p">}</span>    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>근데 EOF는 어떻게 입력할까요?</p>

    <ul>
      <li>윈도우 : ctrl + z</li>
      <li>유닉스 등 : ctrl + d</li>
    </ul>
  </li>
  <li>
    <p>근데 위 코드에서 <code class="highlighter-rouge">c = getchar();</code>가 두 번 나와서 좀 불편합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>  
<span class="cp">#define TRUE (1)
</span>  
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
      
    <span class="k">while</span><span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">())</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">putchar</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>이게 되네 (c = getchar()를 괄호로 꼭 쳐줘야 합니다. 안치면 getchar() != EOF 부터 합니다.)</li>
      <li>이걸 말고도 flag 사용하는 방법도 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>한 글자씩 읽는 방법의 장점</p>

    <ul>
      <li>간단합니다.</li>
      <li>입력이 문자/문자열 일때 좋습니다.</li>
      <li>쓸데 없이 메모리에 입력값을 저장하지 않아도 됩니다. 용량과 실수를 줄일 수 있습니다.</li>
      <li>O(N) 알고리즘에 적합합니다.</li>
    </ul>
  </li>
  <li>
    <p>단점</p>

    <ul>
      <li>정수 같은 문자가 아닌 데이터를 처리하기 어렵습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="169-코드보기--공백whitespace과-줄-수-세기">169. 코드보기 : 공백(whitespace)과 줄 수 세기</h2>

<hr />

<ul>
  <li>이정도 코드 못 짜는 사람 없죠?</li>
  <li>주의할점 : 공백문자라고 하면 <code class="highlighter-rouge">' '</code> 외에도 \n, \t, \f, \r, \v가 포함됩니다. <a href="https://en.cppreference.com/w/cpp/string/byte/isspace">레퍼런스</a></li>
  <li>공백문자를 찾는건 isspace()라는 함수가 <ctype.h>에 있습니다.</ctype.h></li>
</ul>

<h2 id="170-한-줄씩-읽기-gets">170. 한 줄씩 읽기, gets()</h2>

<hr />

<ul>
  <li>
    <p>한 줄은 \n으로 구분 됩니다.</p>
  </li>
  <li>
    <p>한 줄씩 읽는 입력 프로그램의 알고리즘은 한 문자씩과 비슷합니다.</p>

    <ul>
      <li>한 줄 읽고, 읽는데 실패하면 프로그램 종료, 성공했다면 로직 수행, 다시 읽기</li>
    </ul>
  </li>
  <li>
    <p>한 줄을 읽어오면 어딘가 저장해야 합니다.</p>

    <ul>
      <li>근데 그럼 한 줄 읽어오는 함수가 새로운 문자열을 반환해줄까요?</li>
      <li>앞서 알아봤지만 새로운 문자열을 반환하는 함수는 메모리 누수를 일으키기 쉽습니다.</li>
      <li>C에선 절대 새로운 메모리를 반환하는 식으로 돌지 않습니다. 프로그래머가 미리 만든 배열을 함수에 전달해야 합니다.</li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">char* gets(char* str);</code></p>

    <ul>
      <li>
        <p>알려주긴 하지만 거의 퇴출당한 함수입니다. 매우 위험해서.</p>

        <ul>
          <li>C11에선 아예 함수를 제거했습니다.</li>
          <li>최신 C의 헤더파일엔 아예 gets가 없습니다.</li>
        </ul>
      </li>
      <li>
        <p>stdin에서 ‘\n’ 이나 EOF를 만날때 까지 계속 문자를 읽어 str 배열에 저장해줍니다. (그래서 str이 const가 아닙니다.)</p>
      </li>
      <li>
        <p>성공시 입력한 str을 그대로 반환하고, 실패시 널 포인터를 반환합니다.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>    
<span class="cp">#define LINE_LENGTH (64)
</span><span class="o">:</span>
<span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">LINE_LENGTH</span><span class="p">]</span>
    
<span class="k">while</span> <span class="p">(</span><span class="n">gets</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
	<span class="n">puts</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>위 코드에서 64자 이상 입력하면 버퍼 오버플로가 뜹니다. LINE_LENGTH에 몇을 넣든, 그 이상 입력하면 버퍼 오버플로가 발생합니다.(악의적으로 버퍼 오버플로를 유도하는 공격도 있습니다. buffer overflow attack!)</p>
      </li>
      <li>
        <p>버퍼를 잡아놓으면 버퍼에 메모리가 할당 되는데, 버퍼 이상을 입력하려하니 버퍼 범위 외의 곳에 메모리를 덮어 씁니다. 해당 함수 프레임이 끝나고 돌아가야할 함수 주소도 덮어 쓸 수도 있고..</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="171-fgets로-안전하게-한-줄-읽기">171. fgets()로 안전하게 한 줄 읽기</h2>

<hr />

<ul>
  <li>
    <p>f붙은건 file 스트림용이긴 합니다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">char* fgets(char* str, int count, FILE* stream)</code></p>

    <ul>
      <li>
        <stdio.h>안에 있습니다.
</stdio.h>
      </li>
      <li>str은 입력 받은 한 줄을 저장할 char 배열입니다.</li>
      <li>최대 count -1 개의 문자열을 읽어서 str에 저장합니다. -1은 널 문자 자리입니다.</li>
      <li>fgets는 새줄이나 EOF를 만나지 않더라도 count-1개의 문자열을 읽으면 반환됩니다.</li>
      <li>stream의 자료형인 FILE*에서 FILE 자료형은 다음과 같이 스트림 제어에 필요한 정보를 담고 있는 자료형입니다.
        <ul>
          <li>파일 위치 표시자</li>
          <li>스트림이 사용하는 버퍼의 포인터</li>
          <li>읽기/쓰기 중 발생한 오류를 기록하는 오류 표시자</li>
          <li>파일 끝에 도달했음을 기록하는 EOF 지시자</li>
        </ul>
      </li>
      <li>FILE이라 파일만 될 것 같지만 다른 스트림도 모두 표현가능합니다.</li>
      <li>입,출력 스트림은 FILE 포인터로만 접근할 수 있습니다.</li>
      <li>gets와 마찬가지로 성공시 입력받은 str을 반환, 실패시 널 포인터를 반환합니다.</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>  
<span class="cp">#define LINE_LENGTH (10)
</span><span class="o">:</span>
<span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">LINE_LENGTH</span><span class="p">]</span>
  
<span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LINE_LENGTH</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>위에서 “123456789abcde\n”을 입력했을경우
        <ul>
          <li>첫 번째 line배열은 “123456789\0” 가 됩니다. 10 - 1개만 입력하고 마지막에 \0를 입력합니다.</li>
          <li>두 번째 line배열은 “abcde\n\089\0” 가 됩니다. 기존에 있던 8,9,\0을 지우지 않고 그냥 앞에만 덮어 씁니다.</li>
        </ul>
      </li>
      <li>fgets()에 쓸 버퍼는 초기화할 필요 없습니다.</li>
    </ul>
  </li>
  <li>
    <p>위 코드에서 왜 puts() 대신 printf()를 썼을까요?</p>

    <ul>
      <li>gets()로 읽어온 거엔 puts()를 써도 됩니다만 fgets()로 읽어온 거엔 printf()를 써줘야 합니다.</li>
      <li>puts()의 레퍼런스를 통해 스스로 찾아 보세요.</li>
    </ul>
  </li>
</ul>

<h2 id="172-한-줄씩-읽는-방법이-유용한-경우">172. 한 줄씩 읽는 방법이 유용한 경우</h2>

<hr />

<ul>
  <li>우선 단어 하나씩 읽는 것보단 한 줄씩 읽는 게 빠릅니다.
    <ul>
      <li>특히, CPU를 벗어난 외부로부터 뭔가를 읽어오는건 부하가 크기 때문에 한 번에 크게크게 읽어 오는게 유리합니다.</li>
    </ul>
  </li>
  <li>버퍼 크기는 큰 게 좋습니다.</li>
  <li>이 자체로 쓰기보다 뒤에서 볼 ‘한 데이터씩 읽어올 때’랑 같이 쓰면 한 줄씩 읽는 게 더 유용합니다.</li>
</ul>

<h2 id="173-한-데이터씩-읽기-scanf">173. 한 데이터씩 읽기, scanf()</h2>

<hr />

<ul>
  <li>
    <p>지금까진 한 문자씩, 한 줄씩 읽었습니다. 한 데이터씩 읽는 방식은 이번엔 int로, 이번엔 char[]로 등등 타입을 바꿔가며 받을 수 있습니다.</p>
  </li>
  <li>
    <p>scanf, fscanf, sscanf 세 가지가 있습니다.</p>

    <ul>
      <li><code class="highlighter-rouge">int scanf(const char* format, ...)</code> : stdin으로 부터 읽어옵니다.</li>
      <li><code class="highlighter-rouge">int fscanf(FILE* stream, const char* format, ...)</code> 파일 스트림으로부터 읽어옵니다.</li>
      <li><code class="highlighter-rouge">int sscanf(const char* buffer, const char* format, ...)</code> C스타일 문자열로부터 읽어옵니다.</li>
    </ul>
  </li>
  <li>
    <p>stdin에서 정수 읽기</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Enter Number : "</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
<span class="n">prindf</span><span class="p">(</span><span class="s">"num = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>
</code></pre></div>    </div>

    <ul>
      <li>저장할 변수의 주소를 전달합니다. scanf에 그냥 num을 넣으면 scanf 스택 프레임에서만 쓰이고 사라지기 때문입니다. 참조에의한 전달을 하는거죠. 이거 아직도 모르면 머리 박으세요..</li>
    </ul>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num1</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">str1</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%d %s"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num1</span><span class="p">,</span> <span class="n">str1</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li>이런식으로 한 번은 정수로, 한번은 문자열로 받아올 수 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>scanf는 몇 개의 데이터를 읽었는지를 반환합니다.</p>
  </li>
</ul>

<h2 id="174-scanf의-일반적인-서식-문자열-형식">174. scanf()의 일반적인 서식 문자열 형식</h2>

<hr />

<ul>
  <li>scanf() 에는 3개의 옵션이 올 수 있습니다.
    <ul>
      <li>%[*][너비][길이수정자]서식지정자</li>
      <li>서식지정자 : printf와 마찬가지로 다 설명해주려면 끝도 없습니다. 스스로 필요할 때 찾아가면서 하세요.</li>
      <li>너비 : 잘 쓰진 않지만 문자 갯수를 정해 읽을 수 있다는걸 알아만 둡시다.</li>
      <li>길이수정자 : 필요하면 찾아보세요!</li>
      <li>* : 대입 생략 문자 입니다. 한 데이터를 그냥 무시합니다.</li>
    </ul>
  </li>
  <li>모든 데이터는 공백 문자로 구분해 한 단어씩 or 가능할 때까지(“%d”를 받는데 “123abc”를 입력할 경우 “123”까지만 읽습니다.) 읽습니다. 즉, scanf로 읽으면 공백문자는 다 사라집니다. 공백문자를 읽고 싶으면 서식 지정자에서 “%c”로 받는 수 밖에 없습니다.</li>
</ul>

<h2 id="175-scanf-사용-예">175. scanf() 사용 예</h2>

<hr />

<ul>
  <li>사용예시 구경..</li>
</ul>

<h2 id="176-문자를-읽을-때-scanf의-문제점과-해결책-clearerr">176. 문자를 읽을 때 scanf()의 문제점과 해결책, clearerr()</h2>

<hr />

<ul>
  <li>
    <p>문제가 있습니다.. “%s”를 쓸 때, 배열 크기보다 큰 문자열이 들어오면 버퍼 오버플로가 뜨게 됩니다. 아래처럼.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
<span class="cm">/* 입력 &gt;&gt; 123456789abcdefghijklmnop*/</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>이래서 scanf는 문자열 읽을 땐 좋지 않습니다.</p>
  </li>
  <li>
    <p>또한, 문자열 뿐 아니라 다른 데이터형 읽을 때 무한루프에 빠질 위험이 큽니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  
<span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"error"</span><span class="p">);</span>
		<span class="k">continue</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sum</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li>위 코드는 숫자를 입력하면 sum에 계속 더하면서 0을 입력받으면 더하는 걸 멈추고 지금까지의 합을 출력합니다.</li>
      <li>하지만 숫자가 아닌 걸 입력하면 숫자로 입력받지 못하고 “error”를 띄웁니다. 그런데 버퍼엔 아직 입력 못받은 숫자아닌 문자가 남아 있어서 계속 “error”가 뜨는 무한 루프에 빠지게 됩니다.</li>
    </ul>
  </li>
  <li>
    <p>fgests와 sscanf를 같이 쓰는게 좋습니다.</p>
  </li>
  <li>
    <p>위 코드를 개선한 코드입니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TRUE (1)
#define LINE_LENGTH (1024)
</span>  
<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  
<span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LINE_LENGTH</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
		<span class="n">clearerr</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
      
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">sum</span><span class="o">+=</span><span class="n">num</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
  
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
</code></pre></div>    </div>

    <ul>
      <li>일단 입력을 줄 단위로 읽습니다. 그리고 숫자단위로 가능한 만큼 읽습니다.</li>
    </ul>
  </li>
  <li>
    <p>버퍼 오버플로 걱정 없이 문자열 읽어오기</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define TRUE (1)
#define LENGTH (4096)
</span>  
<span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">LENGTH</span><span class="p">];</span>
<span class="kt">char</span> <span class="n">word</span><span class="p">[</span><span class="n">LENGTH</span><span class="p">];</span>
  
<span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LENGTH</span><span class="p">,</span> <span class="n">stdin</span><span class="p">)</span><span class="o">==</span><span class="nb">NULL</span><span class="p">){</span>
		<span class="n">clearerr</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
      
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="s">"%s"</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">){</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">word</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li>한 줄 입력을 받는 line의 길이와 한 데이터 읽는 word 길이를 같게 했기 때문에 LENGTH 이상의 입력을 받으면 line쪽에서 잘려서 받을 뿐, 버퍼 오버플로가 나지는 않습니다.</li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">void cleaererr(FILE* stream);</code></p>

    <ul>
      <li>스트림을 읽거나 쓸 때 EOF를 만나면 스트림의 EOF 표시자(indicator)가 셋팅됩니다.</li>
      <li>그 이외의 이유로 실패하면 오류 표시자를 셋팅합니다.</li>
      <li>표시자는 잘 안지워지는데, 오류 표시자가 안지워진 상태로 읽거나 쓰면 실패할 수 있습니다. clearerr는 그 오류표시자를 지워줍니다.</li>
      <li>표시자의 셋팅여부를 보고 싶으면 feof(), ferror() 함수를 사용하면 됩니다.</li>
    </ul>
  </li>
  <li>
    <p>한 데이터씩 읽는 방법이 유용한 경우</p>

    <ul>
      <li>텍스트를 다른 자료형으로 바로 읽어오는 간단한 방법입니다.</li>
    </ul>
  </li>
</ul>

<h2 id="177-코드보기-게임-전적-쓰고-읽기">177. 코드보기: 게임 전적 쓰고 읽기</h2>

<hr />

<ul>
  <li>16분이나 되는 코드보기 시간입니다.</li>
</ul>

<h2 id="178-한-블록씩-읽기">178. 한 블록씩 읽기</h2>

<hr />

<ul>
  <li>
    <p>입력 받기의 마지막 한 블록씩 읽기 입니다. 이진 파일을 다룰 때 유용합니다.</p>
  </li>
  <li>
    <p>지금까지 본 방법은 텍스트로 저장된 데이터를 읽는 것이었습니다. 한 블록씩 읽기는 이진 데이터로 저장된 걸 읽는 방법입니다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">size_t fread(void* buffer, size_t size, size_t count, FILE* stream);</code></p>

    <ul>
      <li>stream에서 size바이트짜리 데이터를 총 count 갯수 만큼 읽어 buffer에 저장합니다.</li>
      <li>EOF를 만나면 당연히 멈춥니다.</li>
      <li>반환 값은 실제로 읽은 갯수를 반환합니다.</li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">size_t fwrite(const void* buffer, size_t size, sitze_t count, FILE* stream);</code></p>

    <ul>
      <li>읽기가 있으면 쓰기도 있겠죠? 쓰기여서 buffer가 const 입니다. (buffer에 있는 데이터를 밖으로 쓰니까)</li>
    </ul>
  </li>
  <li>
    <p>이진 데이터를 다루기 위해선 파일 스트림을 다뤄야 합니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nums</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">num_read</span><span class="p">;</span>
<span class="kt">FILE</span><span class="o">*</span> <span class="n">fstream</span><span class="p">;</span>
<span class="cm">/* fstream을 가져왔다고 가정 */</span>
<span class="n">num_read</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">64</span><span class="p">,</span> <span class="n">fstream</span><span class="p">);</span>
<span class="n">fwrite</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">64</span><span class="p">,</span> <span class="n">fstream</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>기본 데이터 크기는 시스템마다 다르기 때문에 파일에 저장할 데이터 크기는 고정해 두는게 좋습니다.</p>

    <ul>
      <li>A 시스템용으로 빌드한 실행파일을 B 시스템으로 실행하면 온갖 에러가..</li>
    </ul>
  </li>
</ul>

<h2 id="179-파일-입출력">179. 파일 입출력</h2>

<hr />

<ul>
  <li>C에선 파일을 어떻게 열까요? C#에선 굉장히 쉬웠는데</li>
  <li>C에서 파일 다루는 건 정말 귀찮습니다.</li>
  <li>C에서 파일 다룰땐 다음과 같은 과정을 따릅니다.
    <ul>
      <li>파일을 열어서 파일 스트림을 가져옵니다.</li>
      <li>파일 스트림을 사용해서 로직을 수행합니다.</li>
      <li>파일을 닫아줍니다.</li>
    </ul>
  </li>
</ul>

<h2 id="180-파일-열기">180. 파일 열기</h2>

<hr />

<ul>
  <li>
    <p>파일을 열땐 fopen을 쓰면 됩니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#define LENGTH (1024)
</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">stream</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">list</span><span class="p">[</span><span class="n">LENGTH</span><span class="p">];</span>
  
<span class="n">stream</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>
  
<span class="k">if</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">LENGTH</span><span class="p">,</span> <span class="n">stream</span><span class="p">)</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="highlighter-rouge">FILE* fopen(const char* filename, const char* mode);</code></p>

    <ul>
      <li>filename 이름의 파일을 여는데</li>
      <li>모드(일기전용, 이진 파일 등)을 지정할 수 있습니다.
        <ul>
          <li>r : 읽기전용. 파일이 있다면 첫 부분부터 읽고, 없다면 열기에 실패합니다.</li>
          <li>w : 쓰기 전용. 파일이 있다면 내용을 모두 없애고 처음부터 씁니다. 없다면 새 파일을 생성합니다.</li>
          <li>a : append. 파일이 있다면 끝부분부터 읽습니다. 파일이 없다면 새 파일을 생성합니다.</li>
          <li>그 외에도 r+, w+, a+ 가 있습니다.</li>
          <li>b를 붙이면 이진 모드로 파일을 엽니다. rb, wb, ab, r+b, w+b, a+b</li>
          <li>이진 모드는 사실 유닉스 계열에선 아무 차이가 없습니다. 윈도우에선 새 줄 문자 처리하는 것만 달라집니다.
            <ul>
              <li>윈도우에서 새줄은 이진데이터로 보면 \r\n 입니다. 그런데 이를 텍스트로 열면 \n 만 나옵니다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>반환은 FILE 포인터입니다.</li>
    </ul>
  </li>
</ul>

<h2 id="181-파일에-쓰기읽기-예-fflush-파일에-이어-쓰기-예">181. 파일에 쓰기/읽기 예, fflush(), 파일에 이어 쓰기 예</h2>

<hr />

<h2 id="182-파일-닫기-파일-오류처리-stderr-strerror-perror">182. 파일 닫기, 파일 오류처리, stderr, strerror(), perror()</h2>

<hr />

<h2 id="183-코드보기--파일-복사하기">183. 코드보기 : 파일 복사하기</h2>

<hr />

<h2 id="184-파일-탐색">184. 파일 탐색</h2>

<hr />

:ET