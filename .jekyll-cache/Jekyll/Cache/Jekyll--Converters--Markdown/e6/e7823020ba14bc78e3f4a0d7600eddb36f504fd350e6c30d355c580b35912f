I"
<p> DB 인덱스에 관해 모든걸 정리하는건 책 한권으로도 힘들 것 같고, 개인적으로 궁금하던 부분들을 위주로 정리해둡니다. Oracle 기준입니다.</p>

<h2 id="인덱스란">인덱스란?</h2>

<hr />

<p> 인덱스란 테이블의 검색을 빠르게 하기위한 DB의 오브젝트입니다. 테이블의 각 컬럼을 기준으로 하나의 컬럼에 대해 인덱스가 만들어 질 수도 있고 여러 열에 대해 하나의 인덱스가 만들어 질 수도 있습니다.</p>

<p> Primary Key나 Unique 제약조건이 달린 컬럼에 대해선 자동으로 인덱스가 생성 됩니다.</p>

<ul>
  <li>B-Tree 인덱스, BITMAP 인덱스, 함수 기반 인덱스, 어플리케이션 도메인 인덱스 등..</li>
  <li>보통 인덱스라고 하면 B tree 인덱스</li>
  <li>하나의 컬럼에 인덱스 생성할 수도 있고, 여러 열에 하나의 인덱스를 생성할 수도 있음.</li>
  <li>PK 컬럼, unique 컬럼은 자동으로 인덱스 생김</li>
  <li></li>
</ul>

<h2 id="인덱스를-사용하면-왜-빠른가">인덱스를 사용하면 왜 빠른가?</h2>

<hr />

<p> 인덱스는 내부적으로 B-Tree 인덱스, BITMAP 인덱스, 함수 기반 인덱스 등 다양하게 구현될 수 있지만, 일반적으로 언급하는 인덱스는 B-Tree (Balanced Tree) 구조를 따르는 인덱스입니다. B-Tree 구조를 기반으로 정리하겠습니다.</p>

<p> DB의 데이터는 ‘데이터 블록’을 단위로 저장이 됩니다. 64비트 운영체제에선 기본 8KB, 32 비트 운영체제에선 기본 4KB입니다. (최소 2KB ~ 최대 64KB로 튜닝할 수도 있습니다.) 이 글에선 설명의 편의상 한 데이터 블록에 5개의 데이터만 들어간다고 가정하겠습니다.</p>

<p><img src="/public/image/etc/data_block.png" alt="data_block.png" /></p>

<p> 위와 같이 한 테이블에 1,000개의 데이터가 id, name 컬럼으로 저장되어 있다고 가정하겠습니다. 한 데이터블록에 5개씩 저장된다고 가정하면 총 200개의 데이터 블록이 필요합니다. 여기서 id = 993의 name을 찾을 때, 인덱스가 없다면 컴퓨터는 차례대로 id를 검사할 수 밖에 없습니다.(이런 식으로 차례대로 모두 검사하는걸 흔히 풀 스캔이라고 합니다.) 198개의 데이터 블록을 모두 검사하고 199번째 데이터블록의 세번째에서 id = 993을 발견하고 name을 읽어 옵니다.</p>

<p><img src="/public/image/etc/b_tree1.png" alt="b_tree1.png" /></p>

<p> 이번엔 테이블의 데이터 블록중 id의 맨 앞의 값들(0, 5, 10, 15…)만 모아놓은 데이터블록이 있다고 가정해봅시다. 200개의 데이터 블록의 대표갑들을 5개씩 모았으니 총 40개의 데이터 블록이 생성될 것입니다. 이 맨앞 id들을 모아놓은 데이터블록을 따라가면 원본 데이터가 있는 데이터 블록에 갈 수 있을때, 위 상황에서 id = 993을 찾으려면 ..</p>

<h2 id="인덱스-사용시-단점">인덱스 사용시 단점</h2>

<hr />

<ul>
  <li>인덱스를 저장할 추가 공간 필요</li>
  <li>처음 인덱스 생성시 시간이 많이 걸림 (대용량 데이터에서 인덱스를 뽑을 때)</li>
  <li>insert, update, delete 작업이 자주 일어나는 경우엔 오히려 성능이 나빠질 수 있음.
    <ul>
      <li>insert 작업을 할때 인덱스 분할 과정이 일어날 수 있음(한 리프 블록이 꽉 찼는데 해당 리프 블록에 새로운 데이터가 들어와야 할때) 인덱스 분할 과정은 DB에게 부하가 큰 작업. 리프 노드만 분할하면 그나마 다행인데 가끔 중간노드를 분할해야 할 때도 있음.</li>
    </ul>
  </li>
</ul>

<h2 id="인덱스-생성-및-조회">인덱스 생성 및 조회</h2>

<hr />

<ul>
  <li>PK컬럼, unique 컬럼 인덱스 자동 생성</li>
  <li>user_indexes 테이블에 인덱스들 보관됨</li>
  <li>USER_INDEXES 테이블에서 INDEX_TYPE == NORMAL이 B-TREE 인덱스라는 거임.</li>
  <li>pk, unique 컬럼으로 만들어진 인덱스는 drop 인덱스로 지우지 못함. 컬럼 속성을 바꿔야 함.</li>
  <li>rowid는 데이터의 실제 물리 주소</li>
  <li>where절에 index를 사용한 열이 나와 있어야 인덱스를 활용해 조회 가능</li>
</ul>

:ET