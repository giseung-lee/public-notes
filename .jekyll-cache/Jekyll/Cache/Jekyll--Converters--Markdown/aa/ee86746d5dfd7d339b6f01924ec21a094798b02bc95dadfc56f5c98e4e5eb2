I"j
<ul>
  <li>본 포스팅은 Ken Krueger 선생님의 <a href="https://www.udemy.com/course/microservices-with-spring-cloud/">Microservices with Spring Cloud</a> 강의를 정리하며 사견을 붙인 것입니다.</li>
  <li>포스팅 내 목차는 개별 동영상 강의 기준입니다.</li>
</ul>

<h2 id="25-api-gateway---part-1---purpose-and-spring-cloud-zuul">25. API Gateway - Part 1 - Purpose and Spring Cloud Zuul</h2>

<hr />

<ul>
  <li>강의를 끝내기 전에 API Gateway에 대해 알아볼 것입니다.
    <ul>
      <li>API Gateway가 왜 필요한지</li>
      <li>Spring Cloud Netflix Zuul</li>
      <li>캐싱</li>
      <li>Resource Expansion</li>
      <li>Protocol Translation</li>
    </ul>
  </li>
</ul>

<h3 id="251-api-gateway가-왜-필요할까요">25.1. API Gateway가 왜 필요할까요</h3>

<ul>
  <li>지금까지 실습을 진행하며 많은 서비스들을 만들었습니다. 이 서비스들을 외부 public internet에 노출하면 어떻게 될까요?
    <ul>
      <li>내부에서만 쓰여야할 api들이 밖으로 노출됩니다. 수정, 삭제 api만 알아내면 외부의 아무 유저나 데이터를 조작할 수 있습니다.</li>
      <li>즉, 보안상 문제가 됩니다.</li>
      <li>또한 CORS(Cross-Origin Resource Sharing) 이슈에도 부딪힙니다.</li>
      <li>그 외에도 여러 문제들이 있습니다.</li>
    </ul>
  </li>
  <li>또한, 현대의 웹에는 클라이언트의 종류도 다양합니다. 웹 브라우저, pc 클라이언트, 모바일 클라이언트, TV, 게임 콘솔 등.. 이런 다양한 종류의 클라이언트에게 적합한 결과를 돌려줘야 합니다.</li>
  <li>위와 같은 문제들 때문에 API Gateway가 등장했습니다.
    <ul>
      <li>내부에서 사용하는 api 외에, 클라이언트가 호출하기 좋은 api를 따로 구성할 수 있습니다.</li>
      <li>내부 api는 내부 api와 api 게이트웨이에서 오는 요청만 처리하고 나머지 요청은 거절하면 됩니다. 보안을 강황할 수 있습니다.</li>
      <li>클라이언트는 api 게이트웨이만 상대하면 되므로 CORS 이슈도 해결할 수 있습니다.</li>
      <li>캐싱도 할 수 있고 프로토콜 변환도 할 수 있고 등등… 이점이 많습니다.</li>
    </ul>
  </li>
  <li>api 게이트웨이를 여러개 둘 수 있고 하나만 둘 수도 있습니다.</li>
</ul>

<h3 id="252-spring-cloud-netflix-zuul">25.2. Spring Cloud Netflix Zuul</h3>

<ul>
  <li>
    <p>Zuul 역시 Netfilx OSS이며 Spring Cloud에서 wrapper api를 만들었습니다.</p>
  </li>
  <li>
    <p>Zuul은 JVM 기반의 라우터이자 로드밸런서입니다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">spring-cloud-starter-zuul</code> 의존성을 추가합니다. 안에 Ribbon과 Hystrix를 포함합니다.</p>
  </li>
  <li>
    <p>어노테이션은 <code class="highlighter-rouge">@EnableZuulProxy</code>만 추가하면 됩니다.</p>
  </li>
  <li>
    <p>Zuul은 다음과 같이 작동합니다.</p>

    <ul>
      <li>Eureka client-id 가 URI로 쓰입니다.
        <ul>
          <li>“subject” 서비스는 “/subject”가 되고 “verb”서비스는 “/verb”가 됩니다.</li>
        </ul>
      </li>
      <li>한 서비스가 여러개 있다면 자동으로 로드밸런서가 작동합니다.</li>
      <li>Hystrix의 서킷 브레이커도 자동으로 작동합니다.</li>
      <li>클라이언트는 “/{service name}” 을 호출하면 됩니다. Zuul이 해당 서비스에 해당하는 서버들 중 가장 빠른 서버를 찾아서 ip와 포트를 설정한뒤 요청해줍니다.</li>
    </ul>
  </li>
  <li>
    <p>zuul.ignored-services에 등록하면 해당 서비스만 제외시킬 수 있습니다.</p>

    <ul>
      <li><code class="highlighter-rouge">zuul.ignored-services: *</code> 를 설정해 모든 주소를 막아놓고 허용할 api만 열수도 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>zuul.prefix를 통해 접미사를 붙일 수 있습니다.</p>
  </li>
  <li>
    <p>아래와 같이 prefix와 ignored-services를 설정할 수 있습니다.</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">\---</span>
<span class="na">zuul</span><span class="pi">:</span>
  <span class="na">prefix</span><span class="pi">:</span> <span class="s">/api</span>
  <span class="na">ignored-services</span><span class="pi">:</span> <span class="s">verb</span>
  <span class="na">routes</span><span class="pi">:</span>
    <span class="na">subject</span><span class="pi">:</span>
      <span class="na">path</span><span class="pi">:</span> <span class="s">/sentence-subject/**</span>
    <span class="na">noun</span><span class="pi">:</span>
      <span class="na">path</span><span class="pi">:</span> <span class="s">/sentence-noun/**</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>클라이언트가 사용할 api는 다음과 같이 구성됩니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Result:
localhost:8080/api/sentence-subject/
              /api/verb/ 👉 ignored
              /api/article/
              /api/adjective/
              :
</code></pre></div>    </div>
  </li>
  <li>
    <p>Zuul 자체로는 다음과 같은 것들은 제공해주지 않습니다.</p>

    <ul>
      <li>캐싱</li>
      <li>프로토콜 변환</li>
      <li>Resource Expansion, Link Resolution</li>
    </ul>
  </li>
</ul>

<h2 id="26-api-gateway---part-2---caching-options">26. API Gateway - Part 2 - Caching Options</h2>

<hr />

<ul>
  <li>MSA에 존재하는 static 데이터들을 다룰 때 캐싱은 매우 중요합니다.</li>
  <li>이미 우리가 구축해 놓은 애플리케이션에서 몇 가지 캐싱 방법을 사용할 수 있습니다.
    <ul>
      <li>사실 우리가 캐싱을 하기 전에, 이미 클라이언트에서 캐싱을 하고 있습니다. 현대의 브라우저는 모두 캐싱을 사용합니다. 하지만, 클라이언트단 캐싱 자체로는 불완전 합니다. 우선 클라이언트단에서 캐싱을 하기 위해선 서버에서 헤더를 잘 정해줘야 하기 때문이죠.</li>
      <li>API 게이트웨이에서 캐싱을 할수도 있고, MSA의 각 서비스 서버에서 캐싱을 할수도 있습니다.</li>
      <li>Spring에서 Caching abstraction을 지원합니다. Cache 메서드를 구현하면 됩니다.</li>
    </ul>
  </li>
</ul>

<h3 id="261-springs-caching-abstraction">26.1. Spring’s Caching Abstraction</h3>

<ul>
  <li>
    <p>Spring의 캐싱을 사용하는건 다음과 같이 <code class="highlighter-rouge">@Cacheable</code> 어노테이션을 추가하면 됩니다. value는 캐시의 이름이고, key는 캐시를 저장할 때 쓸 값입니다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FeignClient</span><span class="o">(</span><span class="n">url</span><span class="o">=</span><span class="s">"localhost:8080/warehouse"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">InventoryClient</span><span class="o">{</span>
	<span class="nd">@Cacheable</span><span class="o">(</span><span class="n">value</span><span class="o">=</span><span class="s">"inventory"</span><span class="o">,</span> <span class="n">key</span><span class="o">=</span><span class="s">"#sku"</span><span class="o">)</span>
	<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/inventory/{sku}"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nd">@ResponseBody</span> <span class="nc">Item</span> <span class="nf">getInventoryItem</span><span class="o">(</span><span class="nd">@PathVariable</span> <span class="nc">Long</span> <span class="n">sku</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>그리고 CacheManager를 정의해줘야 합니다. SynchronizedMaps, EHCache, Gemfire 등을 사용할 수 있습니다.</p>
  </li>
  <li>
    <p>기본적으로 캐싱을 사용하려면 expires나 Etags 같은 태그를 다뤄야 합니다.</p>

    <ul>
      <li>현대의 웹에선 expries보단 Etags를 선호합니다.</li>
    </ul>
  </li>
  <li>
    <p>Etags는 다음과 같이 작동합니다.</p>

    <ul>
      <li>클라이언트가 리소스를 요청합니다.</li>
      <li>서버는 리소스에 Etag를 붙여 건네줍니다. Etag는 ResponseBody를 해시함수로 요약한 것입니다.</li>
      <li>클라이언트는 다음에 같은 리소스를 요청할 때 if-none-match 헤더를 Etag와 같이 보냅니다.</li>
      <li>서버가 현재 Etag와 클라이언트가 보낸 Etag가 맞는지 확인하고 맞으면 304 Not modified를, 다르면 새로운 리소스와 Etag를 200코드와 함께 보내줍니다.</li>
      <li>이건 Shallow Etags의 작동과정이고 Deep Etags는 서버의 일을 더 줄여줍니다만 여기선 패스합니다.</li>
    </ul>
  </li>
</ul>

<h3 id="262-etags-server-side">26.2. Etags Server Side</h3>

<ul>
  <li>
    <p>서버에서 Etags를 사용하는 방법은 다음과 같이 Filter 단에서 작동하게 하는 것입니다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Bean</span>
<span class="kd">public</span> <span class="nc">Filter</span> <span class="nf">shallowEtagHeaderFilter</span><span class="o">(){</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">ShallowEtagHeaderFilter</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>다시한번 말하지만, 이건 shallow Etags입니다. 네트워크의 부하를 줄여주지만 서버의 일은 줄여주지 않습니다. 서버는 어쨌든 Etag가 맞는지 확인하고, 304든 200이든 돌려줘야 하니까요. 단, 304만 돌려줄 경우 네트워크 부하는 줄일 수 있습니다.</p>
  </li>
</ul>

<h3 id="263-etags-client-side">26.3. Etags Client Side</h3>

<ul>
  <li>
    <p>클라이언트에서 Etag를 사용하는 방법은 다음과 같습니다.</p>

    <ul>
      <li>
        <p>아쉽게도 Spring RestTemplate 자체에선 캐싱을 지원하지 않습니다.</p>
      </li>
      <li>
        <p>하지만 Apache HttpClient에서 캐싱을 지원하고, 이를 RestTemplate에 등록할 수 있습니다.(Factory에 등록하는 방식으로..)</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">CacheConfig</span> <span class="n">cacheConfig</span> <span class="o">=</span> <span class="nc">CacheConfig</span><span class="o">.</span><span class="na">custion</span><span class="o">()</span>
	<span class="o">.</span><span class="na">setMaxCacheEntries</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
	<span class="o">.</span><span class="na">setMaxObjectSize</span><span class="o">(</span><span class="mi">8192</span><span class="o">)</span>
	<span class="o">.</span><span class="na">build</span><span class="o">();</span>
    	
<span class="nc">CloseableHttpClient</span> <span class="n">cachingClient</span> <span class="o">=</span> <span class="nc">CachingHttpClients</span><span class="o">.</span><span class="na">custom</span><span class="o">()</span>
	<span class="o">.</span><span class="na">setCacheConfig</span><span class="o">(</span><span class="n">cacheConfig</span><span class="o">)</span>
	<span class="o">.</span><span class="na">build</span><span class="o">();</span>
    	
<span class="nc">RestTemplate</span> <span class="n">template</span> <span class="o">=</span> 
	<span class="k">new</span> <span class="nf">RestTemplate</span><span class="o">(</span>
		<span class="k">new</span> <span class="nf">HttpComponetsClientHttpRequestFactory</span><span class="o">(</span><span class="n">cachingClient</span><span class="o">));</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>RestTemplate와 마찬가지로 Feign 역시 자체적으로 캐싱을 지원하진 않습니다. 이 부분은 고민해보세요 어떻게 쓸지.(선생님도 이제 지친것 같다.)</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="27-api-gateway---part-3---resource-expansion">27. API Gateway - Part 3 - Resource Expansion</h2>

<hr />

<ul>
  <li>Resource Expansion이란건 Resource Link Expansion을 말하며 HATEOS 배울 때 본 것처럼 한 리소스가 관련 리소스로 링크타고 expansion 될 수 있는 걸 말합니다.</li>
</ul>

<h3 id="271-traverson">27.1. Traverson</h3>

<ul>
  <li>
    <p>Traverson은 Spring HATEOAS 프로젝트의 일부입니다.</p>
  </li>
  <li>
    <p>원래는 Node js의 라이브러리로 만들어졌습니다.</p>
  </li>
  <li>
    <p>이름 그대로 링크들을 알아서 traverse 해줍니다.</p>
  </li>
  <li>
    <p>다음 의존성이 필요합니다.</p>

    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework.hateoas<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-hateoas<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
  
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>com.jayway.jsonpath<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>json-path<span class="nt">&lt;/artifactId&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>다음으로 Resource 클래스를 만들어야 합니다. HATEOAS에서 한 것 처럼</p>

    <ul>
      <li>Resource 클래스는 도메인 object의 wrapper입니다.</li>
    </ul>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PlayerResources</span> <span class="kd">extends</span> <span class="nc">Resources</span><span class="o">&lt;</span><span class="nc">Resource</span><span class="o">&lt;</span><span class="nc">Player</span><span class="o">&gt;&gt;{</span>
	<span class="o">:</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>다음으론 Traverson 객체를 만들고 타겟이 될 서비스의 url과 미디어 타입을 입력해줍니다.</p>
  </li>
  <li>
    <p>그리고 traverson 객체에 어떤 링크를 따를 건지 .follow()메서드를 통해 등록하고 traverse 한 결과 어떤 타입을 반환 할 건지 .toObject를 통해 등록합니다.</p>
  </li>
  <li>
    <p>traverson.follow().toObject()로 나온 객체는 Resources&lt;Resource&lt;Player&gt;&gt; 이기 때문에 foreach로 Resource&lt;Player&gt;를 하나씩 집어 원하는 로직을 수행해주면 됩니다.</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Traverson</span> <span class="n">traverson</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Traverson</span><span class="o">(</span>
	<span class="k">new</span> <span class="nf">URI</span><span class="o">(</span><span class="s">"http://localhost:8080/"</span><span class="o">),</span>
	<span class="nc">MediaTypes</span><span class="o">.</span><span class="na">HAL_JSON</span>
<span class="o">);</span>
<span class="nc">PlayerResources</span> <span class="n">playerResources</span> <span class="o">=</span> <span class="n">traverson</span>
	<span class="o">.</span><span class="na">follow</span><span class="o">(</span><span class="s">"$_links.team.href"</span><span class="o">,</span> <span class="s">"$_embedded.team[0]._links.players.href"</span><span class="o">)</span>
	<span class="o">.</span><span class="na">toObject</span><span class="o">(</span><span class="nc">PlayerResources</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Resource</span><span class="o">&lt;</span><span class="nc">Player</span><span class="o">&gt;</span> <span class="n">playerResource</span> <span class="o">:</span> <span class="n">playerResources</span><span class="o">.</span><span class="na">getContent</span><span class="o">()){</span>
	<span class="nc">Player</span> <span class="n">player</span> <span class="o">=</span> <span class="n">playerResource</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span>
	<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">player</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Traverson의 단점입니다.</p>

    <ul>
      <li>Traversal일뿐 Expansion이 아닙니다.</li>
      <li>포맷이 한정적입니다. (Limited capability with other formats)</li>
      <li>xml을 지원하지 않습니다. xml 위주로 어플리케이션을 구성하고 있다면 다른 걸 찾아보세요.</li>
    </ul>
  </li>
</ul>

<h3 id="272-spring-data-rest-projections">27.2. Spring Data REST Projections</h3>

<ul>
  <li>
    <p>Resource Expansion의 다른 방법으론 Spring Data REST Projection이 있습니다.</p>
  </li>
  <li>
    <p>Projection은 링크가 ‘inlined’ 되게 해줍니다.</p>
  </li>
  <li>
    <p>사용법은 다음과 같습니다.</p>

    <ul>
      <li>
        <p><code class="highlighter-rouge">@Projection</code>인 인터페이스를 만들어 줍니다.</p>

        <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Projection</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"inlinePlayers"</span><span class="o">,</span> <span class="n">type</span><span class="o">=</span> <span class="o">{</span><span class="nc">Team</span><span class="o">.</span><span class="na">classe</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">InlinePlayers</span><span class="o">{</span>
	<span class="nc">String</span> <span class="nf">getName</span><span class="o">();</span>
	<span class="nc">String</span> <span class="nf">getLocation</span><span class="o">();</span>
	<span class="nc">String</span> <span class="nf">getMascotte</span><span class="o">();</span>
	<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Player</span><span class="o">&gt;</span> <span class="nf">getPlayers</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>아래와 같이 projection 파라미터에 위의 name을 주면 선수 목록을 보여주게 됩니다.</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://localhost:8080/teams/1?projection=inlinePlayers
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p><code class="highlighter-rouge">/teams/</code>을 요청했다면 다음과 같은 응답이 옵니다.</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
	</span><span class="nl">"name"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Harlem"</span><span class="p">,</span><span class="w">
	</span><span class="nl">"location"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Globetrotters"</span><span class="p">,</span><span class="w">
	</span><span class="nl">"_links"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
		</span><span class="nl">"self"</span><span class="w"> </span><span class="p">:{</span><span class="w">
			</span><span class="nl">"href"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"http://localhost:8080/teams/1{?projection}"</span><span class="p">,</span><span class="w">
			</span><span class="nl">"templated"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
		</span><span class="p">},</span><span class="w">
		</span><span class="nl">"players"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
			</span><span class="nl">"href"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"http://localhost:8080/teams/1/players"</span><span class="w">
		</span><span class="p">}</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>링크를 따라 <code class="highlighter-rouge">/teams/?projection=inlinePlayers</code>를 요청하면 다음과 같은 응답이 옵니다.</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
	</span><span class="nl">"name"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Harlem"</span><span class="p">,</span><span class="w">
	</span><span class="nl">"location"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Globetrotters"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"players"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w">
    	</span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"Dizzu"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"position"</span><span class="p">:</span><span class="s2">"Guard"</span><span class="w">
    </span><span class="p">},{</span><span class="w">
        </span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"Big Easy"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"position"</span><span class="p">:</span><span class="s2">"Showman"</span><span class="w">
    </span><span class="p">},{</span><span class="w">
        </span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"Buckets"</span><span class="p">,</span><span class="w">
        </span><span class="nl">"position"</span><span class="p">:</span><span class="s2">"Guard"</span><span class="w">
    </span><span class="p">}]</span><span class="w">
	</span><span class="nl">"_links"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
		</span><span class="nl">"self"</span><span class="w"> </span><span class="p">:{</span><span class="w">
			</span><span class="nl">"href"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"http://localhost:8080/teams/1{?projection}"</span><span class="p">,</span><span class="w">
			</span><span class="nl">"templated"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
		</span><span class="p">},</span><span class="w">
		</span><span class="nl">"players"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
			</span><span class="nl">"href"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"http://localhost:8080/teams/1/players"</span><span class="w">
		</span><span class="p">}</span><span class="w">
	</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>Projection의 단점은 다음과 같습니다.</p>

    <ul>
      <li>Spring Data REST에서만 작동합니다.</li>
      <li>projection이 같은 마이크로서비스의 일부분이어야 합니다.</li>
    </ul>
  </li>
</ul>

<h2 id="28-api-gateway---part-4---protocol-conversion">28. API Gateway - Part 4 - Protocol Conversion</h2>

<hr />

<ul>
  <li>마지막 주제는 프로토콜 변환입니다.</li>
  <li>많은 서비스들은 각기 다른 프로토콜에 최적화 되어 있을 수 있습니다. 앞서 배운 Bus의 경우 AMQP 서버가 필요했던것 처럼 말입니다.
    <ul>
      <li>다른 프로토콜을 쓰는 서비스 앞에 Adapter를 둘 수도 있긴합니다.</li>
    </ul>
  </li>
  <li>API 게이트웨이는 다양한 프로토콜과 통신할 수 있어야 합니다.</li>
  <li>아쉽게도 만병통치약 같은 방법은 없습니다. 어떤 프로토콜과 통신해야 하는지 확인하고 필요한 프로토콜에 맞게 레퍼런스를 참고해 방법을 찾아야 합니다.</li>
  <li>그래도 많이 사용되는 좋은 툴을 하나 꼽자면 Spring Integration을 꼽을 수 있습니다.</li>
</ul>

<h3 id="281-spring-integration">28.1. Spring Integration</h3>

<ul>
  <li>Spring의 일부이고 in-memory messaging 패턴을 이용해 intergration을 해준다고 합니다.</li>
  <li>Spring Integration은 많은 프로토콜 게이트웨이, 어댑터를 지원합니다.
    <ul>
      <li>AMQP, ATOM, Flat Files, FTP(S), Gemfire, HTTP, JDBC, JMS, JMX, JPA, eMail, Mongo, MQTT, Redis, RMI, SFTP, streams, syslog, TCP, Twitter, UDP, Web Services (SOAP), Web Sockets, XMPP</li>
      <li>정말 많습니다. 전 이거면 될 거 같은데요 선생님..</li>
    </ul>
  </li>
  <li>각 프로토콜을 어떻게 integration 하는지를 보여주는건 너무 길어지니 추상적으로 설명만 해드립니다.</li>
</ul>

<h2 id="29-lab-9---zuul-and-etags">29. Lab 9 - Zuul and Etags</h2>

<hr />

<ul>
  <li>API 게이트웨이 실습</li>
</ul>

<h2 id="30-summary-resources-and-feedback">30. Summary, Resources, and Feedback</h2>

<hr />

<ul>
  <li>지금까지 배운 것들 총 정리</li>
  <li>Microservices 전반</li>
  <li>Spring Boot - Overview, Data, REST - 빠르게 프로젝트 빌드하기</li>
  <li>Spring Cloud - 아래 기술들을 모두 포함하는, 클라우드 환경을 구성하기 위한 기술들
    <ul>
      <li>Config - 중앙화되고 버전관리 가능한 설정 파일 서버</li>
      <li>Bus - 설정 파일 동적 업데이트</li>
      <li>Netflix Eureka - Service Discovery</li>
      <li>Netflix Ribbon - 클라이언트단 로드 밸런서</li>
      <li>Netflix Feign - Declarative REST 클라이언트(선언만 하면 끝난다!)</li>
      <li>Netflix Hystrix - 서킷 브레이커</li>
      <li>Netflix Zuul - API 게이트웨이 만들기</li>
    </ul>
  </li>
  <li>레퍼런스들이 잘 돼있으니 찾아가면서 열심히 해보세요!</li>
</ul>

:ET