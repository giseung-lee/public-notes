I"a%
<h3 id="들어가며">들어가며</h3>

<hr />

<ul>
  <li>HTTP는 다음과 같은 것들을 보장해줍니다.
    <ul>
      <li>객체가 올바르게 식별되어(콘텐츠의 타입이나 언어 등..) 클라이언트가 콘텐츠를 올바르게 처리할 수 있습니다.</li>
      <li>객체는 올바르게 압축이 풀릴 것입니다.</li>
      <li>객체는 항상 최신을 유지할 것입니다.</li>
      <li>사용자의 요구를 만족시킬 것입니다.</li>
      <li>네트워크 사이를 빠르고 효율적으로 이동할 것입니다.</li>
      <li>조작되지 않고 온전히 도착할 것입니다.</li>
    </ul>
  </li>
  <li>위와 같은 사항들을 보장하기 위해 엔터티와 엔터티 헤더들이 사용됩니다.</li>
  <li>이번장에서 배울 내용은 위의 사항을 보장하기 위해 사용되는 것들입니다.
    <ul>
      <li>HTTP 메세지 엔터티의 포맷 및 동작방식</li>
      <li>HTTP가 엔터티 본문크기를 기술하는 방법</li>
      <li>크기를 줄여주는 콘텐츠 인코딩</li>
      <li>컨텐츠의 송수신을 위해 수행되는 전송 인코딩(그 중 청크 인코딩)</li>
      <li>최신 버전을 유지해주기 위한 태그, 라벨, 시간, 체크섬, 검사기, 기타 헤더 필드</li>
      <li>중단된 다운로드를 중간부터 재개할 수 있게 해주는 범위 요청</li>
      <li>전에 본 웹페이지를 열때 변경 있는 부분만 요청 할 수 있는 HTTP 델타 인코딩 확장</li>
      <li>엔터티의 변조를 체크하는 엔터티 본문의 체크섬</li>
    </ul>
  </li>
</ul>

<h3 id="151-메세지는-컨테이너-엔터티는-화물">15.1. 메세지는 컨테이너, 엔터티는 화물</h3>

<hr />

<ul>
  <li>HTTP 메세지가 컨테이너라면 HTTP 엔터티는 그 안의 화물입니다.</li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.0 200 OK
Server : Netscape-Enterprise/3.6
Date : Sun, 17 Sep 2000 00:01:05 GMT
Content-type : text/plain		-- Entity Header
Content-length : 18			-- Entity Header
					-- CRLF : 엔터티 본문 시작 알림
Hi I'm a message			-- Entity Body
</code></pre></div></div>

<ul>
  <li>HTTP/1.1 에선 10가지 주요 엔터티 헤더 필드를 정의했습니다.
    <ul>
      <li>Content-Type : 전달된 객체의 종류, 타입</li>
      <li>Content-Length : 전달되는 메세지의 길이나 크기</li>
      <li>Content-Language : 전달되는 객체와 가장 잘 대응되는 자연어</li>
      <li>Content-Encoding : 객체 데이터의 인코딩 방법</li>
      <li>Content-Location : 요청 시점 기준 객체의 위치</li>
      <li>Content-Range : 해다 엔터티가 부분 엔터티라면 전체의 어느 부분인지</li>
      <li>Content-MD5 : 엔터티 본문 콘텐츠에 대한 체크섬</li>
      <li>Last-Modified : 서버에서 이 콘텐츠가 생성 및 수정된 날</li>
      <li>Expires : 엔터티 데이터가 신선하지 않은 것으로 간주되는 날짜</li>
      <li>Allow : 이 리소스에 어느 요청 메서드가 허용되는지</li>
      <li>ETag : 해당 인스턴스에 대한 고유한 검사기. (엄밀히 말하자면 엔터티 헤더는 아니지만 엔터티와 관련한 중요한 헤더입니다.)</li>
      <li>Cache-Control : 이 문서가 어떻게 캐시되어야 하는지 (역시 엄밀히 말하자면 엔터티 헤더는 아닙니다.)</li>
    </ul>
  </li>
</ul>

<h4 id="1511-엔터티-본문">15.1.1. 엔터티 본문</h4>

<ul>
  <li>엔터티 본문은 가공되지 않은 raw 데이터입니다. 이를 설명해주기 위해 엔터티 헤더가 필요합니다.</li>
  <li>엔터티 본문은 헤더 필드의 끝을 뜻하는 CRLF 줄 바로 다음부터 시작합니다.</li>
</ul>

<h3 id="152-content-length-엔터티의-길이">15.2. Content-Length: 엔터티의 길이</h3>

<hr />

<ul>
  <li>Content-Length는 엔터티 본문의 크기를 바이트 단위로 나타냅니다.</li>
  <li>청크 인코딩으로 전송하지 않는 이상 항상 있어야 합니다.</li>
  <li>메세지가 중간에 잘렸는지 감지할 때, 지속 커넥션 상황에서 메세지 사이를 올바르게 분할하기 위해 필요합니다.</li>
</ul>

<h4 id="1521-잘림-검출">15.2.1. 잘림 검출</h4>

<ul>
  <li>과거의 HTTP는 커넥션이 닫힌 걸로 메세지가 끝난걸 확인했습니다.</li>
  <li>Content-Length가 없다면 메세지를 모두 수신하고 정상적으로 커넥션이 닫혔는지, 비정상적으로 닫혀 메세지가 중간에 끊겼는지 알 수 없습니다.</li>
  <li>캐시가 개입한 상황이라면 캐시는 중간에 잘린 메세지를 캐싱해놓고 계속 클라이언트에게 제공할 수 있습니다.</li>
</ul>

<h4 id="1522-잘못된-content-length">15.2.2. 잘못된 Content-Length</h4>

<ul>
  <li>잘못된 Content-Length를 가지고 있는건 아예 Content-Length가 없는 것보다 심각한 문제를 야기합니다.</li>
  <li>HTTP/1.1 에선 클라이언트 프로그램이 잘못된 Content-Length를 받은 사실을 알게되면 사용자에게 알려주도록 되어 있습니다.</li>
</ul>

<h4 id="1523-content-length와-지속-커넥션persistent-connection">15.2.3. Content-Length와 지속 커넥션(Persistent Connection)</h4>

<ul>
  <li>지속커넥션이 기본이된 현재는 Content-Length가 더욱 필수적입니다.</li>
  <li>한 커넥션으로 여러 메세지가 오가기 때문에 해당 메세지가 언제 끝나는지 알아야 하기 때문입니다.</li>
  <li>다만, 청크 인코딩을 사용할 시엔 Content-Length가 없을 수 있습니다. 청크 인코딩은 15.6.에서 알아볼 것입니다.</li>
</ul>

<h4 id="1524-콘텐츠-인코딩">15.2.4. 콘텐츠 인코딩</h4>

<ul>
  <li>콘텐츠가 인코딩 되어 있다면 Content-Length는 인코딩 된 길이를 나타냅니다.</li>
  <li>간혹 인코딩 전의 Content-Length를 보내는 잘못된 서버도 있으니 주의해야 합니다.</li>
</ul>

<h4 id="1525-엔터티-본문-길이-판별을-위한-규칙">15.2.5. 엔터티 본문 길이 판별을 위한 규칙</h4>

<ul>
  <li>다음은 엔터티 본문의 길이와 끝나는 위치를 판별하는 규칙들입니다. 순서대로 적용되어야 합니다.
    <ol>
      <li>HEAD응답과 같이 본문을 갖는게 금지된 특정 HTTP 메세지에선 Content-Length 헤더가 무시됩니다.</li>
      <li>메세지가 Transfer-Encoding 헤더를 포함한다면, 엔터티는 ‘0 바이트 청크’라고 불리는 특별한 패턴으로 끝나야 하고 Content-Length는 무시해야 합니다.</li>
      <li>메세지에 Transfer-Encoding 헤더가 없고 Content-Length 헤더가 있다면 Content-Length헤더는 본문의 길이를 담습니다.</li>
      <li>메세지가 ‘multipart/byteranges’ 미디어 타입을 사용하고 Content-Length가 없다면 해당 메세지는 각자 스스로 크기를 정의할 것입니다. byterages라는 멀티파트 유형은 자신의 크기를 스스로 정하는 유일한 유형입니다. (수신자가 이를 받아들일 수 있는 능력이 있는지 검증한 후 보내야 합니다.)</li>
      <li>위의 어느 것에도 해당되지 않으면 엔터티는 커넥션이 닫힐 때 끝납니다.</li>
      <li>HTTP/1.0과의 호환을 위해, 엔터티 본문을 갖고 있는 HTTP/1.1 <strong>요청</strong>은 반드시 Content-Length도 갖고 있어야 합니다.</li>
    </ol>
  </li>
</ul>

<h3 id="153-엔터티-요약">15.3. 엔터티 요약</h3>

<hr />

<h3 id="154-미디어-타입과-차셋charset">15.4. 미디어 타입과 차셋(Charset)</h3>

<hr />

<h4 id="1541-텍스트-매체를-위한-문자-인코딩">15.4.1. 텍스트 매체를 위한 문자 인코딩</h4>

<h4 id="1542-멀티파트-미디어-타입">15.4.2. 멀티파트 미디어 타입</h4>

<h4 id="1543-멀티파트-폼-제출">15.4.3. 멀티파트 폼 제출</h4>

<h4 id="1544-멀티파트-범위-응답">15.4.4. 멀티파트 범위 응답</h4>

<h3 id="155-콘텐츠-인코딩">15.5. 콘텐츠 인코딩</h3>

<hr />

<h4 id="1551-콘텐츠-인코딩-과정">15.5.1. 콘텐츠 인코딩 과정</h4>

<h4 id="1552-콘텐츠-인코딩-유형">15.5.2. 콘텐츠 인코딩 유형</h4>

<h4 id="1553-accept-encoding-헤더">15.5.3. Accept-Encoding 헤더</h4>

<h3 id="156-전송-인코딩과-청크-인코딩">15.6. 전송 인코딩과 청크 인코딩</h3>

<hr />

<h4 id="1561-안전한-전송">15.6.1. 안전한 전송</h4>

<h4 id="1562-transfer-encoding-헤더">15.6.2. Transfer-Encoding 헤더</h4>

<h4 id="1563-청크-인코딩">15.6.3. 청크 인코딩</h4>

<h4 id="1564-콘텐츠와-전송-인코딩의-조합">15.6.4. 콘텐츠와 전송 인코딩의 조합</h4>

<h4 id="1565-전송-인코딩-규칙">15.6.5. 전송 인코딩 규칙</h4>

<h3 id="157-시간에-따라-바뀌는-인스턴스">15.7. 시간에 따라 바뀌는 인스턴스</h3>

<hr />

<h3 id="158-검사기와-신선도">15.8. 검사기와 신선도</h3>

<hr />

<h4 id="1581-신선도">15.8.1. 신선도</h4>

<h4 id="1582-조건부-요청과-검사기">15.8.2. 조건부 요청과 검사기</h4>

<h3 id="159-범위-요청">15.9. 범위 요청</h3>

<hr />

<h3 id="1510-델타-인코딩">15.10. 델타 인코딩</h3>

<hr />

<h4 id="15101-인스턴스-조작-델타-생성기-그리고-델타-적용기">15.10.1. 인스턴스 조작, 델타 생성기 그리고 델타 적용기</h4>

<h3 id="마치며">마치며</h3>

<hr />
:ET