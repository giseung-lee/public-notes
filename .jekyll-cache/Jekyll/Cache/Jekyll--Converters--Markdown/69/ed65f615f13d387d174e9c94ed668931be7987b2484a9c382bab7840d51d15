I"~<h3 id="들어가며">들어가며</h3>
<hr />

<h3 id="51-다채로운-웹-서버">5.1. 다채로운 웹 서버</h3>

<p>이번 장에선 웹 서버에 관해 간단하게 알아볼 것입니다.</p>

<p>웹 서버는 기능, 형태, 크기가 정말 다양합니다. 열 줄 짜리 스크립트가 될 수도 있고 50mb짜리 상용 엔진도 있으며, 전자기기 작은 기판에 설치된 서버도 있습니다. 이런 다양한 웹 서버들이 있지만 공통적으로 클라이언트의 HTTP 요청을 받고 처리해 리소스를 돌려주는 일을 합니다.</p>

<h4 id="511-웹-서버-구현">5.1.1. 웹 서버 구현</h4>

<p>웹 서버는 HTTP 프로토콜을 구현해 클라이언트와 통신하며, 웹 리소스를 관리하고 서버 스스로를 관리합니다. 운영체제와 함께 TCP 커넥션 관리에 참여하기도 합니다.</p>

<p>운영체제는 웹 서버가 올라가있는 하드웨어를 관리하고, TCP/IP 네트워크를 지원해주며, 웹 리소스를 관리하기 위한 파일 시스템, 연산활동을 위한 프로세스 관리를 제공합니다.</p>

<h4 id="512-다목적-소프트웨어-웹-서버">5.1.2. 다목적 소프트웨어 웹 서버</h4>

<p>세상엔 수 만개의 웹 서버들이 존재합니다. 하지만 그중 주로 사용되는건 몇 가지에 꼽힙니다. 아래 netcraft에서 조사한 웹 서버 시장 점유율을 보시죠.</p>

<p>그림 요망</p>

<p>출처 : <a href="https://news.netcraft.com/archives/2019/09/27/september-2019-web-server-survey.html">https://news.netcraft.com/archives/2019/09/27/september-2019-web-server-survey.html</a></p>

<p>2019년 8월 까지의 데이터가 담겼는데 아파치 웹 서버의 장기집권이 끝나고 웹 서버의 춘추전국시대가 벌어지는 중인것 같습니다. 하지만 수 만개의 웹 서버중 nginx(32.7%), Apache(29.0%), Microsoft(14.7%)가 전체중 75%가량 차지합니다.</p>

<h4 id="513-임베디드-웹-서버">5.1.3. 임베디드 웹 서버</h4>

<p>임베디드 웹 서버는 전자기기에 내장될 목적으로 만들어진 작원 웹 서버입니다. 공유기를 구입하고 비밀번호 등을 설정하기 위해 공유기 관리자 페이지에 들어가게 되는데 이때 들어가는 웹 페이지는 공유기의 임베디드 웹 서버에서 운영중인 페이지입니다.</p>

<hr />

<h3 id="52-간단한-펄-웹-서버">5.2. 간단한 펄 웹 서버</h3>

<p>가장 많이 알려진 아파치 웹 서버의 코어는 50,000줄이 넘는 코드로 이루어져 있습니다. HTTP/1.1의 기능들을 모두 지원하려면 방대한 양의 코드들이 들어갈 수 밖에 없습니다. 하지만 정말 최소한의 기능만 갖는 웹 서버는 30줄로도 가능합니다. 아래 코드가 Perl 언어로 작성한 30줄 짜리 웹 서버 코드입니다.</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/perl</span>

<span class="k">use</span> <span class="nv">Socket</span><span class="p">;</span>
<span class="k">use</span> <span class="nv">Carp</span><span class="p">;</span>
<span class="k">use</span> <span class="nv">FileHandle</span><span class="p">;</span>

<span class="c1"># (1) 명령줄에서 덮어쓰지 않는 이상 8080 포트를 기본으로 사용한다.</span>
<span class="nv">$port</span> <span class="o">=</span> <span class="p">(</span><span class="nv">@ARGV</span> <span class="p">?</span> <span class="nv">$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="mi">8080</span><span class="p">);</span> 

<span class="c1"># (2) 로컬 TCP소켓을 생성하고 커넥션을 기다리도록(listen) 설정한다.</span>
<span class="nv">$proto</span> <span class="o">=</span> <span class="nb">getprotobyname</span><span class="p">('</span><span class="s1">tcp</span><span class="p">');</span>
<span class="nb">socket</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="nv">PF_INET</span><span class="p">,</span> <span class="nv">SOCK_STREAM</span><span class="p">,</span> <span class="nv">$proto</span><span class="p">)</span> <span class="o">||</span> <span class="nb">die</span><span class="p">;</span>
<span class="nb">setsockopt</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="nv">SOL_SOCKET</span><span class="p">,</span> <span class="nv">SO_REUSEADDR</span><span class="p">,</span> <span class="nb">pack</span><span class="p">("</span><span class="s2">l</span><span class="p">",</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="nb">die</span><span class="p">;</span>
<span class="nb">bind</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="nv">sockaddr_in</span><span class="p">(</span><span class="nv">$port</span><span class="p">,</span> <span class="nv">INADDR_ANY</span><span class="p">))</span> <span class="o">||</span> <span class="nb">die</span><span class="p">;</span>
<span class="nb">listen</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="nv">SOMAXCONN</span><span class="p">)</span> <span class="o">||</span> <span class="nb">die</span><span class="p">;</span>

<span class="c1"># (3) 시작 메세지를 출력한다.</span>
<span class="nb">printf</span><span class="p">("</span><span class="s2"> &lt;&lt;&lt;Type-O-Serve Accepting on Port %d&gt;&gt;&gt;</span><span class="se">\n\n</span><span class="p">",</span><span class="nv">$port</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
 <span class="c1"># (4) 커넥션 C를 기다린다.</span>
 <span class="nv">$cport_caddr</span> <span class="o">=</span> <span class="nb">accept</span><span class="p">(</span><span class="nv">C</span><span class="p">,</span> <span class="nv">S</span><span class="p">);</span>
 <span class="p">(</span><span class="nv">$cport</span><span class="p">,</span><span class="nv">$caddr</span><span class="p">)</span> <span class="o">=</span> <span class="nv">sockaddr_in</span><span class="p">(</span><span class="nv">$cport_caddr</span><span class="p">);</span>
 <span class="nv">C</span><span class="o">-&gt;</span><span class="nv">autoflush</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

 <span class="c1"># (5) 누구로부터의 커넥션인지 출력한다.</span>
 <span class="nv">$cname</span> <span class="o">=</span> <span class="nb">gethostbyaddr</span><span class="p">(</span><span class="nv">$caddr</span><span class="p">,</span><span class="nv">AF_INET</span><span class="p">);</span>
 <span class="nb">printf</span><span class="p">("</span><span class="s2"> &lt;&lt;&lt;Request From '%s'&gt;&gt;&gt;</span><span class="se">\n</span><span class="p">",</span><span class="nv">$cname</span><span class="p">);</span>

 <span class="c1"># (6) 빈 줄이 나올 때까지 요청 메세지를 읽어서 화면에 출력한다.</span>
<span class="nv">screen</span>
 <span class="k">while</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nv">C</span><span class="o">&gt;</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="k">print</span> <span class="nv">$line</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=~</span> <span class="sr">/^\r/</span><span class="p">)</span> <span class="p">{</span> <span class="k">last</span><span class="p">;</span> <span class="p">}</span>
 <span class="p">}</span>

 <span class="c1"># (7) 응답 메세지를 위한 프롬프트를 만들고, 응답줄을 입력 받는다.</span>
 <span class="c1"># "." 하나만으로 되어 있는 줄이 입력되기 전까지, 입력된 줄을 클라이언트에게 보낸다.</span>
 <span class="nb">printf</span><span class="p">("</span><span class="s2"> &lt;&lt;&lt;Type Response Followed by '.'&gt;&gt;&gt;</span><span class="se">\n</span><span class="p">");</span>

 <span class="k">while</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=</span> <span class="o">&lt;</span><span class="bp">STDIN</span><span class="o">&gt;</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="nv">$line</span> <span class="o">=~</span> <span class="sr">s/\r//</span><span class="p">;</span>
     <span class="nv">$line</span> <span class="o">=~</span> <span class="sr">s/\n//</span><span class="p">;</span>
     <span class="k">if</span> <span class="p">(</span><span class="nv">$line</span> <span class="o">=~</span> <span class="sr">/^\./</span><span class="p">)</span> <span class="p">{</span> <span class="k">last</span><span class="p">;</span> <span class="p">}</span>
     <span class="k">print</span> <span class="nv">C</span> <span class="nv">$line</span> <span class="o">.</span> <span class="p">"</span><span class="se">\r\n</span><span class="p">";</span>
 <span class="p">}</span>
 <span class="nb">close</span><span class="p">(</span><span class="nv">C</span><span class="p">);</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>이 펄 서버는 ‘type-o-serve’라고 이름 붙인 펄 프로그램 입니다. HTTP 요청이 오면 콘솔창에 받은 요청이 출력되고, 콘솔에 타이핑한 텍스트가 HTTP 응답으로 전송되는 간단한 서버입니다. 코드가 간단하고 책에서 단계별로 주석도 잘 적어주셨기 때문에 쉽게 이해할 수 있을 것입니다.</p>

<hr />

<h3 id="53-진짜-웹-서버가-하는-일">5.3. 진짜 웹 서버가 하는 일</h3>

<p>상용 웹 서버는 위의 펄 서버와 비교할 수 없을 만큼 다양한 일을 합니다. 하지만 모든 웹 서버가 하는 일은 아래와 같은 과정을 따른다고 할 수 있습니다.</p>

<ol>
  <li>커넥션을 맺는다 : 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.</li>
  <li>요청을 받는다 : HTTP 요청 메세지를 네트워크로부터 읽어 들인다.</li>
  <li>요청을 처리한다 : 요청 메세지를 해석하고 행동을 취한다.</li>
  <li>리소스에 접근한다 : 메세지에서 지정한 리소스에 접근한다.</li>
  <li>응답을 만든다 : 올바른 헤더를 포함한 HTTP 응답 메세지를 생성한다.</li>
  <li>응답을 보낸다 : 응답을 클라이언트에게 돌려준다.</li>
  <li>트랜잭션을 로그로 남긴다 : 로그 파일에 트랜잭션 완료에 대한 기록을 남긴다.</li>
</ol>

<p>뒤로는 각 단계들에 대해 살펴보겠습니다.</p>

<hr />

<h3 id="54-단계1--클라이언트-커넥션-수락">5.4. 단계1 : 클라이언트 커넥션 수락</h3>

<p>한 클라이언트에 대해 이미 커넥션이 열려있다면 그 커넥션을 계속 사용할 수 있지만, 새로운 클라이언트가 연결을 요청한다면 새 커넥션을 열 필요가 있습니다.</p>

<h4 id="541-새-커넥션-다루기">5.4.1. 새 커넥션 다루기</h4>

<p>클라이언트가 TCP 커넥션 요청을 보내오면 서버는 커넥션을 수락하고 커넥션에서 IP를 추출해 상대방이 어떤 클라이언트인지 확인합니다.(이런 TCP 커넥션들을 소켓이라고 부릅니다.) 새 커넥션이 생성되고 받아들여지면 서버는 새 커넥션을 커넥션 목록에 추가하고 데이터를 받을 준비를 합니다.</p>

<p>웹 서버는 어떤 커넥션이든 마음대로 거절하거나 닫을 수 있습니다. 금지할 IP 주소나 호스트명을 미리 정해두면 여기서 오는 모든 커넥션을 거절할 수 있습니다.</p>

<h4 id="542-클라이언트-호스트-명-식별">5.4.2. 클라이언트 호스트 명 식별</h4>

<p>서버가 특정 호스트명의 접근을 막거나 로그를 남길때 어디서 온 로그인지 보기쉽게 남겨야할 필요가 있습니다. 이때 서버는 reverse DNS 를 이용해 클라이언트의 IP를 호스트명으로 변환할 수 있습니다. 이 작업을 Hostname Lookup 이라고 합니다.</p>

<p>하지만 이 작업은 시간이 꽤 걸리는 작업이라 트랜잭션을 지연시킬 수 있습니다. 따라서 이 작업은 서버에 따라 꺼두기도 하고 특정 리소스에 대해서만 켜기도 합니다.</p>

<pre><code class="language-Apache">HostnameLookups off
&lt;File ~ "\.(html|htm|cgi)$"&gt;
	HostnameLookups on
&lt;/File&gt;
</code></pre>

<p>위 코드는 아파치에서 html, htm, cgi 리소스들만 Hostname Lookup을 실시하고 나머지는 하지 않는다는 설정 코드입니다.</p>

<h4 id="543-ident를-통해-클라이언트-사용자-알아내기">5.4.3. ident를 통해 클라이언트 사용자 알아내기</h4>

<p>클라이언트를 식별하는 방법엔 ident 프로토콜을 사용하는 방법도 있습니다. 간단히 설명하자면 클라이언트 식별을 위한 전용 커넥션을 생성하고 요청, 응답해 클라이언트를 식별하는 방법입니다. 과정은 다음과 같습니다.</p>

<p>그림 요망</p>

<ol>
  <li>클라이언트가 HTTP 커넥션을 요청합니다.</li>
  <li>서버는 클라이언트의 커넥션 요청을 받아들입니다.</li>
  <li>서버는 클라이언트의 ident 서버 포트(113번으로 정해져있으며 처음 클라이언트가 요청할때 사용한 포트와 다른 포트입니다.)로 커넥션을 요청합니다.</li>
  <li>클라이언트가 커넥션을 받아들이면 서버가 사용자를 식별할 요청을 보냅니다.</li>
</ol>

<p>사내 망에선 종종 사용되지만 공공 인터넷에선 다음과 같은 이유로 사용이 되지 않습니다.</p>

<ol>
  <li>클라이언트가 ident 프로토콜을 지원해야 합니다.</li>
  <li>HTTP 트랜잭션을 지연시킵니다.</li>
  <li>방화벽에서 서버의 ident 커넥션 요청이 막힐 수도 있습니다.</li>
  <li>ident 프로토콜은 가상 IP 주소를 잘 지원하지 않습니다.</li>
  <li>프라이버시 침해의 우려도 있습니다.</li>
</ol>

<hr />

<h3 id="55-단계2--요청-메세지-수신">5.5. 단계2 : 요청 메세지 수신</h3>

<p>커넥션을 맺은 뒤에 서버는 데이터가 오길 기다립니다. 커넥션에 데이터가 들어오면 앞 장에서 살펴본 HTTP 메세지의 구성을 고려해 데이터를 HTTP 메세지로 파싱합니다.</p>

<ul>
  <li>요청 메서드, URI, 버전번호를 파싱합니다. 각 값은 공백으로 분리되어 있고 요청줄의 끝은 CRLF로 끝납니다.</li>
  <li>헤더들을 파싱합니다. 각 헤더는 CRLF로 끝납니다.</li>
  <li>헤더의 끝을 의미하는 CRLF 끝나는 빈줄을 찾아 헤더 파싱을 끝냅니다.</li>
  <li>이후 엔터티 본문이 있다면 읽어 들입니다.(이때, 헤더에 Content-Length가 있다면 그만큼 읽어냅니다.)</li>
</ul>

<p>IP패킷들은 순서와 상관없이 불규칙하게 전달됩니다. 따라서 웹 서버는 파싱 가능할때까지 IP패킷의 데이터들을 메모리에 임시 저장해 놓을 수 있어야 합니다.</p>

<h4 id="551-메세지의-내부-표현">5.5.1. 메세지의 내부 표현</h4>

<p>웹 서버에 따라 요청 메세지를 다루기 쉽게 따로 자료 구조를 만들어 저장합니다.</p>

<h4 id="552-커넥션-입력출력-처리-아키텍처">5.5.2. 커넥션 입력/출력 처리 아키텍처</h4>

<p>포털 사이트 같이 사용자가 많은 웹 서버들은 그 많은 사용자와 하나 이상의 커넥션을 맺고 있습니다. 어떤 사용자는 10초에 한 번씩 요청을 보내고 어떤 사용자는 1초에 한 번씩 보냅니다. 그리고 어떤 사용자는 웹 크롤러를 사용해 1초에 10번씩 요청을 보냅니다.</p>

<p>이렇게 많은 사용자들의 커넥션들을 효율적으로 처리하기 위해 커넥션 입/출력 처리 기술도 발전해 왔습니다.</p>

<p><strong>단일 스레드 웹 서버</strong></p>

<p>처음은 단일 스레드 웹 서버였을 것입니다. 한 번에 하나의 커넥션만 처리하는 단일 스레드 웹 서버는 당연히 성능이 형편 없어 테스트 및 교육용이나 임베디드 서버 같은 극히 일부의 서버에서만 사용됩니다.</p>

<p><strong>멀티프로세스와 멀티스레드 웹 서버</strong></p>

<p>여러 요청을 동시에 처리하기 위해 멀티프로세스/스레드 서버가 사용됩니다. 프로세스/스레드는 필요할때마다 생성할 수도 있고 미리 만들어 놓고 기다릴 수도 있습니다.</p>

<p>각각 커넥션 마다 프로세스/스레드를 할당 할 수 있지만 이렇게 된다면 너무 많은 메모리를 낭비하게 될 것입니다. 멀티프로세스/스레드를 사용하는 웹 서버들은 프로세스/스레드 수에 제한을 걸어 놓습니다.</p>

<p><strong>다중 I/O 서버</strong></p>

<p>방금 설명한 멀티프로세스/스레드 서버는 단일 스레드보단 좋지만 한계가 있습니다. 하나의 커넥션이 생성되었지만 실제로 그 커넥션에 들어오는 요청이 없더라도 프로세스/스레드는 그 커넥션을 보면서 데이터가 오길 기다려야하기 때문입니다. 이를 해결하기 위한 방법이 입출력 다중화(multiplexing)입니다.</p>

<p>하나의 커넥션은 ‘입력 -&gt; 처리 -&gt; 출력’ 으로 동작한다고 볼 수 있습니다. 그런데 처리중엔 입력, 출력에서 쓰이는 함수가 봉쇄(block) 됩니다. #@$#@$@#$ 추가 설명 필요</p>

<p><strong>다중 멀티스레드 웹 서버</strong></p>

<hr />

<h3 id="56-단계3--요청-처리">5.6. 단계3 : 요청 처리</h3>

<p>요청을 처리하는 과정은 뒷 장들에서 나올 주제중 대부분이기 때문에 이번 장에선 생략하겠습니다.</p>

<hr />

<h3 id="57-단계4--리소스의-매핑과-접근">5.7. 단계4 : 리소스의 매핑과 접근</h3>

<p>웹 서버는 리소스를 주고 받게 해주는 서버입니다. 이 리소스에는 이미지 파일, html 페이지 같은 고정된 리소스도 있지만 php, jsp, asp와 같이 리소스 생성 어플리케이션을 통해 만들어지는 동적인 리소스도 있습니다.</p>

<p>웹 서버가 리소스를 알맞게 제공하기 위해선 클라이언트의 요청 URI에서 그에 맞는 리소스나 리소스 생성기를 찾아야 합니다. 이런 과정을 리소스 맵핑이라고 합니다.</p>

<h4 id="571-docroot">5.7.1. Docroot</h4>

<p>리소스 맵핑의 가장 단순한 형태는 URI로 파일 자체를 가리키는 것입니다. 그런데 그 파일들은 어느 디렉토리에 위치해 있을까요?</p>

<p>스프링 프레임워크를 사용해 보았다면 클라이언트는 ‘WebContent’ 폴더 안에 있는 것들만 접근 할 수 있다라는 얘기를 많이 들어보셨을 것입니다. 이렇게 일반적으로 웹 서버 파일 시스템의 특별한 폴더를 웹 리소스를 올려두기 위해 예약해둡니다. 이 폴더를 문서 루트, docroot 라고 부릅니다.</p>

<p>웹 서버는 URI에서 호스트명 뒤의 리소스 경로를 가져와 docroot 뒤에 붙입니다. 아래와 같은 요청이 왔다고 하면</p>

<blockquote>
  <p>요청 URI : http://www.joes-hardware.com/specials/saw-blade.gif
리소스 경로 : /specials/saw-blade.gif</p>
</blockquote>

<p>웹 서버의 docroot에 따라 docroot/specials/saw-blade.gif 리소스를 찾아 갑니다.</p>

<p>이 docroot는 사용하는 웹 서버에서 기본적으로 설정해 두기도 하고 따로 설정 파일을 통해 docroot를 지정할 수도 있습니다. 많이 사용하는 아파치 웹 서버의 경우 httpd.conf 파일에 아래와 같은 줄을 추가해 설정할 수 있습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DocumentRoot /usr/local/httpd/files
</code></pre></div></div>

<p>웹 서버는 상대 URL이 docroot를 벗어나 파일 시스템의 다른 부분을 가리킬 수 없게 조심해야 합니다. 예를들어 다음과 같이 docroot의 상위 디렉토리를 찾는 요청이 왔다고 해서 실제 docroot의 상위 디렉토리를 찾아가면 안됩니다.</p>

<blockquote>
  <p>http://www.joes-hardware.com/../</p>
</blockquote>

<p><strong>가상 호스팅된 docroot</strong></p>

<p>가상 호스팅은 하나의 물리적 웹 서버에 여러 도메인을 호스팅 하는 것입니다. 가상 호스팅 환경에선 호스팅된 각각의 서버마다 분리된 docroot를 설정해줍니다. 설정은 매우 간단합니다. 많이 사용되는 아파치의 경우 아래와 같이 설정 됩니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost www.joes-hardware.com&gt;
	ServerName www.joes-hardware.com
	DocumentRoot /docs/joe
	TransferLog /logs/joe.access_log
	ErrorLog /logs/joe.error_log
&lt;/VirtualHost&gt;

&lt;VirtualHost www.marys-antiques.com&gt;
	ServerName www.marys-antiques.com
	DocumentRoot /docs/mary
	TransferLog /logs/mary.access_log
	ErrorLog /logs/mary.error_log
&lt;/VirtualHost&gt;
</code></pre></div></div>

<p>가상 호스팅에 대해선 18장에서 더 자세히 이어집니다.</p>

<p><strong>사용자 홈 디렉터리 docroots</strong></p>

<p>docroots를 활용하면 사용자들이 한 대의 웹 서버에서 각자 자신의 웹 사이트를 만들 수 있습니다. ‘/~’ 뒤에 이름이 오는 것으로 시작하는 URI들이 그 예입니다.</p>

<blockquote>
  <p>요청 메세지A : GET /~bob/index.html HTTP/1.0
-&gt; 가리키는 리소스 : /home/bob/public_html</p>

  <p>요청 메세지B : GET /~betty/index.html HTTP/1.0
-&gt; 가리키는 리소스 : home/betty/public_html</p>
</blockquote>

<h4 id="572-디렉터리-목록">5.7.2. 디렉터리 목록</h4>

<p>URL은 리소스 파일을 가리키는게 아니라 디렉터리 자체를 가리킬 수도 있습니다. 이를 디렉터리 URL 이라고 합니다. 대부분 웹 서버는 디렉터리 URL 요청을 받았을때 다음과 같은 행동을 취합니다.</p>

<ul>
  <li>에러를 반환</li>
  <li>디렉터리 대신 특별한 ‘색인 파일’을 반환</li>
  <li>디렉터리를 탐색한 뒤 그 내용을 담은 HTML 페이지를 반환</li>
</ul>

<p>대부분의 웹 서버는 디렉터리 URL을 받으면 해당 디렉터리 안의 ‘index.html’  혹은 ‘index.htm’ 파일을 찾습니다. 그리고 그 파일이 존재한다면 반환합니다.</p>

<p>아파치 웹 서버에선 이렇게 디렉터리 URL이 왔을때 기본적으로 찾을 파일의 이름 집합을 설정할 수 있습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DirectoryIndex index.html index.htm home.html home.htm index.cgi
</code></pre></div></div>

<p>위와 같이 설정하면 나열된 순서대로 파일을 찾아보고 나온다면 그 파일을 반환합니다.</p>

<p>그런데 만약 기본 색인 파일을 찾을 수 없다면 어떻게 할까요? 많은 웹 서버는 요청받은 디렉터리 안의 파일들의 크기, 변경일, 파일에 대한 링크 등을 열거한 HTML 파일을 반환합니다. 하지만 이 방식은 클라이언트에게 숨겨야 할 파일도 노출할 수 있으니 조심해야 합니다.</p>

<p>아파치 웹 서버에선 다음과 같은 설정으로 디렉터리 색인 파일 자동 생성을 끌 수 있습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Options -Indexes
</code></pre></div></div>

<h4 id="573-동적-콘텐츠-리소스-매핑">5.7.3. 동적 콘텐츠 리소스 매핑</h4>

<p>웹 서버는 URI를 동적 리소스에 맵핑할 수도 있습니다. 웹 서버중 웹 어플리케이션 서버(WAS, Web Application Server)라고 불리는 것들은 웹 서버와 백엔드 어플리케이션을 연결해줍니다.</p>

<p>국내에서 많이 사용되는 기술 스택인 ‘아파치 - 톰캣 - 자바 서블릿’이 이런 동적 콘텐츠 맵핑의 하나라고 볼 수 있습니다.</p>

<p>아파치에서 URI에 따라 프로그램의 경로를 맵핑 시킬 수 있습니다. 다음 아파치 설정을 보겠습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ScriptAlias /cgi-bin/ /usr/local/etc/httpd/cgi-programs/
</code></pre></div></div>

<p>위 설정은 URI 경로가 ‘/cgi-bin/’ 으로 시작한다면, ‘/usr/local/etc/httpd/cgi-programs/’ 에서 프로그램을 찾아 실행하라는 의미 입니다. 여기에 덧붙여</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AddHandler cgi-script .cgi
</code></pre></div></div>

<p>위와 같은 설정을 추가해 특정 확장자의 파일만 실행 되도록 설정할 수 있습니다. 위 설정은 ‘.cgi’ 로 끝나는 모든 웹 리소스는 실행되어야 함을 명시하는 것입니다.</p>

<p>CGI는 서버사이드 어플리케이션을 실행하기 위한 간단한 인터페이스인데 웹의 초창기에 많이 사용되었습니다. CGI 자체는 Common Gateway Interface로 웹 서버와 웹 어플리케이션 서버간 데이터를 주고받는데 도움을 주는 인터페이스입니다. 이 CGI를 따라 작성된 프로그램을 CGI 프로그램이라고 합니다.</p>

<p>오늘날엔 asp, jsp 같은 애플리케이션 서버가 cgi를 대체하고 있습니다.</p>

<h4 id="574-서버사이드-인클루드server-side-includes-ssi">5.7.4. 서버사이드 인클루드(Server-Side Includes, SSI)</h4>

<p>서버사이드 인클루드는 서버가 생성하거나 가지고 있는 HTML 파일을 클라이언트에게 보내기 직전에 html 안에 있던 변수 값들을 치환하는 것을 말합니다.</p>

<p>SSI를 가지고 있는 html파일은 대부분 ‘.shtml’ 이라는 확장자가 붙습니다.</p>

<p>자바 스택을 이용해 웹 페이지를 만들어 보았다면 jsp 페이지에</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;% include file="/css/bootstrap.css" %&gt; 
</code></pre></div></div>

<p>이런 &lt;% ~~ %&gt; 태그를 본적이 있을 것입니다. 이런 태그들이 클라이언트에게 보내지기 직전에 치환되는 변수들이며 이런 과정을 SSI라고 합니다.</p>

<p>많은 웹 서버가 이 SSI를 지원합니다. 동적 컨텐츠를 만들 수 있는 쉬운 방법중 하나입니다.</p>

<h4 id="575-접근-제어">5.7.5. 접근 제어</h4>

<p>웹 서버는 각 리소스에 접근 제어를 설정할 수도 있습니다. 접근이 제어된 리소스에 요청이 올 경우 웹 서버는 클라이언트의 IP에 근거해 접근을 제어하던가, 리소스에 접근하기 위한 비밀번호를 물어보던가 등을 할 수 있습니다.</p>

<hr />

<h3 id="58-단계5--응답-만들기">5.8. 단계5 : 응답 만들기</h3>

<p>요청을 받았다면 응답을 해야 합니다.</p>

<h4 id="581-응답-엔터티">5.8.1. 응답 엔터티</h4>

<p>응답 메세지에 엔터티 본문이 있다면, 응답 메세지엔 다음과 같은 것들이 포함되어야 합니다.</p>

<ul>
  <li>응답 본문의 MIME 타입을 서술하는 Content-Type 헤더</li>
  <li>응답 본문의 길이를 서술하는 Content-Length 헤더</li>
  <li>실제 응답 본문</li>
</ul>

<h4 id="582-mime-타입-결정하기">5.8.2. MIME 타입 결정하기</h4>

<p>웹 서버는 응답 본문의 MIME 타입을 결정해야 하는 책임이 있습니다. MIME 타입을 결정하는 방법엔 다음과 같은 것들이 있습니다.</p>

<p><strong>mime.types</strong>
 파일 이름의 확장자를 사용하는 방법입니다. 확장자를 그대로 사용하는 것은 아니고, 웹 서버별로 확장자별 MIME 타입이 담겨 있는 파일을 탐색해 확장자에 맞는 MIME 타입을 맵핑해 줍니다. 가장 흔히 쓰이는 방법입니다.</p>

<p><strong>매직 타이핑(Magic Typing)</strong>
 한편, 확장자가 없는 파일이 있을 수도 있습니다. 아파치 웹 서버에선 파일의 내용을 검사해 특정 패턴을 추출할 수 있습니다. 이 패턴을 매직 파일(패턴과 MIME 타입을 맵핑해주는 테이블)에 맵핑해 MIME 타입을 찾아냅니다.</p>

<p><strong>유형 명시(Explicit typing)</strong>
 특정 파일 혹은 특정 디렉토리 안의 파일들을 파일 확장자나 내용에 상관 없이 어떤 MIME 타입을 갖도록 명시할 수도 있습니다.</p>

<p><strong>유형 협상(Type negotiation)</strong>
 한 리소스가 여러 MIME 타입에 맵핑 될 수도 있습니다. 이때 웹 서버가 협상 과정을 통해 사용하기 가장 좋은 MIME 타입을 판별해 설정할 수도 있습니다.</p>

<h4 id="583-리다이렉션">5.8.3. 리다이렉션</h4>

<p>웹 서버는 성공 대신 리다이렉션을 응답하기도 합니다. 리다이렉션이 사용되는 경우는 다음과 같습니다.</p>

<p><strong>영구히 리소스가 옮겨진 경우</strong>
 리소스의 위치가 옮겨지거나 이름이 바뀌었을 수 있습니다. 이때 웹 서버는 클라이언트에게 리소스의 URL이 바뀌었으니 북마크를 새로 갱신하라고 말해줄 수 있습니다. 이때 ‘301 Moved Permanently’ 코드가 사용됩니다.</p>

<p><strong>임시로 리소스가 옮겨진 경우</strong>
 리소스가 영구히 옮겨진게 아니라 잠시 옮겨지거나 이름이 변경될 수도 있습니다. 이때, 리다이렉션은 필요하지만 방금 전 처럼 북마크를 갱신할 필요는 없습니다. 이럴땐 ‘303 See Other’ 이나 ‘307 Temporary Redirect’ 코드가 사용됩니다.</p>

<p><strong>URL 증강</strong>
 서버는 문맥 정보를 포함시키기 위해 재작성된 URL로 리다이렉션 시키기도 합니다. 그러면 클라이언트는 다시 작성된 fat URL을 따라 다시 요청 합니다. 이때도 ‘303 See Other’이나 ‘307 Temporary Redirect’ 코드가 사용됩니다.</p>

<p><strong>부하 균형</strong>
 과부하된 서버가 요청을 받으면 부하가 덜 걸린 서버로 리다이렉션 시킬수도 있습니다. 이때도 ‘303 See Other’이나 ‘307 Temporary Redirect’ 코드가 사용됩니다.</p>

<p><strong>친밀한 다른 서버가 있을 때</strong>
 웹 서버들은 사용자에 대한 정보를 가지고 있을 수 있습니다. 한 서버가 요청을 받았을때, 클라이언트의 정보를 가지고 있는 서버로 리다이렉션 시킬 수 있습니다. 이때도 ‘303 See Other’이나 ‘307 Temporary Redirect’ 코드가 사용됩니다.</p>

<p><strong>디렉터리 이름 정규화</strong>
 클라이언트가 디렉터리 이름에 대해 URI 요청을 하는데 ‘/’를 바뜨렸다면, 대부분의 웹 서버는 클라이언트를 ‘/’를 추가한 새로운 URI로 리다이렉션 시킵니다.</p>

<hr />

<h3 id="59-단계6--응답-보내기">5.9. 단계6 : 응답 보내기</h3>

<p>대게 한 서버는 여러 클라이언트를 상대하며 여러 커넥션을 가지고 있습니다. 그중 어떤 커넥션은 놀고 있을 수 있고 어떤 커넥션은 데이터를 보내고 있으며 어떤 커넥션은 데이터를 받고 있을 수도 있습니다.</p>

<p>요청을 받을때와 마찬가지로 응답을 보낼때도 커넥션 상태들을 추적해 효율적으로 전송해야 합니다. 특히, 비지속 커넥션은 응답을 보낸뒤에 바로 커넥션을 닫으면 되기 때문에 비교적 간단하지만 지속 커넥션의 경우 더 주의해야 합니다.</p>

<hr />

<h3 id="510-단계7--로깅">5.10. 단계7 : 로깅</h3>

<p>트랜잭션이 완료되면 트랜잭션의 수행 결과를 로그 파일에 기록합니다. 대부분의 웹 서버는 기본적으로 제공하는 로깅 방식과 설정들이 있습니다.</p>

<hr />

<h3 id="마치며">마치며</h3>

<p>매 장을 읽으면 그동안 머릿속에 자유롭게 돌아다니던 지식의 조각들이 제 자리를 찾아가는 것을 느낍니다. ‘How to use’를 알고 있던 것들이 ‘How it works’와 연결되는 과정이 즐겁습니다.</p>
:ET