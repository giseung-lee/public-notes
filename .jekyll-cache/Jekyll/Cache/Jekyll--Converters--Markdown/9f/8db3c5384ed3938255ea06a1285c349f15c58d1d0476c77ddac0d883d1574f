I"J
<h2 id="224-메모리의-종류">224. 메모리의 종류</h2>

<hr />

<ul>
  <li>
    <p>컴퓨터는 다양한 하드웨어로 구성되어 있습니다. 그 중 가장 중요한 부품 2가지가 있다면 CPU와 메모리입니다.</p>
  </li>
  <li>
    <p>CPU</p>

    <ul>
      <li>모든 코드의 로직(연산)을 실행하는 제어 장치</li>
      <li>컴퓨터의 핵심 두뇌</li>
      <li>CPU안에도 레지스터라고 불리는 작고 빠른 저장공간이 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>메모리</p>

    <ul>
      <li>실행 중인 코드 및 연산의 중간 결과 등을 저장하는 공간</li>
      <li>변수, 배열 등 대입되는 데이터가 저장됩니다.</li>
      <li>컴퓨터의 공책, 메모장과 같은 역할입니다.</li>
      <li>메모리도 중요한 2가지를 뽑을 수 있습니다. (외에 데이터 섹션, 코드 섹션 등이 있습니다.)
        <ul>
          <li>스택 메모리</li>
          <li>힙 메모리</li>
        </ul>
      </li>
      <li>스택 메모리, 힙 메모리는 물리적으로는 같은 메모리입니다.</li>
      <li>기본은 힙 메모리입니다. 힙 메모리가 조금 더 범용적인 형태입니다. 내어 달라고 하면 운영체제가 내어줍니다.</li>
      <li>스택 메모리는 프로그램마다(엄밀히 말하면 프로그램의 스레드 마다) 떼어준 메모리입니다.</li>
    </ul>
  </li>
</ul>

<h2 id="225-스택-메모리">225. 스택 메모리</h2>

<hr />

<ul>
  <li>스택 메모리는 앞에서 많이 봤습니다. 모른다면 전 강의를 복습..</li>
  <li>스택 메모리에 대해 더 알고 싶으면 <strong>함수 호출 규약(calling convention)</strong>에 대해 더 알아보시길 바랍니다.</li>
  <li>컴파일러마다 따르는 calling convention이 있는데 이 규약에 따라 스택 메모리에서 메모리를 어떻게 주고 받고, 돌아가는 지 달라집니다.</li>
</ul>

<h2 id="226-레지스터">226. 레지스터</h2>

<hr />

<ul>
  <li>레지스터는 CPU에 있습니다. 메모리 아닙니다. 단, 역할은 메모리와 비슷합니다.</li>
  <li>메모리는 느립니다.
    <ul>
      <li>CPU의 데이터를 메모리에 저장하려면 CPU에서 메모리까지 연결해주는 버스(bus)를 태워 데이터를 주고 받아야 합니다. 그런데, 버스를 태워 데이터를 보내는 것 자체가 지연입니다. 또한, 버스의 크기를 어떻게 설정하는 지에 따라 성능이 좌우되기도 합니다.</li>
      <li>대부분 컴퓨터의 메모리는 DRAM입니다. DRAM은 저렴한 대신 기록한 데이터를 유지하기 위해 주기적으로 데이터를 다시 써야 합니다.(가만히 두면 날아갑니다.) SRAM은 이러 단점이 없긴 한데… 매우 비쌉니다.</li>
    </ul>
  </li>
  <li>컴퓨터 공학자들은 저렴하고 빠른 컴퓨터를 만들고 싶었습니다. 그래서 메모리는 DRAM을 쓰되, SRAM을 CPU와 메모리 사이에 두기로 했습니다.</li>
  <li>사이에 두기로 했지만 아예 CPU안에 넣어버렸습니다. 굉장히 작은 크기만. 그것이 레지스터 입니다.(엄밀히 말하면 SRAM 자체는 아니지만 거진 비슷합니다.)</li>
</ul>

<h2 id="227-어셈블리어로-보는-레지스터">227. 어셈블리어로 보는 레지스터</h2>

<hr />

<ul>
  <li>레지스터는 CPU가 사용하는 저장 공간 중 가장 빠른 저장공간입니다.</li>
  <li>CPU가 연산할 땐 레지스터에 있는 데이터를 사용합니다. 연산 결과도 일단 레지스터에 저장합니다.</li>
  <li>그런데 저희는 이미 레지스터를 많이 만났습니다. 어셈블리어 까볼때.
    <ul>
      <li>어셈블리어에서 봤던 ebp, esp, eax, ecx 등이 레지스터입니다.</li>
    </ul>
  </li>
  <li>X86에서 사용하는 레지스터
    <ul>
      <li>8개의 범용 레지스터 (general-purpose register)
        <ul>
          <li>ESP, EBP, EAX, EBX, ECX, EDX 등</li>
        </ul>
      </li>
      <li>6개의 세그먼트 레지스터 (segment register)</li>
      <li>1개의 플래그 레지스터 (flags register)</li>
      <li>1개의 명령어 포인터 (instruction pointer)</li>
    </ul>
  </li>
</ul>

<h2 id="228-register-키워드">228. register 키워드</h2>

<hr />

<ul>
  <li>
    <p>어셈블리어로 코딩하면 register 수준에서 데이터를 다룰 수 있습니다 ㅎㅎ</p>
  </li>
  <li>
    <p>그런데, C는 레지스터를 써달라고 시도해 볼 순 있습니다. 단, 컴파일러에 따라 해줄지 말지는 모릅니다.</p>
  </li>
  <li>
    <p>거의 안쓸거지만 설명은 드립니다.</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
<span class="cm">/* size_t는 계속 레지스터에 넣어주세요!! */</span>
<span class="k">register</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
  
<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="n">printf</span><span class="p">(</span><span class="s">"num: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>register</p>

    <ul>
      <li>
        <p>register <자료형> <변수명>;</변수명></자료형></p>
      </li>
      <li>
        <p>저장 유형 지정자(storage-class specifier) 라고 부릅니다.</p>
      </li>
      <li>
        <p>‘가능하면 해당 변수를 레지스터에 저장해달라’</p>
      </li>
      <li>
        <p>실제로 레지스터에 저장할 지는 컴파일러가 결정합니다.</p>
      </li>
      <li>
        <p>레지스터는 메모리와 다르기 때문에 몇 가지 제약이 있습니다. (메모리가 아니라 레지스터에 저장했기 때문에 쓸 수 없는 기능들)</p>

        <ul>
          <li>
            <p>변수의 주소를 구할 수 없습니다.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">register</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
      
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span> <span class="cm">/* 컴파일 오류 */</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>레지스터 배열을 포인터로 사용 불가</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">register</span> <span class="kt">int</span> <span class="n">nums</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
      
<span class="n">p</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span> <span class="cm">/* 컴파일 오류 */</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="cm">/* 컴파일 오류 */</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>전역변수에 사용할 수 없습니다. (전역 변수는 메모리의 데이터 섹션에 들어가야 하며, 레지스터는 몇 개 없는데 전역 변수는 프로그램 실행 내내 잡혀 있어야 하므로)</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>      
<span class="k">register</span> <span class="kt">int</span> <span class="n">g_num</span><span class="p">;</span> <span class="cm">/* 컴파일 오류 */</span>
      
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>
        <p>요즘 대부분 컴파일러는 register를 그냥 무시합니다.</p>
      </li>
      <li>
        <p>예전 임베디드 시스템에선 꽤 사용되던 키워드입니다.(CPU도 느리고 메모리도 적어서 프로그래머가 더 많은 일을 했어야 했던 때)</p>
      </li>
      <li>
        <p>요즘 컴파일러는 release모드에서 알아서 최적화 해줍니다. 레지스터에 계속 잡아두면 빠를 변수는 레지스터에 잡아줍니다.</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="229-힙-메모리">229. 힙 메모리</h2>

<hr />

<ul>
  <li>스택 메모리의 단점
    <ul>
      <li>수명 - 함수가 반환되면 함수 안의 데이터가 날아갑니다. 오래 잡아 두고 싶으면 전역변수를 쓰던지, static 키워드를 써야 했습니다. 근데 이렇게 하면 함수 안에서만 있거나, 프로그램 끝날때까지 있거나입니다. 중간에 원할 때 만들고 원할 때 지울 수 있으면 좋겠습니다.</li>
      <li>크기 - 스택 메모리의 크기는 작고 한정되어 있습니다. 큰 데이터는 스택 메모리에 못 넣을 수도 있습니다.</li>
    </ul>
  </li>
  <li>힙 메모리
    <ul>
      <li>컴퓨터에 존재하는 범용 메모리입니다.</li>
      <li>스택 메모리처럼 특정 용도로 떼어 놓은 메모리가 아닙니다.</li>
      <li>컴파일러 및 CPU가 메모리 관리를 안해주기 때문에 개발자가 원할 때 원하는 만큼 할당 받고, 원할 때 반납(해제)할 수 있습니다.</li>
    </ul>
  </li>
  <li>힙 메모리 장점
    <ul>
      <li>용량 제한이 없습니다.</li>
      <li>프로그래머가 직접 수명을 제어할 수 있습니다. - 양날의 검</li>
    </ul>
  </li>
  <li>힙 메모리 단점
    <ul>
      <li>빌려온 메모리를 해제 안하면 누구도 그 메모리를 쓸 수 없습니다.(메모리 누수라고 합니다.)</li>
      <li>언매니지드 언어라는 뜻도 힙 메모리를 관리안해주기 때문입니다.
        <ul>
          <li>메모리관리를 해주는 매니지드언어(C#, Java 등)은 힙 메모리를 관리해주는 기능이 존재합니다. 이런 메모리관리는 범용적으로 적용되기 때문에 속도는 느립니다.</li>
        </ul>
      </li>
      <li>메모리 관리를 직접 해줘야 합니다. 실수를 막기 위한 좋은 습관들을 들여야 합니다.</li>
      <li>스택에 비해 할당/해제 속도가 느립니다.
        <ul>
          <li>스택은 오프셋 개념이라 빈틈없이 쓸 수 있습니다. 힙은 비사용중인 메모리중 아무데나 집어주기 때문에 메모리 공간에 불규칙적인 구멍이 생겨 효율적으로 메모리를 사용하기 힘듭니다.(‘메모리 파편화’라고도 합니다.)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>정적 메모리 vs 동적 메모리
    <ul>
      <li>스택 메모리는 정적 메모리입니다. 컴파일시 메모리를 얼마나 쓸 지 정해져 있습니다. 할당/해제가 자동으로 관리 되도록 컴파일 됩니다.</li>
      <li>힙 메모리는 실행중에 크기와 할당/해제 시기가 달라질 수 있습니다. 어떤 파일을 언제 열지, 언제 저장할 지, 어떤 행동을 할 건지 등에 따라 달라집니다.</li>
    </ul>
  </li>
</ul>

<h2 id="230-동적-메모리">230. 동적 메모리</h2>

<hr />

<ul>
  <li>동적메모리를 사용할 땐 세 가지 단계를 거칩니다.
    <ul>
      <li>메모리 할당
        <ul>
          <li>힙 관리자에게 메모리를 xxx 바이트만큼 달라고 요청합니다.</li>
          <li>관리자는 xxx 바이트 만큼 연속되는 빈 메모리를 찾아 사용중으로 상태를 바꾸고 메모리의 시작 주소를 반환합니다.</li>
        </ul>
      </li>
      <li>메모리 사용
        <ul>
          <li>반환하는 주소를 포인터로 받습니다.</li>
          <li>그 이후는 평소 프로그래밍 하듯이 합니다.</li>
        </ul>
      </li>
      <li>메모리 해제
        <ul>
          <li>주소를 다 쓰면 다 썼다고 힙 관리자에게 알려줍니다.</li>
          <li>힙 관리자는 해당 메모리를 사용가능한 상태로 다시 바꿉니다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="231-메모리-할당-및-해제-함수-malloc">231. 메모리 할당 및 해제 함수, malloc()</h2>

<hr />

<ul>
  <li>할당
    <ul>
      <li>malloc()</li>
      <li>calloc()</li>
    </ul>
  </li>
  <li>해제
    <ul>
      <li>free()</li>
    </ul>
  </li>
  <li>재할당
    <ul>
      <li>realloc()</li>
    </ul>
  </li>
  <li>기타(정적 메모리에도 사용 가능)
    <ul>
      <li>memset()</li>
      <li>memcpy()</li>
      <li>memcmp()</li>
    </ul>
  </li>
</ul>

<h3 id="malloc">malloc()</h3>

<ul>
  <li>memory allocation의 약자입니다.</li>
  <li><code class="highlighter-rouge">void* malloc(size_t size);</code></li>
  <li>void 포인터를 용도에 맞는 포인터로 캐스팅해서 사용합니다.</li>
  <li>반환된 주소에 있는 초기 값은 쓰레기 값입니다. C에선 초기화 안해줍니다.</li>
  <li>메모리가 없거나 기타 이유로 실패하면 NULL을 반환합니다.</li>
</ul>

<h2 id="232-free-malloc-사용-예">232. free(), malloc() 사용 예</h2>

<hr />

<h3 id="free">free()</h3>

<ul>
  <li>malloc()의 짝꿍입니다. 메모리를 해제해줍니다.</li>
  <li>malloc() 을 작성하면 일단 바로 free()를 작성하는 습관을 들입시다. 중간 코드는 malloc(), free()를 쓰고 써도 됩니다.</li>
  <li><code class="highlighter-rouge">void free(void* ptr);</code></li>
  <li>malloc을 통해 얻어온 주소만 free 가능합니다. 외에 malloc으로 받아온 포인터가 아닌 다른 포인터를 넣으면 결과는 undefined입니다.</li>
</ul>

<h3 id="malloc-사용-예">malloc() 사용 예</h3>

<ul>
  <li>쭉 코드보는 시간</li>
</ul>

<h2 id="233-동적-메모리-할당-시-문제">233. 동적 메모리 할당 시 문제</h2>

<hr />

<ul>
  <li>
    <p>할당 받아온 주소를 그대로 연산에 사용하면 발생할 수 있는 문제가 있습니다.</p>

    <ul>
      <li>한 포인터에 최초에 malloc으로 받아온 주소가 아니라 중간에 다른 주소를 대입하면 free 할때 undefinded한 결과가 나옵니다. 그리고 malloc으로 받은 메모리는 해제되지 못하고 남아 있습니다.</li>
    </ul>
  </li>
  <li>
    <p>할당받은 포인터로 연산을 최대한 자제시키는 코딩 표준.</p>

    <ul>
      <li>
        <p>malloc을 받아온 원본 포인터는 그냥 가지고 있고, 연산이 필요하면 다른 포인터를 선언해서 그걸로 연산해라.</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">void</span><span class="o">*</span> <span class="n">nums</span><span class="p">;</span> <span class="cm">/* malloc 받을 포인터 */</span>
 <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span> <span class="cm">/* 연산할 포인터 */</span>
     
 <span class="n">nums</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">LENGTH</span><span class="o">*</span><span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
 <span class="n">p</span> <span class="o">=</span> <span class="n">nums</span><span class="p">;</span> <span class="cm">/* free를 위한 원본은 남겨두기 위해 주소 복사 */</span>
     
 <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">LENGTH</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
 	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
 <span class="p">}</span>
     
 <span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>해제한 메모리를 또 해제하는 경우도 있습니다. undefined한 결과이지만 크래시가 날 수도 있습니다.</p>
  </li>
  <li>
    <p>해제한 메모리를 사용하려 하는 경우도 있습니다.(memory stomp라고 합니다.) 역시 결과는 undefined 이긴 합니다.</p>
  </li>
  <li>
    <p>실수를 줄일 수 있는 습관2</p>

    <ul>
      <li>
        <p>해제 후 널 포인터를 대입</p>

        <ul>
          <li>
            <p>free() 한 뒤에 바로 NULL을 대입해줍니다. 다음에 누가 해당 변수를 호출해도 메모리는 안전합니다.</p>

            <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="n">nums</span><span class="p">;</span>
<span class="cm">/* 코드 생략 */</span>
<span class="n">nums</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">LENGTH</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="cm">/* 코드 생략 */</span>
<span class="n">free</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
<span class="n">nums</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

:ET