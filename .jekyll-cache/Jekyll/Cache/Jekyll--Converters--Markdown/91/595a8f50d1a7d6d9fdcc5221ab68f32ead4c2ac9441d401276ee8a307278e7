I"3
<ul>
  <li>본 포스팅은 Ken Krueger 선생님의 <a href="https://www.udemy.com/course/microservices-with-spring-cloud/">Microservices with Spring Cloud</a> 강의를 정리하며 사견을 붙인 것입니다.</li>
  <li>포스팅 내 목차는 개별 동영상 강의 기준입니다.</li>
</ul>

<h2 id="25-api-gateway---part-1---purpose-and-spring-cloud-zuul">25. API Gateway - Part 1 - Purpose and Spring Cloud Zuul</h2>

<hr />

<ul>
  <li>강의를 끝내기 전에 API Gateway에 대해 알아볼 것입니다.
    <ul>
      <li>API Gateway가 왜 필요한지</li>
      <li>Spring Cloud Netflix Zuul</li>
      <li>캐싱</li>
      <li>Resource Expansion</li>
      <li>Protocol Translation</li>
    </ul>
  </li>
</ul>

<h3 id="251-api-gateway가-왜-필요할까요">25.1. API Gateway가 왜 필요할까요</h3>

<ul>
  <li>지금까지 실습을 진행하며 많은 서비스들을 만들었습니다. 이 서비스들을 외부 public internet에 노출하면 어떻게 될까요?
    <ul>
      <li>내부에서만 쓰여야할 api들이 밖으로 노출됩니다. 수정, 삭제 api만 알아내면 외부의 아무 유저나 데이터를 조작할 수 있습니다.</li>
      <li>즉, 보안상 문제가 됩니다.</li>
      <li>또한 CORS(Cross-Origin Resource Sharing) 이슈에도 부딪힙니다.</li>
      <li>그 외에도 여러 문제들이 있습니다.</li>
    </ul>
  </li>
  <li>또한, 현대의 웹에는 클라이언트의 종류도 다양합니다. 웹 브라우저, pc 클라이언트, 모바일 클라이언트, TV, 게임 콘솔 등.. 이런 다양한 종류의 클라이언트에게 적합한 결과를 돌려줘야 합니다.</li>
  <li>위와 같은 문제들 때문에 API Gateway가 등장했습니다.
    <ul>
      <li>내부에서 사용하는 api 외에, 클라이언트가 호출하기 좋은 api를 따로 구성할 수 있습니다.</li>
      <li>내부 api는 내부 api와 api 게이트웨이에서 오는 요청만 처리하고 나머지 요청은 거절하면 됩니다. 보안을 강황할 수 있습니다.</li>
      <li>클라이언트는 api 게이트웨이만 상대하면 되므로 CORS 이슈도 해결할 수 있습니다.</li>
      <li>캐싱도 할 수 있고 프로토콜 변환도 할 수 있고 등등… 이점이 많습니다.</li>
    </ul>
  </li>
  <li>api 게이트웨이를 여러개 둘 수 있고 하나만 둘 수도 있습니다.</li>
</ul>

<h3 id="252-spring-cloud-netflix-zuul">25.2. Spring Cloud Netflix Zuul</h3>

<ul>
  <li>
    <p>Zuul 역시 Netfilx OSS이며 Spring Cloud에서 wrapper api를 만들었습니다.</p>
  </li>
  <li>
    <p>Zuul은 JVM 기반의 라우터이자 로드밸런서입니다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">spring-cloud-starter-zuul</code> 의존성을 추가합니다. 안에 Ribbon과 Hystrix를 포함합니다.</p>
  </li>
  <li>
    <p>어노테이션은 <code class="highlighter-rouge">@EnableZuulProxy</code>만 추가하면 됩니다.</p>
  </li>
  <li>
    <p>Zuul은 다음과 같이 작동합니다.</p>

    <ul>
      <li>Eureka client-id 가 URI로 쓰입니다.
        <ul>
          <li>“subject” 서비스는 “/subject”가 되고 “verb”서비스는 “/verb”가 됩니다.</li>
        </ul>
      </li>
      <li>한 서비스가 여러개 있다면 자동으로 로드밸런서가 작동합니다.</li>
      <li>Hystrix의 서킷 브레이커도 자동으로 작동합니다.</li>
      <li>클라이언트는 “/{service name}” 을 호출하면 됩니다. Zuul이 해당 서비스에 해당하는 서버들 중 가장 빠른 서버를 찾아서 ip와 포트를 설정한뒤 요청해줍니다.</li>
    </ul>
  </li>
  <li>
    <p>zuul.ignored-services에 등록하면 해당 서비스만 제외시킬 수 있습니다.</p>
  </li>
  <li>
    <p>zuul.prefix를 통해 접미사를 붙일 수 있습니다.</p>
  </li>
  <li>
    <p>아래와 같이 prefix와 ignored-services를 설정할 수 있습니다.</p>

    <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">\---</span>
<span class="na">zuul</span><span class="pi">:</span>
  <span class="na">prefix</span><span class="pi">:</span> <span class="s">/api</span>
  <span class="na">ignored-services</span><span class="pi">:</span> <span class="s">verb</span>
  <span class="na">routes</span><span class="pi">:</span>
    <span class="na">subject</span><span class="pi">:</span>
      <span class="na">path</span><span class="pi">:</span> <span class="s">/sentence-subject/**</span>
    <span class="na">noun</span><span class="pi">:</span>
      <span class="na">path</span><span class="pi">:</span> <span class="s">/sentence-noun/**</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>클라이언트가 사용할 api는 다음과 같이 구성됩니다.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Result:
localhost:8080/api/sentence-subject/
              /api/verb/ 👉 ignored
              /api/article/
              /api/adjective/
              :
</code></pre></div>    </div>
  </li>
</ul>

:ET