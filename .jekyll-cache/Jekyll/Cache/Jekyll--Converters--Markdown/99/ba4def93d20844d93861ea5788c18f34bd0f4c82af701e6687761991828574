I"c+<h3 id="들어가며">들어가며</h3>

<p>이번 장에선 HTTP 프로토콜이 다른 프로토콜과 만나는 다음 4개의 지점들에 대해 알아볼 것입니다.</p>

<ul>
  <li>게이트웨이 : 서로 다른 프로토콜과 애플리케이션간의 HTTP인터페이스. 다른 프로토콜이 HTTP로, HTTP가 다른 프로토콜로 변환되는 지점</li>
  <li>애플리케이션 인터페이스 : 서로 다른 형식의 웹 애플리케이션이 통신하는데 사용</li>
  <li>터널 : HTTP 커넥션을 통해 다른 프로토콜의 트래픽을 전송</li>
  <li>릴레이 : 단순한 HTTP 프록시로, 한 번에 한 개의 홉에 데이터를 전달.</li>
</ul>

<hr />

<h3 id="81-게이트웨이">8.1. 게이트웨이</h3>

<p>웹은 다양하고 많은 리소스를 가지고 있어, 한개의 서버만으론 모든 리소스를 관리하기 힘들어졌습니다. 이에 따라 인터프리터와 같이 리소스를 받기위한 경로를 안내하는 역할의 게이트웨이들이 등장하기 시작했습니다.</p>

<p>게이트웨이의 역할은 리소스와 애플리케이션을 연결하는 것입니다. 게이트웨이는 리소스를 가져올 수 있는 적합한 프로토콜을 사용해 리소스를 가져와 애플리케이션이 원하는 프로토콜로 보내줍니다.</p>

<ul>
  <li>HTTP/FTP 게이트웨이 : 클라이언트의 HTTP요청이 FTP서버에 있는 파일을 가리킬때 요청은 게이트웨이를 통과해 FTP 서버에서 파일을 가져와 HTTP로 돌려줍니다.</li>
  <li>HTTP/HTTPS 게이트웨이 : 게이트웨이가 SSL요청을 받고 해독해 HTTP 요청으로 바꿔 원 서버에게 전달합니다. 이런 보안 가속기 게이트웨이는 보통 웹 서버의 바로 앞단에 위치합니다.</li>
  <li>HTTP/CGI 게이트웨이 : HTTP 요청을 받은 뒤 CGI를 통해 서버 안의 애플리케이션으로 보내고, 받아온 리소스를 다시 HTTP로 돌려줍니다.</li>
</ul>

<h4 id="811-클라이언트-측-게이트웨이와-서버-측-게이트웨이">8.1.1. 클라이언트 측 게이트웨이와 서버 측 게이트웨이</h4>

<p>앞의 예에서 HTTP/FTP, HTTP/HTTPS, HTTP/CGI와 같이 표현했습니다. 이와 같이 게이트웨이가 변환하는 프로토콜은</p>

<blockquote>
  <클라이언트 프로토콜="">/<서버 프로토콜="">
</서버></클라이언트>
</blockquote>

<p>위와 같이 표현합니다.</p>

<p>그리고 앞으로 ‘서버 측 게이트웨이’와 ‘클라이언트 측 게이트웨이’라는 용어가 등장할 것입니다. 이는 게이트웨이가 어느쪽 역할을 하고 있는지 말해줍니다.</p>

<ul>
  <li>서버 측 게이트웨이 : <HTTP>/<기타 프로토콜=""></기타></HTTP></li>
  <li>클라이언트 측 게이트웨이 : <기타 프로토콜="">/<HTTP></HTTP></기타></li>
</ul>

<hr />

<h3 id="82-프로토콜-게이트웨이">8.2. 프로토콜 게이트웨이</h3>

<p>이번 절에선 네트워크상 클라이언트와 서버를 연결해 주는 게이트웨이를 알아볼 것입니다.(다음 절에선 서버 내에서 서버와 다른 리소스 서버를 연결하는 게이트웨이를 알아 봅니다.)</p>

<h4 id="821-http-서버-측-웹-게이트웨이">8.2.1. HTTP/*: 서버 측 웹 게이트웨이</h4>

<p>서버 측 웹 게이트웨이는 클라이언트의 HTTP 요청을 받아 HTTP가 아닌 다른 프로토콜을 사용하는 서버와 연결해줍니다. HTTP/FTP 게이트웨이나 HTTP/HTTPS 같은 게이트웨이 입니다.</p>

<p>책엔 HTTP/FTP 게이트웨이에 관한 예시가 나와 있습니다.</p>

<p><img src="\public\image\http완벽가이드\http_ftp_gateway.png" alt="http_ftp_gateway" /></p>

<h4 id="822-httphttps-서버-측-보안-게이트웨이">8.2.2. HTTP/HTTPS: 서버 측 보안 게이트웨이</h4>

<p>기업 내부로 들어오는 모든 HTTP 요청을 암호화 하여 고객들의 개인정보를 보호하고 보안을 제공해주는 게이트웨이 입니다.</p>

<p>클라이언트는 일반적인 HTTP URL을 사용하지만 게이트웨이에서 자동으로 사용자의 모든 세션을 암호화 합니다.</p>

<h4 id="823-httpshttp-클라이언트-측-보안-가속-게이트웨이">8.2.3. HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이</h4>

<p>요즘은 브라우저에서 기본적으로 http:// 가 아닌 https://를 많이 사용한다는 것은 알 것입니다. 이를 HTTP 서버와 통신시키기 위해선 HTTPS/HTTP 게이트웨이가 필요합니다. 이런 게이트웨이를 ‘보안 가속기’라고 부릅니다.</p>

<p>클라이언트의 암호화된 요청인 HTTPS 요청을 받아들여 이를 해독하고 웹 서버엔 일반 HTTP 요청을 보냅니다.</p>

<p><img src="\public\image\http완벽가이드\https_http_gateway.png" alt="https_http_gateway" /></p>

<p>하지만 옮긴이에 따르면 요즘엔 대부분 SSL 암/복호화 모듈을 서버에 내장한다고 합니다. 로드 밸런서 중에도 SSL 모듈을 내장해 보안 가속기 게이트웨이의 역할을 해준다고 합니다.</p>

<hr />

<h3 id="83-리소스-게이트웨이">8.3. 리소스 게이트웨이</h3>

<p>전 절에서 소개한 게이트웨이는 클라이언트와 서버 사이를 이어주는 게이트웨이였습니다. 한편, 가장 일반적인 형태의 게이트웨이인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합해주는 역할을 합니다.  클라이언트와 HTTP로 통신하고, 서버 내에 있는 애플리케이션 프로그램들과도 연결됩니다.</p>

<p><img src="/public/image/http완벽가이드/application_server_gateway.png" alt="application_server_gateway" /></p>

<p>위 그림에서 하나의 서버에 두 클라이언트가 각기 다른 요청을 보내고 있습니다. 애플리케이션 서버는 게이트웨이의 API를 이용해 서버 내에 동작하고 있는 프로그램과 연결됩니다.</p>

<ul>
  <li>
    <p>클라이언트 A의 요청을 받은 애플리케이션 서버는 API를 이용해 서버내 카메라 관련 프로그램과 통신했습니다. 프로그램이 돌려준 결과물을 클라이언트에게 HTTP로 돌려줍니다.</p>
  </li>
  <li>
    <p>클라이언트 B의 요청을 받은 애플리케이션 서버는 서버 내 전자상거래 어플리케이션과 통신합니다.</p>
  </li>
</ul>

<p>애플리케이션 서버가 사용하는 API중 최초로 널리쓰이게된 API는 CGI(Common Gateway Interface)입니다. 전 포스팅이나 앞에서도 계속 언급됐던 기술이죠.</p>

<p>CGI는 말 그대로 인터페이스입니다. 애플리케이션 서버와 서버내 프로그램이 서로 통신할때 필요한 행동들(프로그램 실행, 프로그램 출력 수집, HTTP응답 회신 등…)을 모아놓은 것이죠.</p>

<p>애플리케이션 서버에 요청이 들어오면 서버는 헬퍼 애플리케이션을 생성합니다. 이때 헬퍼 애플리케이션이 CGI를 구현한 프로그램입니다. CGI 프로그램인 헬퍼 어플리케이션이 필요한 데이터를 받고 서버 내 프로그램과 통신해 결과를 받아 서버에 반환합니다.</p>

<h4 id="831-공용-게이트웨이-인터페이스cgi">8.3.1. 공용 게이트웨이 인터페이스(CGI)</h4>

<p>CGI가 하는 역할을 때문에 CGI를 ‘서버 확장’이라고도 합니다. CGI는 최초로 널리쓰인 서버 확장이고 아직까지도  사용됩니다.(물론 책이 쓰여진 2002년 기준이고, 2020년 현재엔 초기 CGI는 찾아보기 힘듭니다.)</p>

<p>CGI 애플리케이션은 Perl, C, Python 등 다양한 언어로 구현할 수 있습니다. 그리고 CGI자체가 단순하여 거의 모든 HTTP 서버가 지원합니다.</p>

<p>CGI 애플리케이션이 어떻게 요청을 처리하는지는 사용자에게 보여지지 않습니다. 진행되는 처리 단계를 감추고, 잘못된 요청 및 데이터로부터 서버를 보호해줍니다.</p>

<p>하지만 역시 단점도 있습니다. 기본적으론 각 요청마다 CGI 프로그램의 프로세스가 하나씩 생깁니다. 요청이 많아지면 이에 따른 부하 역시 커집니다. 이를 해결하고자 새로운 CGI인 Fast CGI등이 개발됐습니다. FastCGI는 데몬(Daemon, 사용자가 직접 제어하지 않고, 백그라운드에서 돌며 여러 작업을 하는 프로그램)으로 실행되어 매 요청마다 프로세스를 생성하지 않습니다.</p>

<p>책이 쓰여진 시점이 아닌 2020년 현재엔 요청마다 CGI 프로세스를 만드는 방식은 거의 안쓰인다고 보면 됩니다.</p>

<h4 id="832-서버-확장-api">8.3.2. 서버 확장 API</h4>

<p>CGI 프로토콜은 구동 중인 서버에 외부 인터프리터가 접속하는 것을 도와줍니다. 하지만 서버 자체의 동작을 바꾸거나, 서버의 처리능력을 더 끌어올리기 위해선 외부에서 서버로 직접 연결할수 있어야 합니다. 이를 위해 만들어진 것이 서버 확장 API입니다.</p>

<p>확장 API는 개발자가 외부에서 자신이 작성한 코드를 서버에 연결하거나, 서버의 컴포넌트를 자신이 만든 것으로 교체할 수 있게 해줍니다.</p>

<p>아파치, 마이크로소프트, 넷스케이프와 같은 대중적인 서버의 대부분은 확장 API를 한개 이상 제공합니다. 서버 확장의 한 가지 예는 마이크로소프트의 프론트페이지 서버 확장(FPSE, FrontPage Server Extension)입니다. FPSE는 클라이언트에서 전송되는 원격 프로시져 호출(RPC, Remote Procedure Call)명령을 인식할 수 있습니다. 클라이언트 쪽에서 서버에 직접 명령을 내릴 수 있는 것이죠. 이 명령이 HTTP에 편승해 옵니다. 19장에서 더 자세히 볼 수 있습니다.</p>

<hr />

<h3 id="84-애플리케이션-인터페이스와-웹-서비스">8.4. 애플리케이션 인터페이스와 웹 서비스</h3>

<p>앞서 살펴본 것 처럼 HTTP는 애플리케이션을 연결하는 도구로 사용됩니다. 이때 항상 생기는 이슈는 두 애플리케이션 사이에서 프로토콜의 인터페이스를 조율하는 일입니다.</p>

<p>기본적인 CGI가 있고, HTTP 헤더만으로 표현하기 힘든 정보를 교환해야 할때 HTTP를 확장한 서버 확장 API도 있습니다.</p>

<hr />

<h3 id="85-터널">8.5. 터널</h3>

<h4 id="851-connect로-http-터널-커넥션-맺기">8.5.1. CONNECT로 HTTP 터널 커넥션 맺기</h4>

<h4 id="852-데이터-터널링-시간-커넥션-관리">8.5.2. 데이터 터널링, 시간, 커넥션 관리</h4>

<h4 id="853-ssl-터널링">8.5.3. SSL 터널링</h4>

<h4 id="854-ssl-터널링-vs-httphttps-게이트웨이">8.5.4. SSL 터널링 vs HTTP/HTTPS 게이트웨이</h4>

<h4 id="855-터널-인증">8.5.5. 터널 인증</h4>

<h4 id="856-터널-보안에-대한-고려사항들">8.5.6. 터널 보안에 대한 고려사항들</h4>

<hr />

<h3 id="86-릴레이">8.6. 릴레이</h3>

<hr />

<h3 id="마치며">마치며</h3>
:ET