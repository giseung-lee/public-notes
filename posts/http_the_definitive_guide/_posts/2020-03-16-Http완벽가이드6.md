---
layout: post
title: HTTP 6 - 프록시
---

{% assign imgurl=site.data.common.path.image|append: '/'|append: page.categories[1] %}

### 들어가며

---

### 6.1. 웹 중개자

 쿠팡, 11번가와 같은 인터넷 쇼핑몰은 소비자와 판매자 사이를 중개해줍니다. 소비자 입장에선 똑같이 돈을 주고 물건을 받는것이지만 인터넷 쇼핑몰을 이용하면 쇼핑몰이 제공하는 다양한 기능(상품 비교, 장바구니 등)을 사용할 수 있습니다.

 프록시는 클라이언트와 서버를 중개해줍니다. 클라이언트와 서버 사이에 놓여 여러가지 기능들을 제공해줍니다. 클라이언트와 서버 사이에 있기 때문에 프록시는 클라이언트와 통신할땐 서버처럼, 서버와 통신할 땐 클라이언트 처럼 행동합니다.

#### 6.1.1. 개인 프록시와 공유 프록시

 프록시는 하나의 클라이언트가 하나를 독점적으로 쓸 수도 있고 여러 클라이언트가 공유할 수도 있습니다. 

 **공용 프록시**

 하지만 대부분의 프록시는 사실 공용 프록시입니다. 클라이언트마다 프록시를 할당해 관리하는 것 보다 하나의 큰 프록시를 관리하는게 효율이 더 높기 때문입니다. 그리고 캐시 프록시 서버 같은 프록시는 공통된 요청을 빠르게 처리할 수 있기 때문에 사용자가 많을수록 유리하기도 합니다.

 **개인 프록시**

 개인 프록시는 흔하지 않지만 꾸준히 사용됩니다. 주로 클라이언트의 PC에 설치되어 실행 됩니다. 인터넷 브라우저 자체적으로 개인 프록시를 운영하기도 합니다. 

#### 6.1.2. 프록시 대 게이트웨이

 그런데 클라이언트와 서버 사이를 중개해주는 것이 하나 더 있습니다. 바로 게이트웨이입니다. 앞 장에서 살짝 살펴보았고 이후 8장에서 더 자세히 살펴볼 것입니다.

 일반적으로 프록시와 게이트웨이의 차이점은 같은 프로토콜을 연결하는지, 다른 프로토콜을 연결하는 지입니다. 프록시는 같은 프로토콜을 사용해 클라이언트와 서버를 중개하고, 게이트웨이는 메세지를 받아 다른 프로토콜의 메세지로 전환해줍니다. 

 하지만 사실 프록시와 게이트웨이의 경계는 모호합니다. 프록시는 다른 버전의 HTTP 프로토콜끼리도 중개해야 하기 때문에(클라이언트마다 HTTP 버전이 다르므로) 프로토콜을 변환하기도 합니다. 그리고 상용 프록시들은 SSL 보안 프로토콜, SOCKS 방화벽, FTP접근 등 게이트웨이가 하는 역할까지 지원합니다.

---

### 6.2. 왜 프록시를 사용하는가?

 프로시가 사용되는 몇 가지 예를 알아보겠습니다.

 **어린이 필터**

 어린이들이 주로 사용하는 학교의 PC 같은 경우엔 유해한 사이트를 차단하는 프록시를 설정해둘수 있습니다. 

 **문서 접근 제어자**

 대기업 같이 권한이 계층화 되어있는 곳에선 부서별로, 직급별로 열람 가능한 문서를 제한할 수 있습니다. 모든 클라이언트가 중앙 프록시 서버를 거칠 수 있도록 하고, 중앙 프록시 서버에서 요청마다 접근을 제어하고 audit trail(감사 추적)을 할 수 있습니다.

 **보안 방화벽**

 보안용 프록시를 설치해 들어오는 요청에 바이러스가 있는지 검사할 수 있습니다.

 **웹 캐시**

 서버에 걸리는 부담을 줄이고 클라이언트들이 응답을 빠르게 얻을 수 있도록 서버 안에 자주 열람되는 리소스들의 사본을 모아 프록시에 저장해 놓을 수도 있습니다. 이를 웹 캐시라고 부릅니다. 

 **대리 프록시(Surrogate)**

 대리 프록시는 웹 서버인것 처럼 위장합니다. 요청을 받아 요청받은 리소스의 위치를 찾기 위해 다른 서버들과 통신합니다. 웹 서버의 성능 개선을 목적으로 쓰이기 때문에 흔히 서버 가속기라고 불리기도 합니다. 콘텐츠 라우팅기능과 결합되어 분산 네트워크를 구성하기도 합니다.

 **콘텐츠 라우터**

 콘텐츠 라우터는 클라이언트나 콘텐츠 종류에 따라 요청을 특정 웹 서버로 유도합니다. 예를들어 높은 성능을 위해 추가로 돈을 지불할 수 있는 웹 서비스에선 추가 지불한 클라이언트들의 요청은 더 빨리 응답해줄 수 있는 웹 캐시로 전달해줍니다.

 **트랜스코더**

 트랜스코더는 본문의 포맷을 수정하는 프록시입니다. GIF 파일을 JPG 파일로 압축하거나, 일반 텍스트 파일을 더 압축할 수도 있고, 텍스트 파일을 특정 언어로 변환할 수도 있습니다.

 **익명화 프록시(Anonymizer)**

 HTTP 메세지에서 클라이언트를 식별할 수 있는 특성들을 제거하고 전달해주는 프록시입니다. User-Agent헤더에서 사용자의 컴퓨터와 OS종류를 제거하고, IP주소, From헤더, Referer헤더, Cookie헤더 등을 제거해줍니다.

---

### 6.3. 프록시는 어디에 있는가

 프록시가 어떤 역할을 하는지는 알았으니 이번엔 프록시가 구체적으로 어디에 있고, 언제 네트워크 아키텍처상에 배치되는지 알아보겠습니다. 

#### 6.3.1. 프록시 서버 배치

 프록시는 클라이언트-서버 사이면 어느 곳에든 배치 될 수 있는데 아래와 같은 방법들로 배치할 수 있습니다.

 **LAN과 WAN사이 : 출구(Egress) 프록시**

 로컬 네트워크(LAN, Local Area Network)가 WAN(Wide Area Network)에 들어가는 지점에 위치해 회사안의 보안을 강화할 수도 있고 어린이들이 유해 사이트에 노출되지 않게 할 수도 있습니다.

 **ISP(Internet Service Provider)접근 지점 : 접근(입구) 프록시**

 ISP란 KT, SK 텔레콤과 같이 인터넷을 제공해주는 업체를 말합니다. 주로 인터넷 속도 개선을 위해 사용하는 캐시 프록시를 예로 들 수 있습니다.

 **웹 서버 바로 앞 : 대리 프록시**

 대리 프록시는 웹 서버 바로 앞에 위치해 요청을 처리하고 서버에서 리소스를 가져와야 할 때만 서버까지 요청을 보냅니다. 주로 캐시 프록시를 예로 들 수 있습니다.

 **네트워크 교환 프록시**

 네트워크들 사이에 위치해서 트래픽의 혼잡을 완하하고 감시하기도 합니다. 

#### 6.3.2. 프록시 계층

 프록시는 여러개를 거칠 수도 있습니다. 만약

 클라이언트 -> 프록시1 -> 프록시2 -> 프록시3 -> 서버

 관계가 있다면 프록시2는 프록시1의 인바운드 프록시이며 '부모'프록시라고 부릅니다. 반대로 프록시2는 프록시3의 아웃바운드 프록시이며 '자식'프록시라고 부릅니다.

 **프락시 계층 콘텐츠 라우팅**

 프록시가 계층을 이루고 있을때 프록시A는 항상 프록시B로 요청을 보낼 수도 있고(프록시 계층이 정적이다) 조건에 따라 다른 프록시들로 라우팅 할 수도 있습니다.(프록시 계층이 동적이다.) 

- 부하 균형
   자식 프록시는 부하를 분산하기 위해 부모 프록시들의 작업량을 파악해 부하가 적게 걸리는 부모쪽으로 라우팅 할 수 있습니다.
- 지리적 인접성에 근거한 라우팅
   원 서버의 각 지역을 담당하는 부모쪽으로 라우팅할 수 있습니다. 2020년 3월 16일 기준으로 구글 클라우드 서비스는 전세계 21개 지역에 서버를 두고 있습니다. 서울도 있습니다.
- 프로토콜/타입 라우팅
   요청 URI에 근거해 라우팅을 할 수 있습니다. FTP프로토콜로 온 요청을 파일 서버로 라우팅 한다던가, 이미지 파일 요청이 왔을때 이미지 서버로 라우팅할 수 있습니다.
- 유료 서비스 가입자를 위한 라우팅
   빠른 성능을 위해 추가금액을 낸 이용자를 위해 가까운 것에 캐시 프록시를 만들어 캐시 프록시에서 바로 리소스를 제공해줄 수 있습니다.

#### 6.3.3. 어떻게 프록시가 트래픽을 처리하는가

 그런데 지금까지 학습한 바에 따르면 우리는 분명 원 서버로 URL 요청을 보낼텐데 어떻게 그 요청이 프록시로 가는 걸까요

 **클라이언트 수정**

 웹 브라우저같은 웹 클라이언트들은 수동 혹은 자동 프록시 설정을 지원합니다. 클라이언트 어플리케이션에서 특정 프록시를 거치도록 설정 됐거나, 설정 하게되면 사용자의 요청은 프록시로 먼저 가게 됩니다. 

 **네트워크 수정**

 네트워크를 관리하는 업체에선 트래픽을 가로채 프록시로 보낼 수 있습니다. 이 방법을 사용하면 클라이언트 입장에선 자신의 요청이 프록시를 거쳐온건지, 바로 서버로 갔다온건지 알 수 없습니다. 이를 하기 위해 스위칭 장치와 라우팅 장치가 필요합니다. 이런 프록시를 인터셉트 프록시라고 부릅니다.
 (투명 프록시(transparent proxy) 라고도 하지만 HTTP 명세에서 transparent는 '행위의 의미를 변경하지 않는다'라는 뜻으로 쓰이기 때문에 본 책에선 투명 프록시 대신 인터셉트 프록시라고 표현했습니다.)

 **DNS 이름 공간을 수정**

 사용자가 URL에 호스트명을 입력하면 DNS 서버가 이를 호스트의 IP로 변환해줍니다. 이 과정에서 호스트 명을 호스트의 원 서버 IP가 아닌 프록시의 IP로 변환되게 설정한다면 요청을 프록시로 보낼 수 있습니다.

 **웹 서버를 수정 - 리다이렉션**

 웹 서버에서 프록시로 리다이렉션 시킬 수도 있습니다.

---

### 6.4. 클라이언트 프록시 설정

 앞서 웹 브라우저같은 클라이언트 어플리케이션을 수정해 요청을 프록시로 보낼 수 있다고 했습니다. 거의 모든 현대 브라우저에선 프록시를 사용할 수 있도록 여러가지 설정 방법을 제공하고 있습니다.

#### 6.4.1. 클라이언트 프록시 설정: 수동

 사용자가 브라우저의 설정 탭에서 수동으로 프록시 설정을 할 수 있습니다. (크롬 프록시 설정 : [https://www.itopening.com/2413/](https://www.itopening.com/2413/) )

#### 6.4.2. 클라이언트 프록시 설정: PAC 파일

 수동으로 프록시를 설정하는 방법은 쉽지만 한계가 있습니다. 하나의 프록시만 설정할 수 있고, 지정한 프록시가 장애를 일으킬때의 대안도 없으며, 기업같은 곳에선 프록시를 바꿀때마다 모든 사용자가 각자 프록시 설정을 바꿔야 합니다.

 PAC(Proxy Auto-Configuration)파일은 말 그대로 프록시를 자동으로 Configuration해주는 파일입니다. PAC파일은 FindProxyForUrl(url, host)라는 함수를 구현한 자바스크립트 파일입니다. PAC파일의 URI를 브라우저에 수동으로 설정해두면, 브라우저는 PAC 파일의 로직에 따라 동적으로 프록시를 찾습니다.

 기업같은 곳에서 PAC파일을 한 곳에서 관리하고 모든 사용자가 그 PAC파일의 URI만 안다면 언제든지 PAC 파일을 사용자와 관계 없이 업데이트 할 수 있습니다.

 PAC 파일은 .pac확장자를 갖고 MIME 타입은 'application/x-ns-proxy-autoconfig' 입니다. PAC파일에서 정의해야 하는 FindProxyForUrl 함수는 아래중 하나를 리턴해야 합니다.

| return 값       | 설명                          |
| --------------- | ----------------------------- |
| DIRECT          | 프록시 없이 직접 연결한다.    |
| PROXY host:port | 지정한 프록시를 사용한다.     |
| SOCKS host:port | 지정한 SOCKS 서버를 사용한다. |

 아래는 프로토콜에 따라 프록시를 달리해주는 PAC 파일 사례입니다.

```javascript
function FindProxyURL(url, host){
	if(url.substring(0, 5)=="http:"){
		return "PROXY http-proxy.mydomain.com:8080";
    }
    else if(url.substring(0, 4)=="ftp:"){
		return "PROXY ftp-proxy.mydomain.com:8080";
    }
    else{
        return "DIRECT";
    }
}
```

#### 6.4.3. 클라이언트 프록시 설정: WPAD

 하지만 여기서 끝나지 않고 이 PAC파일의 설정 자체도 동적으로 할 수 있습니다. WPAD(Web Proxy Autodiscovery Protocol)는 프로토콜중 하나이며 자동으로 PAC 파일을 찾아줍니다. 대부분의 브라우저에서 지원해줍니다.

 자동으로 PAC 파일을 찾는 방법엔 몇가지 정형화된 기법이 있습니다. 브라우저는 몇 가지 PAC 파일 탐색 기법을 차례대로 성공할때 까지 수행합니다.

 WPAD명세에선 다음의 순서대로 기법들을 정의하고 있습니다.

- 동적 호스트 발견 규약(DHCP, Dynamic Host Configuration Protocol)
- 서비스 위치 규약(SLP, Service Location Protocol)
- DNS 잘 알려진 호스트명
- DNS SRV 레코드
- DNS TXT 레코드 안의 서비스 URI

 20장에서 더 자세히 알아볼 것입니다.

---

### 6.5. 프록시 요청의 미묘한 특징들

 프록시에게 하는 요청은 서버에 하는 요청과 약간 다른 특징을 갖습니다.

#### 6.5.1. 프록시 URI는 서버 URI와 다르다

 클라이언트가 웹 서버로 바로 요청을 보낼땐 아래와 같이 부분 URI를 갖을 수 있습니다.

> GET /index.html HTTP/1.0
> User-Agent : SuperBrowser v1.3

 하지만 프록시로 요청을 보낼땐 다음과 같이 완전한 URI를 갖습니다.

> GET http://www.marys-antiques.com/index.html HTTP/1.0
> User-Agent : SuperBrowser v1.3

 인터넷의 초창기 시절 클라이언트는 서버와 직접 대화했습니다. 가상 호스팅도, 프록시도 없었습니다. 이렇게 직접 대화하는 환경에서 서버는 자신의 호스트명, 포트번호를 알고 있기 때문에 클라이언트쪽에선 불필요한 정보 발송을 피하기 위해 스킴과 호스트를 생략한 부분 URI를 보냈습니다.

 하지만 프록시, 게이트웨이가 등장하며 부분 URI는 문제가 됐습니다. 프록시로 보내기 위해선 프록시 서버의 호스트명을 명시해야 했고, 게이트웨이에선 스킴을 읽어 어떤 프로토콜인지 식별해야 했기 때문입니다. 

 이를 해결하기 위해서 HTTP/1.0에선 프록시 요청의 경우 완전한 URI를 보내기로 하였습니다. HTTP/1.1 부턴 프록시, 서버 모두 완전한 URI를 요구하지만 아직 많은 레거시 클라이언트들이 부분 URI를 보냅니다.

#### 6.5.2. 가상 호스팅에서 일어나는 같은 문제

 가상 호스팅은 물리적으론 같은 웹 서버를 공유하지만 여러 도메인을 호스팅하는 방식을 말합니다. 앞서 언급한 부분 URI는 가상 호스팅 환경에서도 문제가 됐습니다. 

 프록시에선 완전한 URI를 요구하는 것으로 문제를 해결했지만 가상 호스팅에선 호스트와 포트 정보가 담겨있는 Host 헤더를 요구하는 것으로 해결했습니다.

#### 6.5.3. 인터셉트 프록시는 부분 URI를 받는다.

 6.5.1. 에서 프록시 요청은 완전한 URI를 요구한다고 했습니다. 하지만 클라이언트가 자신이 프록시와 대화하는지 모르면서 프록시와 대화할 수도 있습니다. 대리프록시, 인터셉트 프록시가 그 예입니다. 이때, 클라이언트는 자신이 원 서버와 대화한다고 생각하고 부분 URI를 보낼 수 있습니다.

 대리 프록시는 앞서 설명했듯이 원 서버의 호스트명과 IP를 사용하기 때문에 문제될 것이 없고, 원 서버의 IP는 대리 프록시가 알고 있습니다.

 인터셉트 프록시는 네트워크 사이에서 서버로 가는 트래픽을 가로채기 때문에 부분 URI를 얻게 됩니다.(그래서 어떻게 되는지...)

#### 6.5.4. 프록시는 프록시 요청과 서버 요청을 모두 다룰 수 있다.

 다목적 프록시라면 완전한 URI와 부분 URI 모두를 다룰 수 있어야 합니다. 어떻게 다루는 지는 아래와 같은 프로세스를 따릅니다.

1. 완전한 URI가 주어졌다면 그것을 사용합니다.
2. 부분 URI가 주어졌고 Host헤더가 있다면, Host 헤더를 이용해 원 서버의 이름과 포트번호를 알아냅니다.
3. 부분 URI가 주어졌으나 Host 헤더가 없다면 다음과 같은 경우의 수가 있습니다.
   1. 프록시가 대리 프록시라면, 프록시에 원 서버 주소와 포트번호가 설정되어 있을 것입니다.
   2. 이전에 인터셉트 프록시가 가로챘던 트래픽을 받았고, 이전에 가로챈 인터셉터 프록시가 해당 트래픽에 원 IP주소와 포트번호를 설정해두었다면 그 IP와 포트번호를 사용합니다.
   3. 모두 실패했다면 에러 메세지를 반환합니다.(Host헤더를 지원하는 최신 브라우저로 업그레이드 하라는 에러 메세지)

#### 6.5.5. 전송 중 URI 변경

 영향이 없을 것 같은 사소한 URI 변경도 문제를 일으킬 수 있습니다. 

 몇몇 프록시는 URI를 다음 홉으로 보내기 전에 포트번호를 기본 포트인 ':80'으로 설정한다던가, 잘못 사용된 예약어를 올바르게 교체하는 것 같은 표준 형식으로의 '정규화'를 진행합니다. 이런 변형도 상호운용성 문제를 일으킬 수 있습니다.

 프록시는 최대한 관대하게 메세지를 받아 넘겨야 합니다. 

 특히 HTTP명세에서 일반적인 인터셉트 프록시가 URI를 전달할때 절대 경로를 고쳐 쓰는 것을 금지합니다.(빈 경로를 '/'로 교체하는 건 허용합니다.) 

#### 6.5.6. URI 클라이언트 자동확장과 호스트명 분석(Hostname Resolution)

 브라우저는 프록시의 존재 여부에 따라 요청 URI를 다르게 분석합니다. 프록시가 없다면 사용자가 입력한 URI에서 호스트명을 찾고 그에 대응하는 IP 주소들을 연결에 성공할 때까지 시도합니다.

 호스트가 발견되지 않는다면 브라우저는 사용자가 호스트명을 완전히 입력하지 않은 것으로 간주하고 2장에서 살펴봤던 URL 확장을 시도합니다.

#### 6.5.7. 프록시 없는 URI 분석(URI Resolution)

  6.5.6.에서 명시적인 프록시가 없을 때의 과정을 사례를 들어 알아보겠습니다. 사용자가 URI에 'Oreilly'를 입력한 상황입니다.

1. 사용자가 'Oreilly'를 입력합니다.
2. 브라우저는 DNS로 호스트 'Oreilly'를 찾습니다. -> 실패
3. 브라우저는 'Oreilly'를 확장합니다.
   3.1. 앞에 'www', 뒤에 'com'을 붙여 'www.oreilly.com'로 URI를 확장했습니다.
   3.2. DNS로 'www.oreilly.com'을 찾습니다. -> 성공, IP주소 받음
4. 브라우저는 알아낸 IP주소들에 대해 성공할 때까지 접속을 시도합니다. -> 성공했다면 커넥션을 맺습니다.
5. 요청을 보내고 응답을 받습니다.

#### 6.5.8. 명시적인 프록시를 사용할 때의 URI 분석

 6.5.6. 에서 명시적인 프록시를 사용한다면 브라우저가 제공하는 URI 확장 없이 요청이 진행됩니다.

1. 사용자가 'Oreilly'를 입력합니다.
2. 브라우저는 사용하기로 설정된 프록시의 호스트 명과 DNS를 이용해 프록시의 IP를 알아냅니다.
3. 브라우저와 프록시가 커넥션을 맺습니다.
4. 브라우저는 기본 스킴과 경로만 추가해 프록시로 'http://oreilly/'라는 요청을 보냅니다.
5. 이후로는 프록시에 따라 달라집니다. URI 확장을 시도하는 프록시도 있지만 대부분 확장하지 않고 에러를 돌려줄 것입니다.

#### 6.5.9. 인터셉트 프록시를 이용한 URI 분석

 앞서 인터셉터 프록시는 클라이언트 입장에서 본인이 프록시와 대화하는지 모른다고 하였습니다. 그렇기 때문에 6.5.6.의 과정에서 인터셉트 프록시가 개입한다면 클라이언트는 URI 확장을 시도합니다.

1. 사용자가 'Oreilly'를 입력합니다.
2. 브라우저는 DNS로 호스트 'Oreilly'를 찾습니다. -> 실패
3. 브라우저는 'Oreilly'를 확장합니다.
   3.1. 앞에 'www', 뒤에 'com'을 붙여 'www.oreilly.com'로 URI를 확장했습니다.
   3.2. DNS로 'www.oreilly.com'을 찾습니다. -> 성공, IP주소 받음

 하지만 여기서 프록시가 없을 때와 인터셉트 프록시가 개입할때가 다른 과정을 보입니다. 프록시가 없을 땐 받아온 IP들중 연결에 성공할 때까지 접속을 시도합니다. 하지만 인터셉트 프록시가 개입하면 첫 번째 접속 시도로 끝납니다.

4. 브라우저가 첫 번째 접속을 시도하고 그 시도를 인터셉트 프록시가 가로챕니다. 브라우저는 첫 번째 접속 시도가 성공했다고 생각합니다.
5. 인터셉트 프록시가 원 서버와 대화할 준비가 되었을때 프록시는 원 서버에 장애가 있다는 것을 알게 됩니다. 
6. 인터셉트 프록시는 Host헤더를 찾아 DNS를 이용해 접속 시도할 수 있는 IP를 다시 받아 오던지, Host헤더가 없다면 요청 받은 IP를 역방향 DNS 룩업을 시행해 호스트명을 알아낸뒤 다시 다른 IP들을 알아옵니다.

---

### 6.6. 메세지 추적

 오늘날에 웹 요청이 서버로 가기 까지 둘 이상의 프록시를 지나는건 매우 흔한 일입니다. 프록시가 흔해지며 프록시를 넘나드는 메세지의 흐름을 추적하고 문제점을 찾아내는 것이 중요해 졌습니다.

#### 6.6.1. Via 헤더

 Via헤더 필드는 메세지가 지나는 중간 노드(프록시 및 게이트웨이)의 정보를 나열해줍니다. 한 노드를 지날 때 마다 해당 노드에 대한 정보가 Via 목록의 끝에 추가되어야 합니다. 

> Via : 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com

 위의 Via헤더 예시는 해당 메세지가 두개의 프록시를 거쳤음을 말해줍니다. 첫번째 프록시는 HTTP/1.1을 구현하는 proxy-62.irenes-isp.net 이라는 프록시이고 두번째는 HTTP/1.0을 구현하는 cache.joes-hardware.com 이라는 프록시입니다.

 프록시는 또한 네트워크의 라우팅 루프(마지막 목적지를 찾지 못하고 계속 looping 하는 현상)를 탐지하기 위해 Via 헤더를 사용할 수 있습니다. 프록시에서 받은 요청을 다른 곳으로 보낼때 자신의 정보를 Via헤더에 추가해야 하는데 추가 하기 전에 Via 헤더를 탐색해 라우팅 루프가 발견되는지 검사할 수 있습니다.



 **Via 문법**

 Via 헤더 필드는 쉼표로 구분된 경유지(Waypoint)의 목록입니다.
 각 경유지는 개별 프록시, 게이트웨이를 나타내며 프로토콜과 주소에 대한 정보를 담고 있습니다. 프로토콜 이름을 기입 할 수 있으며 기입 안한경우엔 HTTP로 간주합니다. 프로토콜 버전과 경유지 이름은 필수이며 선택적으로 코멘트를 추가할 수 있습니다.

 **Via 문법 - 프로토콜 이름**
 각 waypoint가 수신한 프로토콜입니다. HTTP라면 생략 가능하고 버전앞에 '/'로 구분되어 붙습니다.

 **Via 문법 - 프로토콜 버전**
 수신한 메세지의 프로토콜 버전입니다. 필수적으로 기입되어야 합니다.

 **Via 문법 - 노드 이름**
 중개자의 호스트와 포트번호입니다. 포트번호는 생략 가능하며 이 경우 사용하는 프로토콜의 기본 포트로 간주합니다. 가명으로 대체할 수 있습니다.

 **Via 문법 - 노드 코멘트**
 선택사항이며 자유롭게 기입할 수 있지만 주로 벤더나 버전 정보, 프록시에서 일어난 이벤트에 대한 진단 정보등을 넣습니다.



 **Via 요청과 응답 경로**

 요청, 응답 모두 Via 헤더를 갖습니다. TCP 커넥션의 경우 대부분 응답 메세지는 요청과 같은 경로로 되돌아갑니다. 요청시에 프록시 A, B, C를 지났다면 응답시엔 대부분 프록시 C, B, A를 지납니다.

 **Via와 게이트웨이**

 현대의 프록시는 게이트웨이의 기능도 같이 제공할 수 있습니다. Via 헤더엔 이런 프로토콜 변환이 기록되기 때문에 클라이언트 쪽에서 해당 프록시에 프로토콜 변환 기능이 있는지 확인할 수 있습니다.

> GET ftp://http-guide.com/pub/welcom.txt HTTP/1.0

 위와 같은 요청을 프록시로 보냈고 프록시가 FTP서버에 FTP 요청을 보내고 받아온 FTP응답을 HTTP로 변환해 클라이언트에게 돌려줍니다.

> HTTP/1.0 200 OK
> Date : Sun, 11 Nov 2001 21:01:59 GMT
> **Via : FTP/1.0 proxy.irenes-isp.net (Traffic-Server/5.0.1-17882 [cMsf])**
> Last-modified : Sun, 11 Nov 2001 21:05:24 GMT
> Content-type : text/plain
>
> Hi there~ This is FTP Server

 Via헤더에 기록된 수신 프로토콜이 FTP라는 것에 주의합시다. 클라이언트가 처음 FTP요청을 보냈기에 수신한 프로토콜이 기재됐습니다.

 **Server 헤더와 Via헤더**

 Server 헤더는 최종적인 목적지 서버가 사용하는 소프트웨어를 알려줍니다. 클라이언트가 요청한 원 서버를 위한 헤더입니다. 프록시에선 이 Server 헤더를 건드리면 안됩니다. 프록시가 무슨 소프트웨어를 사용하는지는 Via헤더의 코멘트에 기록하면 됩니다.

 **Via가 개인정보 보호와 보안에 미치는 영향**

 프록시가 방화벽의 일부인 경우엔 프록시 뒤에 있는 호스트의 이름과 포트를 전달해서는 안됩니다. 이때 프록시는 호스트 명을 적당한 가명으로 교체할 수 있습니다. 아래와 같이 말이죠.

> Via: 1.0 foo, 1.1 devirus.company.com, 1.1 access-logger.company.com

이 Via 헤더를

> Via: 1.0 foo, 1.1 concealed-stuff

 위와 같이 여러개의 경유지를 하나로 합쳐 숨길 수 있습니다. 하지만 이렇게 합쳐 숨기기 위해선 경유지들이 모두 같은 조직의 통제하에 있고 호스트가 이미 가명으로 교체되었어야 합니다. 그리고 수신된 프로토콜이 다를땐 다른 프로토콜들을 합쳐선 안됩니다. 

#### 6.6.2. TRACE 메서드

 앞 장에서 TRACE 메서드의 역할을 알아본적이 있습니다. TRACE 요청이 목적지 서버에 도착했을 때(혹은 바로 알아볼 Max-Forward값이 0인 요청을 받은 서버), 서버는 요청 메세지를 응답 메세지 본문에 넣어 응답 합니다. 

 **Max-Forward**

 Max-Forward 헤더는 TRACE요청이나 OPTIONS 요청에서 프록시 홉의 갯수를 제한할 수 있습니다. 메세지가 프록시 들을 계속 무한 루프 도는지 테스트 할 때나, 프록시 연쇄 중간의 특정 프록시 서버들의 효과를 체크할 때 사용됩니다.

 Max-Forward헤더는 이 메세지가 앞으로 몇 개의 홉을 더 거칠수 있는지를 말해주는 값을 가지고 있습니다. Max-Forward값이 0이라면 수신 프록시는 자신이 목적지 서버가 아니더라도 인바운드 방향으로 전달하지 말고 클라이언트 쪽으로 응답을 보내야 합니다.

 받은 Max-Forward값이 0이 아니면 다음 홉으로 전달시 Max-Forward 값을 1 줄여 보내야 합니다. 

 그리고 이런 Max-Forward가 작동하기 위해선 모든 프록시나 게이트웨이가 이 Max-Forward를 지원해야 합니다.

---

### 6.7. 프록시 인증

 프록시는 접근 제어 장치로 사용될 수 있습니다. 사용자가 유효한 접근 권한 자격을 프록시에 제출하지 않으면 프록시에서 요청을 차단할 수 있는데 이를 '프록시 인증' 메커니즘 이라고 합니다.

1. 제한된 콘텐츠에 대한 요청이 프록시에 도착.
2. 프록시는 접근 자격을 요구하는 407 Proxy Authorization Required 상태코드와 자격 제출 방식을 설명해주는 Proxy-Authenticate 헤더 필드를 클라이언트에게 보냅니다.
3. 407 응답을 받은 클라리언트는 로컬 DB를 찾던지, 사용자에게 물어보던지 여러 방식으로 요구 자격을 수집합니다.
4. 자격을 얻었다면 자격을 Proxy-Authenticate 헤더에 담아 다시 요청을 보냅니다.
5. 자격이 유효하다면 프록시는 다음 홉으로 메세지를 전달하고 유효하지 않다면 407응답을 보냅니다.

 프록시 인증은 인증에 참여하는 프록시가 프록시 연쇄상에 여러개 있을 경우 잘 작동하지 않습니다.(Proxy-Authenticate에 있는 값이 여러 프록시 인증 중 어디에 쓰여야 될지 모르므로.) 이를 해결하기 위해 프록시 연쇄의 특정 경유지와 인증 자격을 짝지어주는 HTTP 기능 확장이 제안 됐지만 많이 구현되진 않았습니다.

---

### 6.8. 프록시 상호운용성

 클라이언트, 서버, 프록시들은 각기 다른 프로토콜, 프로토콜 버전, 벤더 등을 가지고 있습니다. 따라서 이런 많은 기기들간의 상호운용성 문제는 항상 중요합니다.

#### 6.8.1. 지원하지 않는 헤더와 메서드 다루기

 기본적으로 프록시가 자신이 이해할 수 없는 메서드와 헤더를 만난다면 관대하게 그대로 보존해 전달해야 합니다. HTTP 명세에선 메서드와 헤더의 확장을 허용하기 때문에 항상 자신이 이해하지 못하는 메서드와 헤더를 염두에 두어야 합니다. 

 같은 이름의 헤더필드가 여러개 온다면 이 헤더필드의 상대적인 순서 역시 그대로 보존해야 합니다.

#### 6.8.2. OPTIONS: 어떤 기능을 지원하는지 알아보기

 앞 장에서 OPTIONS는 서버에게 특정 리소스에 대해 어떤 메서드를 지원하는지 묻는 메서드라고 했습니다. 

 OPTIONS 요청을 받은 서버는 특정 리소스에 대해 가능한 기능을 서술하는 여러 헤더를 추가할 수 있지만 HTTP/1.1 명세에서 정의한 헤더는 Allow 헤더 뿐입니다. 

#### 6.8.3. Allow 헤더

 기본적으로 Allow 헤더는 OPTIONS 요청에 대해 응답하기 위한 헤더입니다. 식별되는 자원에 대해 OPTIONS 요청을 하면 서버는 그 리소스에 지원되는 메서드나 서버가 지원하는 모든 메서드(요청 URI가 *인 경우)를 열거합니다.

> Allow : GET, HEAD, PUT
>
> -> 요청 리소스에 대해 GET, HEAD, PUT 요청이 가능하다.

 그런데 Allow 헤더가 요청에도 사용될 수 있습니다. 이때 Allow 헤더는 새 리소스가 지원했으면 하는 메서드를 추천하기 위해 사용되지만 서버가 이를 지원할 의무는 없습니다.

 프록시가 Allow에 있는 메서드를 이해할 수 없다고 해서 Allow 헤더를 수정하면 안됩니다.

---

### 마치며