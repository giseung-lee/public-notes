---
layout: post
title: HTTP 13 - 다이제스트 인증
---
{% assign imgurl=site.data.common.path.image|append: '/'|append: page.categories[1] %}

### 들어가며

 다이제스트 인증은 이전 12장에서 살펴본 기본 인증과 호환되는 기본 인증의 대체재입니다.

 기본 인증에서 사용한 base-64 인코딩은 쉽게 디코딩 되는 단점이 있었습니다. 다이제스트 인증은 비밀번호를 인코딩 하는 과정이 비가역적입니다. 다시 디코딩 할 수 없죠. 

 그리고 기본 인증에선 인코딩된 비밀번호 자체를 중간에 가로채 악용할 수 있었는데, 다이제스트 인증에선 nonce라는 기술을 사용해 이런 상황을 방지합니다. 

 하지만 다이제스트 인증 역시 현재는 거의 쓰이지 않습니다. 다이제스트 인증의 한계 역시 알아보겠습니다.

---

### 13.1. 다이제스트 인증의 개선점

 기본인증에 비해 발전된 다이제스트 인증의 특징은 다음과 같습니다.

- 비밀번호를 평문으로 전송하지 않습니다.
- 메세지를 중간에 가로채 재현하려는 악의적인 공격을 차단합니다.
- 구현 방법에 따라 메세지 내용 위,변조를 막을 수 있습니다.
- 그 외 몇몇 잘 알려진 형태의 공격을 막습니다.

#### 13.1.1. 비밀번호를 안전하게 지키기 위해 요약(digest) 사용하기

 다이제스트 인증은 비밀번호를 평문으로 보내지 않고 비밀번호에 대한 지문(fingerprint) 혹은 요약(digest)를 보냅니다. 이 요약(digest)는 비가역적으로 생성되기 때문에 base-64와 같이 디코드 할 수 없습니다.

 다이제스트 인증의 기본적인 동작 과정은 다음과 같습니다.

1. 클라이언트가 보호된 리소스를 요청합니다.
2. 서버는 401 Unauthorized와 함께 이름과 비밀번호를 요구합니다.
3. 사용자가 이름과 비밀번호를 입력하면 클라이언트 프로그램은 비밀번호에 대한 요약을 만들어 서버에게 보냅니다.
4. 서버는 요청 받은 요약과 서버가 가지고 있는 비밀번호로 만든 요약을 비교합니다.(서버는 평문 비밀번호가 아닌 다이제스트만 가지고 있을 수도 있습니다.)
5. 요약이 맞다면 요청받은 리소스를 제공해줍니다.

#### 13.1.2. 단방향 요약

 다이제스트 인증에서 사용하는 요약(digest)방법은 비가역적인 단방향 함수이고 어느 길이의 입력이든 일정한 길이의 압축으로 변환합니다.(무한한 경우의 수를 일정 길이로 요약하기 때문에 다른 입력같이 같은 요약을 나타내는 충돌이 발생할 수도 있지만, 이런 충돌이 일어날 확률은 무시할 수 있을 정도로 작습니다.) 

 많이 사용되는 요약함수인 MD5 (Message Digest #5)는 임의의 바이트 배열을 128비트로 요약합니다. 128비트는 약 2^128=1,000,000,000,000,000,000,000,000,000,000,000,000,000 가지의 요약을 만들 수 있기 때문에 충돌의 확률은 무시할수 있습니다.

 MD5 출력은 4비트씩 끊어 32자의 16진수 문자로 표현되기도 합니다. 다음은 MD5의 예시입니다. 

| 입력                                                         | MD5 요약                         |
| ------------------------------------------------------------ | -------------------------------- |
| "Hi"                                                         | C1A5298F939E87E8F962A5EDFC206918 |
| "bri:Ow!"                                                    | BEAAA0E34EBDB072F8627C038AB211F8 |
| "3.1415926535897"                                            | 475B977E19ECEE70835BC6DF46F4F6DE |
| "http://www.http-guide.com/index.htm"                        | C617C0C7D1D05F66F595E22A4B0EAAA5 |
| "WE hold these Truths to be self-evident, that all Men are created equal, that they are endowed by their Creator with certain unalienable Rights, that among these are Life, Liberty and the Pursuit of Happiness—That to secure these Rights, Governments are instituted among Men, deriving their just Powers from the Consent of the Governed, that whenever any Form of Government becomes destructive of these Ends, it is the Right of the People to alter or to abolish it, and to institute new Government, laying its Foundation on such Principles, and organizing its Powers in such Form, as to them shall seem most likely to effect their Safety and Happiness." | 66C4EF58DA7CB956BD04233FBB64E0A4 |

 요약 함수는 보통 '암호 체크섬(cryptographic checksums)' 이라고 불리며, 단방향 해시함수 이거나 지문 함수(fingerprint function) 입니다.

#### 13.1.3. 재전송 방지를 위한 난스(nonce) 사용

 하지만 요약만 가지고는 기본 인증에서 나타난 취약점을 해결하지 못합니다. 중간에 요약을 가로챈다면 그 요약으로 서버에게 요청을 보낼 수 있기 때문입니다. 이런 종류의 공격을 '재전송 공격'이라고 합니다.

 재전송 공격을 방지하기 위해 사용되는게 난스(nonce) 입니다. 서버는 클라이언트에게 매 요청마다 바뀌는 값인 난스를 WWW-Authenticate 헤더에 담아 보냅니다.(클라이언트 쪽에서 요약을 만들때 사용한 난스를 보내기도 합니다.)

 난스는 요약이 만들어지기 전 비밀번호에 섞이게 됩니다. 난스를 섞은 비밀번호를 요약으로 만들면 재전송 공격을 방지할 수 있습니다.

 난스를 사용하지 않은 다이제스트 인증은 기본 인증 만큼 보안에 취약합니다.

#### 13.1.4. 다이제스트 인증 핸드셰이크

 다음은 다이제스트 인증과정의 예시입니다. 

![digest.png]({{ imgurl }}/digest.png)

---

### 13.2. 요약 계산

 다이제스트 인증의 핵심은 공개 정보, 비밀 정보, 난스 값을 조합해 비가역적인 요약(digest)를 만드는 것입니다. 

#### 13.2.1. 요약 알고리즘 입력 데이터

 요약 알고리즘엔 아래의 요소들이 필요합니다.

- 해시 함수 H(d) : d는 데이터입니다.
- 요약 함수 KD(s, d) : s는 비밀(secret), d는 데이터입니다.
- 보안 정보를 담고 있는 데이터 : 앞으로 A1이라 부릅니다.
- 요청 메세지의 보안 정보가 아닌 데이터 : A2라 부릅니다.

 H와 KD를 사용해 A1과 A2의 요약을 만들어 냅니다.

#### 13.2.2. H(d)와 KD(s,d) 알고리즘

 해시 함수에 사용되는 알고리즘은 여러가지가 있지만 RFC2617에선 MD5와 MD5-sess('sess'=세션)를 사용하며 알고리즘을 명시하지 않았다면 MD5가 기본으로 사용됩니다.

- H(d) = MD5(d)
- KD(s, d) = H('s:d') = MD('s:d')

 요약 함수 KD는 입력받은 비밀정보와 데이터를 콜론으로 연결해 해시 함수 H로 보냅니다. 해시함수 H는 해시 값을 만들기 위해 설정된 알고리즘으로 데이터를 보냅니다.

#### 13.2.3. 보안 관련 데이터(A1)

 A1이라 불리는 데이터 덩어리는 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 정보로 이루어져 있습니다. A1을 계산하는 방법 중엔 다음과 같은 방법이 있습니다.

 **MD5**

 모든 요청마다 단방향 해시를 실행함. 사용자이름, 영역, 비밀번호를 콜론으로 연결한 것.

 **MD5**

 사용자이름, 영역, 비밀번호에 대한 해시를 계산한 뒤에 서버로 부터 받은 난스와 클라이언트 난스(c난스)를 콜론으로 붙인 것입니다.

| 알고리즘 | A1                                                      |
| -------- | ------------------------------------------------------- |
| MD5      | A1 = <사용자이름>:<영역>:<비밀번호>                     |
| MD5-sess | A1 = MD5(<사용자이름>:<영역>:<비밀번호>):<난스>:<c난스> |

#### 13.2.4. 메세지 관련 데이터(A2)

 A2데이터는 URL, 요청 메서드, 엔터티 본문 같은 보안 관련 정보가 아닌 정보들입니다. A2 역시 요약을 만들어 내기 위해 사용됩니다. RFC2617에선 보호 수준(quality of protection, qop)에 따라 A2의 사용법을 정의하고 있습니다.

| qop           | A2                                                  |
| ------------- | --------------------------------------------------- |
| 정의되지 않음 | <요청 메서드>:<uri 지시자 값>                       |
| auth          | <요청 메서드>:<uri 지시자 값>                       |
| auth-int      | <요청 메서드>:<uri 지시자 값>:H(<요청 엔터티 본문>) |

 uri 지시자 값은 요청줄에서 가져온 요청 URI 입니다.

#### 13.2.5. 요약 알고리즘 전반

 RFC 2617에선 qop에 따라 두가지 요약 계산 알고리즘을 제시하고 있습니다.

 앞선 13.2.1.~13.2.4. 의 종합이라고 볼 수 있습니다.

| qop                | 요약 알고리즘                                 | 비고                                     |
| ------------------ | --------------------------------------------- | ---------------------------------------- |
| 정의되지 않음      | KD( H(A1) , <난스>:H(A2) )                    | deprecated. RFC2069와의 호환을 위해 남김 |
| auth 혹은 auth-int | KD( H(A1) , <난스>:<nc>:<c난스>:<poq>:H(A2) ) | (책이 쓰여질 당시) 선호되는 방법         |

#### 13.2.6. 다이제스트 인증 세션

 인증 세션이란 말 그대로 한 번의 인증이 유효한 단위입니다.

 서버가 WWW-Authenticate를 인증요구를 하고 클라이언트가 이에 응답을 했다면 인증 세션이 시작됩니다.

 인증 세션은 다른 WWW-Authenticate 인증요구를 받을 때까지 지속됩니다. 클라이언트는 그동안 이름, 비밀번호, 난스, 난스횟수 등 현재 인증 세션에 대한 값들을 기억해야 합니다.

#### 13.2.7. 사전(preemptive) 인가

 일반적인 인증은 [요청 -> 인증요청(난스 포함 전송) -> 인증요청에 대한 응답 -> 인증 성공 및 원 요청에 대한 응답] 와 같은 사이클이 반복됩니다. 

 사전 인가는 이와 같은 사이클이 반복 될 것임을 예상하고 요청에 대한 응답을 보낼때 다음 요청에 쓰일 난스를 같이 전송 합니다. 

 아래의 그림을 보는게 훨씬 도움이 될 것입니다.

![preemptive_authorization.png]({{ imgurl }}/preemptive_authorization.png)

 이 사전 인가는 HTTP의 기본인증에선 매우 당연한 것입니다. 서버에게 받을 난스가 없기 때문이죠. 하지만 다이제스트 인증에선 난스를 주고받아야 합니다. 

 이를 위해 서버는 다음 난스를 아래와 같은 방법으로 다룰 수 있습니다.

- 다음 난스 미리 생성
  - Authentication-Info : nextnonce="<난스값>" 와 같이 다음 난스를 미리 생성해 전해줍니다. 다만 이 방법은 앞장에서 본 회전 지연(latency)을 방지하기 위한 기술은 파이프라이닝과 상충하기 때문에 단점이 더 큽니다.
- 제한된 난스 재사용
  - 한 난스를 정해진 횟수, 혹은 짧은 시간 동안 재사용하도록 허락합니다. 이 경우 파이프라이닝과 함께 사용할 수 있습니다. 횟수를 다쓰거나, 시간이 지나면 다시 난스를 받아와야 합니다.
  - 다만 이 방법에서 횟수나 시간이 길어진다면 성능은 올라가지만 재사용하고 있는 난스를 중간에 탈취해 사용하는 재전송 공격에 취약해집니다.
- 동기화된 난스 생성
  - 클라이언트와 서버가 공유하고 있는 비밀키를 이용해 클라이언트와 서버가 순차적으로 각자 같은 난스를 생성하도록 합니다.

#### 13.2.8. 난스 선택

 RFC 2617에선 다음과 같은 가상의 나스 공식을 제안했습니다.

- BASE64(타임스탬프 H(타임스탬프 : Etag : 개인키))

 타임 스탬프는 서버에서 생성된 시간 혹은 반복 불가능한 임의의 값이면 됩니다. Etag는 엔터티 태그이며 개인키는 서버만 알고 있는 값입니다. 

#### 13.2.9. 상호 인증

 웹이 발전하며 요청은 여러 프록시를 거치게 되고 그 중 악의적인 프록시의 공격이 있을 수도 있기 때문에 클라이언트가 서버를 인증할 수 있는 방법도 고안되었습니다. 이 방법은 상호 인증이라 부르며 RFC 2617에 포함되었습니다.

 상호 인증은 서버가 클라이언트에게 클라이언트 난스(c난스)를 전송하므로 이루어집니다. 

 

---

### 13.3. 보호 수준(Quality of Protection) 향상

#### 13.3.1. 메세지 무결성 보호

#### 13.3.2. 다이제스트 인증 헤더

---

### 13.4. 실제 상황에 대한 고려

#### 13.4.1. 다중 인증요구

#### 13.4.2. 오류 처리

#### 13.4.3. 보호 공간(Protection Space)

#### 13.4.4. URI 다시 쓰기

#### 13.4.5. 캐시

---

### 13.5. 보안에 대한 고려사항

#### 13.5.1. 헤더 부당 변경

#### 13.5.2. 재전송 공격

#### 13.5.3. 다중 인증 메커니즘

#### 13.5.4. 사전(dictionary) 공격

#### 13.5.5. 악의적인 프록시와 중간자 공격(Man-in-the-Middle Attack)

#### 13.5.6. 선택 평문 공격

#### 13.5.7. 비밀번호 저장

---

### 마치며 
