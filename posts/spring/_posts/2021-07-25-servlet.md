---
layout: post
title: servlet & servlet container
---

# 개요

---

프레임워크는 편리하지만 그 만큼 감추는게 많기 때문에 내부 동작원리를 파악하기 어렵다.

스프링 부트를 주로 쓰지만 스프링 레거시를 사용할 때마다 초기 셋팅에서 애를 먹곤한다. 스프링 부트를 사용할 땐 신경쓸 필요 없던 것들을 직접 셋팅 해줘야 한다.

관련해서 구글링 해본 결과 우선 서블릿과 서블릿 컨테이너에 대해 먼저 정리할 필요를 느꼈다.

# HTTP 통신과 Java EE

---

HTTP로 메세지를 주고받기 위해서는 해야할 일들이 있다. 

- TCP/IP 연결 관리
- HTTP 메세지 수신
- HTTP 메세지 해석 (메서드, 헤더, 비다 분리 등..)
- HTTP 메시지에 대한 처리 (응답 생성)
- HTTP 메시지 발송

하지만 실제 개발자들이 

서블릿이 실제 메세지를 처리하는 역할을 하고, 서블릿 컨테이너가 서블릿의 생명주기를 관리하고 네트워크와 관련한 처리를 함. 

> 웹 서비스는 서블릿 컨테이너가 전달받은 HTTP 메시지를 서블릿에 전달하고, 이 서블릿이 작동함으로써 결과가 클라이언트에 반환되는 과정을 말합니다.
> - 웹 프로그래머를 위한 서블릿 컨테이너의 이

# 서블릿

---

`javax.servlet.Servlet` 인터페이스를 구현한 것. 해당 인터페이스 자체는 아래와 같이 매우 간단함. 

```java
public interface Servlet {
    void init(ServletConfig var1) throws ServletException;

    ServletConfig getServletConfig();

    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;

    String getServletInfo();

    void destroy();
}
```

서블릿 컨테이너가 서블릿 관리하는 방법도 이미 스펙에 정의되어 있기 때문에 `Servlet` 인터페이스를 서블릿 컨테이너에서 동작할 수 있도록 미리 구현해놓음.
그게 하단의 `jakarta.servlet.GenericServlet`임. 

```java
public abstract class GenericServlet implements Servlet, ServletConfig, Serializable {
    private static final long serialVersionUID = 1L;
    private transient ServletConfig config;

    public GenericServlet() {
    }

    public void destroy() {
    }

    public String getInitParameter(String name) {
        return this.getServletConfig().getInitParameter(name);
    }

    public Enumeration<String> getInitParameterNames() {
        return this.getServletConfig().getInitParameterNames();
    }

    public ServletConfig getServletConfig() {
        return this.config;
    }

    public ServletContext getServletContext() {
        return this.getServletConfig().getServletContext();
    }

    public String getServletInfo() {
        return "";
    }

    public void init(ServletConfig config) throws ServletException {
        this.config = config;
        this.init();
    }

    public void init() throws ServletException {
    }

    public void log(String message) {
        this.getServletContext().log(this.getServletName() + ": " + message);
    }

    public void log(String message, Throwable t) {
        this.getServletContext().log(this.getServletName() + ": " + message, t);
    }

    public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;

    public String getServletName() {
        return this.config.getServletName();
    }
}
```

그런데 사실 `GenericSevlet` 역시 직접 구현해서 사용하진 않음. 개발자가 직접 구현해서 사용하는 건 `GenericSevlet`를 구현한 `jakarta.servlet.http.HttpServlet`임

양이 많아 구현부분은 지우고 메서드 선언만 가져옴.

```
public abstract class HttpServlet extends GenericServlet {
    private static final long serialVersionUID = 1L;
    private static final String METHOD_DELETE = "DELETE";
    private static final String METHOD_HEAD = "HEAD";
    private static final String METHOD_GET = "GET";
    private static final String METHOD_OPTIONS = "OPTIONS";
    private static final String METHOD_POST = "POST";
    private static final String METHOD_PUT = "PUT";
    private static final String METHOD_TRACE = "TRACE";
    private static final String HEADER_IFMODSINCE = "If-Modified-Since";
    private static final String HEADER_LASTMOD = "Last-Modified";
    private static final String LSTRING_FILE = "jakarta.servlet.http.LocalStrings";
    private static final ResourceBundle lStrings = ResourceBundle.getBundle("jakarta.servlet.http.LocalStrings");
    private final Object cachedAllowHeaderValueLock = new Object();
    private volatile String cachedAllowHeaderValue = null;

    public HttpServlet()

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException

    protected long getLastModified(HttpServletRequest req)

    protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException

    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException 

    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException 

    protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException 

    private void sendMethodNotAllowed(HttpServletRequest req, HttpServletResponse resp, String msg) throws IOException 

    private String getCachedAllowHeaderValue()

    private static Method[] getAllDeclaredMethods(Class<?> c)

    protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException

    protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
    
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException

    private void maybeSetLastModified(HttpServletResponse resp, long lastModified)

    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException

    private static class NoBodyAsyncContextListener implements AsyncListener

    private static class NoBodyPrintWriter extends PrintWriter

    private static class NoBodyOutputStream extends ServletOutputStream

    private static class NoBodyResponse extends HttpServletResponseWrapper

    private static class TomcatHack
}
```

주목할 만한 점은 `javax.servlet.Servlet` 에서 부터 계속 추상 메서드로 내려오던 `service` 메서드를 구현한 것이다.

`service` 메서드에선 HTTP 메세지의 메서드를 읽고 `doGet`, `doPost`, `doDelete` 등 적합한 메서드를 찾아 처리한다.

그래서 `jakarta.servlet.http.HttpServlet` 를 직접 구현할 땐 용도에 맞게 `doGet`, `doPost` 등을 오버라이딩한다. 

# 서블릿 컨테이너

---
 
웹 컨테이너, 컨테이너라고도 불림.

아파치 톰캣, 제티, 그리즐리 등..

목적은 서블릿을 관리하고 동작 시키는 것.
 
HTTP 메세지를 받았을때 해석하는 역할을 함. 해석해서 해당 메세지를 처리할 서블릿을 찾고, 서블릿의 적합한 메서드를 호출함. 

# 톰캣

'배치' 한다. -> tomcat의 webapps 에 디렉터리 만들면 그게 배치한거임. 그 디렉터리엔 `WEB-INF > classes` 폴더랑 web.xml 파일만 있으면 됨. 

web.xml -> 어느 url을 어느 servlet이 담당할 건지 맵핑. 
