---
layout: post
title: 기본 인증
---
{% assign imgurl=site.imgbase|append: page.categories[-1] %}

### 들어가며

 웹 상의 개인정보 보호를 위해 서버는 각 사용자를 식별하고 그 사용자만 볼 수 있거나, 그 사용자에게 허가된 콘텐츠만 보여줍니다.

 이와 같은 일을 하기위해 필요한건 사용자들을 식별하는 일이고 이를 인증이라고 부릅니다. HTTP에선 기본적인 인증 방법을 제공합니다. 이 포스팅이 쓰여지고 있는 요즘엔 HTTP '기본 인증'은 거의 안쓰이지만 간단하게 알아보고 가겠습니다.

---

### 12.1 인증

#### 12.1.1. HTTP의 인증요구/응답 프레임워크

 HTTP는 인증에 필요한 인증요구/응답 프레임워크를 제공합니다. 프레임워크의 동작 과정은 단순합니다.

1. 클라이언트가 인증이 필요한 리소스를 요청
2. 서버가 개인 정보를 요구하는 '인증요구'로 응답
3. 클라이언트 프로그램이 사용자에게 이름, 비밀번호를 물어봄
   ![authentication2.png]({{ imgurl }}/authentication2.png)
   (크롬에선 이런 식으로 물어봅니다.)
4. 사용자가 이름, 비밀번호를 입력하면 서버에게 인증 정보를 담아 다시 요청
5. 이름, 비밀번호가 맞다면 서버가 리소스를 전해줌

#### 12.1.2. 인증 프로토콜과 헤더

 위 과정에서 쓰이는 헤더들을 알아보겠습니다.

| 단계     | 헤더                | 설명                                                         | 메서드/상태      |
| -------- | ------------------- | ------------------------------------------------------------ | ---------------- |
| 요청     |                     | 첫 번째 요청에는 인증 정보가 없다.                           | GET              |
| 인증요구 | WWW-Authenticate    | 401 상태코드와 같이 사용되어 인증 정보를 요구함. WWW-Authenticate 헤더에는 접근하고 있는 보안 영역에 대해 설명함. | 401 Unauthorized |
| 인증     | Authorization       | 이름, 비밀번호를 기술해 다시 요청을 보냄                     | GET              |
| 성공     | Authentication-Info | 인증 정보가 맞다면 요청한 리소스와 함께 응답. Authentication-Info는 선택적인 헤더인데 여기에 인증 세션에 관한 정보를 넣어 보내는 서버도 있음. | 200 OK           |

![authentication.png]({{ imgurl }}/authentication.png)

#### 12.1.3. 보안 영역

 위에서 WWW-Authenticate헤더는 접근하고 있는 '보안 영역'에 대해 설명한다고 했습니다. 웹 서버는 보안이 필요한 문서들을 보안 영역(realm)별로 나눕니다. 회사 내부에서 재무팀이 있고 기술팀이 있다면 해당 리소스들은 해당 팀원들에게만 공개되야 하므로 'finance' realm과 'tech' realm이 있을 수 있습니다. realm에 'executive-commitee@company.com' 처럼 호스트 명을 넣어 사용하기도 합니다.

 ![security_realm.png]({{ imgurl }}/security_realm.png)

---

### 12.2. 기본 인증

 HTTP에서 지원하는 인증엔 '기본 인증'과 '다이제스트 인증'이 있습니다. 그중 기본 인증은 매우 간편합니다.

#### 12.2.1. 기본 인증의 예

 기본 인증의 과정을 예시와 함께 다시 짚어봅니다.

1. 사용자가 가족 사진인 /family/jeff.jpg를 요청
2. 서버가 이름과 비밀번호를 요구하는 401 Authorization Required 응답을 WWW-Authenticate: Basic realm='family'와 함께 보냄
3. 401 응답을 받은 브라우저는 사용자 이름, 비밀번호를 요구하는 대화상자를 띄우고 입력받음
   ![authentication2.png]({{ imgurl }}/authentication2.png)
4. 브라우저는 받은 이름과 비밀번호를 ':' 으로 이어 붙이고 base-64 방식으로 인코딩해 Authorization 헤더에 담아 다시 요청 보냄
5. 다시 요청 받은 서버는 이를 디코딩해 이름과 비밀번호가 맞는지 확인함. 문제 없다면 200 OK와 함께 요청 받은 문서를 돌려줌

  기본 인증에선 위에서 살펴본 헤더중 'Authentication-Info' 헤더는 사용되지 않습니다.

#### 12.2.2. Base-64 사용자 이름/비밀번호 인코딩

 사용자가 이름, 비밀번호를 입력하면 브라우저는 '이름:비밀번호' 를 base-64방식으로 인코딩해 보냅니다. base-64 인코딩은 8비트 이진데이터를 그에 해당하는 64진법 수로 바꾸는 인코딩입니다. 

![base64.png]({{ imgurl }}/base64.png)

 ```0010 1100 -> 44 -> s``` 처럼 작동합니다. 이 base64인코딩을 사용하면 이진 데이터, 텍스트, Unicode 문자 등의 데이터를 전송가능한 알파벳 및 숫자로 변환 할 수 있습니다. HTTP 헤더에 사용할 수 없는 특수문자들도 사용할 수 있습니다. 

#### 12.2.3. 프록시 인증

 이 같은 인증과정을 프록시에서 수행할 수도 있습니다. 프록시에서의 인증은 상태코드와 헤더명만 다르고 절차는 같습니다.

| 웹 서버                | 프록시 서버               |      |
| ---------------------- | ------------------------- | ---- |
| 비인증 상태 코드 : 401 | 비인증 상태 코드 : 407    |      |
| WWW-Authenticate       | Proxy-Authenticate        |      |
| Authorization          | Proxy-Authorization       |      |
| Authentication-Info    | Proxy-Authentication-Info |      |

---

### 12.3. 기본 인증의 보안 결함

 기본 인증은 사용하기 쉽지만 보안상 문제가 많습니다.

1. base-64만으로 인코딩 하는건 너무 취약합니다. base-64 인코딩은 애초에 보안 자체가 목적이 아니기 때문에 누구나 쉽게 디코딩 할 수 있습니다.([https://www.base64decode.org/](https://www.base64decode.org/)) 디코딩 해주는 웹 사이트도 많고 시간만 있다면 종이와 펜으로도 디코딩 할 수 있습니다. base-64인코딩은 그저 읽기 힘들게 만들어줄 뿐입니다.
2. base-64가 디코딩 되기도 쉽지만 디코딩을 안하고 인코딩 된 그대로를 가져와 악의적으로 사용할 수도 있습니다. 인코딩된 상태로 가져와 그 문자로 서버에 접속을 시도할 수 있습니다.
3. 매 사이트마다 이름과 비밀번호를 다르게 쓰고 기억하는건 매우 번거롭기 때문에 대부분의 사람은 같은 이름, 비밀번호를 많은 사이트에서 같게 사용합니다. 온라인 쇼핑몰에서 탈취한 이름, 비밀번호로 은행 사이트에 접속 시도할 수도 있습니다.
4. 프록시가 개입하는 경우 정상적으로 작동하지 않을 수도 있습니다.
5. 가짜 위장 서버에 취약합니다. 가짜 서버에서 이름과 비밀번호를 요구하고 탈취해갈 수 있습니다.

 기본 인증 방법을 실제 웹사이트에서 사용 못해본 사람들도 많을 것입니다.(제가 그렇습니다.) 기본 인증 방법 자체만으론 문제가 많기 때문에 HTTP에서도 다음장에서 살펴볼 '다이제스트 인증'을 만들었고, 14장에서 살펴볼 보안 암호화 기술도 등장하였습니다. 

---

### 마치며 

 매우 간단한 장이었습니다.