---
layout: post
title: C Unmanaged Programming 4 - 포인터 (작성중)
---
{% assign imgurl=site.imgbase|append: page.categories[-1] %}



- 해당 포스팅은 [Kim Pope 선생님의 C 언매니지드 프로그래밍 강의](https://www.udemy.com/course/c-unmanaged-programming-by-pocu/)를 정리하며 사견을 붙인 것입니다.

- 포스팅 내 목차는 동영상강의 기준입니다.



## 87. 포인터

---

- 앞서 스택메모리를 알려드린건 지금 이 포인터를 배우기 위함입니다.
- 포인트 뒤로 나오는 모든 것들엔 포인터가 필요하다고 보시면 됩니다.
- 선생님이 C에서 중요하다고 생각하는 세 가지는 다음과 같습니다.
  - 포인터
  - 동적 메모리 할당
  - 구조체, 공용체를 포인터, 동적 메모리와 함께 쓰는 법

### 개발자가 직접 메모리 주소를 이용해 데이터를 바꿀 수 있나요?

- 다른 언어였다면 불가능 하지만 C에선 가능합니다. 이걸 잘하면 매우 강력한 일을 할 수 있지만, 잘못 건드리면 흐흐.. 😈
- C가 위험하다, 강력하다 모두 이 포인터 때문입니다.

## 88. 주소 연산자 \&

---

- 직접 메모리 주소로 변수를 조작하려면 우선 해당 변수의 주소를 알아야 합니다.

- 아래 코드를 실행해 봅시다.

  ```c
  void print_address(void){
      int num = 10;
      printf("address of num is %p\n", (void*)&num);
  }
  int main(void){
      print_address();
      return 0;
  }
  /*
  address of num is 00000068ED6FF914
  */
  ```

- \&를 주소 연산자라고 합니다. (비트연산자 \&와 헷갈리지 맙시다. 비트연산자 \&는 피연산자가 2개입니다.)

  - \&뒤에 오는 변수의 주소를 돌려줍니다.

- 주소를 표현할 땐 16진수를 사용합니다. 

  - printf 에서 "%p" 를 사용하면 주소를 16진수로 보여줍니다.

- 실행할 때 마다 주소가 바뀝니다. (보안 강화를 위해 실행할 때마다 프로그램이 올라가는 주소가 바뀝니다. - ASLR 이라고 합니다.)



## 89. 메모리 주소 저장하기

---

- \& 연산자로 주소를 구할 수 있다는 걸 배웠습니다. 그럼 이 주소를 어떻게 변수에 저장할까요.

  - 어차피 16진수 숫자니까 int에 저장하면 되지 않을까요!! 👉 컴파일 에러 납니다.

    ```c
    void try(void){
    	int num = 10;
    	int num_addr = &num;
    }
    /*
    error: incompatible pointer to integer conversion initializing 'int' with an expression of type 'int *'; remove &
    */
    ```

- 앞으로 '주소'와 '값'이 계속 언급 될 텐데 둘을 잘 구분합시다. 주소는 값의 메모리 위치.

- 주소를 저장하기 위한 특별한 변수가 있습니다.

  - 그 변수가 바로 **포인터**입니다.
  - 포인터 is 변수



## 90. 포인터의 의미

---

- 포인터란 주소를 저장하기 위한 변수**형**입니다.
- 포인터는 변수입니다. 메모리 주소를 저장하는 변수요.
- 포인터를 다른 복잡한 정의로 이해하면 앞으로 더 복잡해집니다. 포인터는 그냥 변수에요.



## 91. 메모리 주소에 저장된 자료형

---

- 주소에 저장된 자료형은 뭘까요?
  - 하드웨어는 신경쓰지 않습니다. 비트패턴을 char로 읽으면 char고, int로 읽으면 int고, float으로 읽으면 float입니다.
- 근데, 해당 주소에서부터 몇 바이트를 읽어야 하는지(나는 이 주소에서 몇 바이트를 갈거야! 같은것)는 하드웨어에게 알려줘야 합니다.
- 포인터 변수를 선언할 때 그 주소에 어떤 형의 데이터가 있는지 명시해줘야 합니다.
  - int 포인터, float 포인터, char 포인터 이런 식입니다.
  - 어떤 변수에 주소가 있는데 그걸 int 로 읽어라, float으로 읽어라, char로 읽어라



## 92. 포인터 변수를 선언하는 방법

---

- 자료형 뒤에 \*를 붙여 포인터 변수를 선언합니다.

  ```c
  void save_address(void){
  	int num = 10;
  	int* num_addr = &num;
  }
  ```

  - int\*, char\*, float\* 모두 가능합니다.

- `int *variableName;` 으로 써도 되지만 우리는 `int* variableName;`을 씁시다.



## 93. 포인터 변수를 부르는 방법

---

- 한국에선 보통 'int 포인터' 라고 부릅니다.
- 영어로는 'pointer to an int' 라고 부릅니다.
- 포인터 읽는 법은 중요합니다. 뒤에 포인터를 어떻게 읽느냐에 따라 중요해지는 부분이 있습니다. 선생님은 영어식 표현을 선호하는 것 같습니다.
- 포인터는 메모리 주소를 저장하는 변수.
  - 그럼 포인터의 내용은 어디에 저장되죠? 👉 당연히 메모리 어딘가에
  - 다른 위치를 가리키는 변수여서 '포인터'라고 부릅니다.
- 처음 공부할 때 모눈종이 사서 메모리 그려보면서 하시길 추천합니다.
  - 눈으로만 보면서 편하게 하면 머리에 안남습니다. 걸렸네..😅



## 94. 포인터 변수의 실제 메모리 뷰

---

- 디버거와 오브젝트 코드를 까서 실제 메모리 보는 중..
- 메모리 보다보면 주소가 뒤집혀 보이는걸 볼 수 있습니다.
- 데이터가 끝나는 마지막 단위를 가장 작은 메모리 주소에 위치해 메모리 주소를 뒤집어 저장하는 방식을 '리틀 엔디언' 이라고 합니다. [참고](https://ko.wikipedia.org/wiki/엔디언)
  - 요즘 나오는 인텔, amd 리틀 엔디언 방식입니다.  빅 엔디언은 옛날 cpu들입니다.
  - POCU 학생이라면 '소프트웨어 공학용 수학' 시간에 배웠습니다.
  - 들어야 되나.. 



## 95. 포인터의 비유 : 현실 세계 예

---

- 기술적인 설명은 위에 나온 것으로 끝입니다. 현실 세계로 비유를 한 번 해보겠습니다.
- 패쓰



## 96. 다른 포인터의 예

---

- int 포인터 말고 다른 포인터도 쓸 수 있습니다.

- 각 코드들을 디버그 찍어서 값 뽑아보고, 오브젝트 코드 열어서 주소 구경해봅시다.

  ```c
  void save_address(void){
  	char num = 10;
  	char* num_addr = &num;
  }
  ```

  ```c
  void save_address(void){
  	short num = 10;
  	short* num_addr = &num;
  }
  ```

  ```c
  void save_address(void){
  	float num = 10;
  	float* num_addr = &num;
  }
  ```

  ```c
  void save_address(void){
  	double num = 10;
  	double* num_addr = &num;
  }
  ```

  

## 97. 포인터에 저장된 주소도 바꿀 수 있나요?

---

- 포인터도 변수니까 당연히 변경 가능합니다.
- 포프 선생님 강의는 하나 하나가 굉장히 짧으십니다. ~~(대신 총 동영상수 342개...)~~



## 98. 역 참조 연산자 \*

---

- 포인터도 변수이기 때문에 변수가 쓰이는 것처럼 거의 사용 가능합니다.

- 매개변수로 전달할 수도 있습니다.

  ```c
  void do_something(int* addr){
  	/* do someting */
  }
  
  int main(void){
  	int num = 100;
  	do_something(&num);
  }
  ```

- 주소를 받았다면 그 주소를 역으로 추적해서 값을 찾을 수도 있습니다. 그때 사용하는 게 역 참조 연산자 \*입니다.

  ```c
  void do_something(int* addr){
  	/* do someting */
      printf("num : %d\n",*addr)
  }
  
  int main(void){
  	int num = 100;
  	do_something(&num);
  }
  ```

- 곱하기 아니에요. 포인터 변수 앞에 달려서 그 포인터 주소에 있는 곳으로 가 값을 읽어와라!



## 99. 참조와 역 참조

---

- '참조'라는 단어는 언급하지 않았지만 포인터가 계속 하고 있던일을 '참조'라고 합니다.
  - 변수의 값을 직접 가져다 쓰는게 아니라 그게 어디 있다고 '참조'만 하는 것입니다.
- 역 참조는 반대로 직접 그 주소로 가서 값에 접근하는 것입니다.
- 이 '역 참조'를 '간접(indirect) 연산자'라고도 합니다. 값에 직접 접근하는게 아니라 주소를 타고 한 번 거쳐서 간다는 뜻으로말입니다.
- indirection은 프로그래머의 자질을 알아보는 요소중 하나로 보는 곳도 있습니다.
  - 컴퓨터 구조에서 데이터를 오래 메모리에 저장하는 방법이기도 하고.. 추상적 개념을 이해할 수 있는지 알아보는 것이기도 하고...



## 100. 역 참조를 이용한 값 변경 예

---

- 역 참조를 이용해 값을 바꿀 수 있습니다.

  ```c
  int main(void){
  	int num = 50;
  	pritnf("origin : %d", num);
  
  	int* addr = &num;
  	*addr = 100;
  	printf("modified : %d", num);
      
  	return 0;
  }
  /*
  origin : 50
  modified : 100
  */
  ```

- 포인터 변수 선언할 때랑 역 참조 걸때랑 헷갈릴 수도 있으니 포인터 변수 선언할 땐 반드시 `int *num` 하지 말고 `int* num` 합시다.

## 101. 포인터로 두 변수의 값 바꾸기

---

- 모두가 작성해 봤을 법한 swap()메서드

  ```c
  void swap(int a, int b){
  	int temp = a;
  	a = b;
  	b = temp;
  }
  
  int main(void){
  	int a = 10;
  	int b = 20;
  	printf("%d, %d\n", a, b);	
  	swap(a, b);
  	printf("%d, %d\n", a, b);
  }
  /*
  10, 20
  10, 20
  */
  ```

  - 이게 안되는 이유는 말 안해도 알죠잉 C#에선 이거할 때 매개변수에 ref 를 붙이므로써 가능 했습니다.

- C에선 이때 포인터를 쓰는 겁니다.

  ```c
  void swap(int* a, int* b){
  	int temp = *a;
  	*a = *b;
  	*b = temp;
  }
  
  int main(void){
  	int a = 10;
  	int b = 20;
  	printf("%d, %d\n", a, b);	
  	swap(&a, &b);
  	printf("%d, %d\n", a, b);
  }
  /*
  10, 20
  20, 10
  */
  ```

  

## 102. 값에 의한 전달 vs 참조에 의한 전달

---

- 이건 그냥 용어에 대한 논쟁입니다. 포인터를 매개변수로 전달할 때
1. 원본이 바뀐다 👉 '참조에 의한 전달' 이라고 부르자!
  2. 메모리 주소를 복사했다 👉 '값에 의한 전달' 이라고 부르자!
- 아주 엄밀히 말하면 C에서 함수를 호출할 땐 항상 변수를 복사합니다. 따라서 '값에 의한 전달'이란 용어가 맞습니다. 단, 포인터를 사용해 참조에 의한 전달을 흉내낼 뿐입니다.
- 근데 사실 저건 말장난입니다. 어쨌든 프로그래머 입장에선 원본이 바뀌는지 안 바뀌는지가 중요합니다. 따라서 원본이 바뀌니까 프로그래머의 의도상 '참조에 의한 전달'이라고 하는게 맞습니다.

## 103. 코드보기 : Min, Max 한 번에 구하기

---

```c
/* min_max.h */
#ifndef MIN_MAX
#define MIN_MAX
void getMinMax(const int arr[], const size_t length, int* out_min, int* out_max);
#endif
```

```c
/* min_max.c */
#include "min_max.h"
#include <assert.h>
#include <stdio.h>
/* length >= 1 때만 */
void getMinMax(const int arr[], const size_t length, int* out_min, int* out_max){
    
    size_t i;
    /* 디버그 모드에서만 검사하는 함수 */
    assert(length>=1);

    *out_min = arr[0];
    *out_max = arr[0];

    for (i=0; i<length; i++){
        if (*out_min > arr[i]){
            *out_min = arr[i];
        }
        if(*out_max < arr[i]){
            *out_max = arr[i];
        }
    }
}
```

```c
/* main.c */
#include <stdio.h>
#include "min_max.h"

int main(void){
    int arr[] = {4,2,3,15,23,12,6,8,3};
    int num_min;
    int num_max;
    getMinMax(arr, sizeof(arr)/sizeof(arr[0]), &num_min, &num_max);
    printf("min : %d, max : %d\n", num_min, num_max);
    return 0;
}
```



## 104. 포인터와 함수 반환 값

---

- 포인터도 변수니까 함수의 리턴 값으로 사용할 수도 있습니다.

- 단, 주의할 점이 있는데 지역변수의 주소를 반환하는건 매우 위험한 코드입니다. 컴파일러에 따라서 waring을 띄워주는 컴파일러도 있습니다.

  ```c
  int* add(const int a, const int b){
  	int result = a+b;
  	return &result;
  }
  
  int main(void){
  	int* result;
  	result = add(10, 20);
  	return 0;
  }
  ```

- 함수의 지역 변수는 스택메모리에 저장됩니다. 함수의 작업이 끝나면 함수의 스택 프레임은 사라지고 전에 쓰던 데이터 값은 그 자리에 남아있습니다. 그리고 그 자리 위에 다른 함수의 스택 프레임이 들어오고 다른 변수가 들어옵니다. 그렇게 다른 데이터가 덮어 씌워질 수 있습니다.

## 105. 댕글링 포인터(dangling pointer)

---

- 컴파일러가 warning을 뱉은 이유는 **유효하지 않은 주소**를 가리켜서 나는 것입니다.
- 위와 같은 코드는 절대 작성하면 안됩니다.
- 실제 가리키는 대상이 없는 포인터를 '댕글링 포인터'라고 부르고 100에 99.9는 문제를 일으킵니다.
- 단, 포인터를 안전하게 반환할 수 있는 경우가 있습니다.
  - 전역 변수 - 전역 변수의 주소는 프로그램이 도는 동안 바뀌지 않습니다.
  - 함수 내 static 변수 - 함수 안에서만 접근하지만, static 변수는 데이터 섹션에 들어가 주소가 바뀌지 않습니다.
  - 힙 메모리에 생성한 데이터
  - 즉, 스택프레임에 들어가는 데이터가 아니라 힙이나 데이터 섹션에 들어가는 메모리는 주소를 반환해도 좋습니다.



## 106. 널(NULL) 포인터

---

- 아무 것도 가리키지 않는 포인터를 '널 포인터'라고 부릅니다.

  - Null 포인터의 값은 '0'인 정수 상수 혹은 void*로 캐스팅된 표현식입니다.
  - 널 포인터를 만들려면 `int* ptr=NULL` 혹은 `int* ptr = 0` 하면 됩니다.
  - 근데 보통 전용 매크로 `#define NULL ((void*)0)`를 사용합니다.
    - 0도 대입하고 0을 void* 로 캐스팅도 하네요.

- 포인터 변수와 NULL은 비교 가능합니다.

  ```c
  int* ptr = NULL;
  
  if (ptr==NULL){~~};
  ```

- 포인터 변수 NULL 비교할 때 `ptr==0`을 써도 되긴 하는데... 그냥 `NULL`쓰도록 합시다.