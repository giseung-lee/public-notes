---
layout: post
title: C Unmanaged Programming 2 - 빌드과정
---
{% assign imgurl=site.imgbase|append: page.categories[-1] %}



- 해당 포스팅은 [Kim Pope 선생님의 C 언매니지드 프로그래밍 강의](https://www.udemy.com/course/c-unmanaged-programming-by-pocu/)를 정리하며 사견을 붙인 것입니다.

- 포스팅 내 목차는 동영상강의 기준입니다.



## 63. 소스코드에서 실행파일까지, C 프로그램의 빌드 과정

---

- C에서 만든 컴파일 모델의 뼈대는 다른 언어들에서도 사용합니다.

### C 프로그램의 빌드 과정

- 빌드란?

  - 사람이 읽기 쉬운 소스코드를 기계어 명령어로 변환 하는 과정
  - 명령어들을 모아 기계에서 실행 가능한 실행 파일로 만드는 과정

- 빌드의 단계

  1. 전처리(preprocessing)
  2. 컴파일(compilation)
  3. 어셈블(assembling) 
  4. 링크(linking)

- 2, 3 단계를 합쳐 컴파일이라고도 부르고, 1, 2, 3 단계를 합쳐서 컴파일이라고도 부릅니다.

- 각 과정을 크게보면 다음과 같습니다.

- 소스코드(.h, .c) <br>--[전처리기]--> 확장된 소스코드(트랜스레이션 유닛) <br>--[컴파일러]--> 어셈블리 코드 <br>--[어셈블러]--> 오브젝트 코드 <br>--[링커]--> 실행파일(.exe, .out)

- 강의에서 사용하던 clang은 clang 명령어로 소스코드를 바로 실행파일로 만듭니다. 하지만 clang에서도 옵션을 주면 한 단계씩 실행 가능합니다.

  - 현업에선 최소 2단계로는 나눠 사용합니다.(컴파일, 링크)

- 조만간 강의에서 볼 코드는 다음과 같이 이루어져 있습니다.

  - func.h 👉 함수 헤더파일(함수 선언부)
  - func.c 👉 함수 구현파일
  - main.c 👉 실행 파일

- 조만간 쓸 명령어는 다음과 같습니다. 각 옵션은 [여기](https://clang.llvm.org/docs/UsersManual.html)를 참고해주세요!

  ```
  clang -std=c89 -W -Wall -pedantic-errors *.c
  ```

  





## 64. .h와 .c 파일

---

- C# 에선 func.cs 와 main.cs만 있었지만 C에선 func.h, func.c 로 헤더를 분리해줍니다. 컴퓨터 성능이 안좋던 시절에 더 효율적으로 만들기 위해 나눴습니다.

### C 파일

- 실제 로직 코드들입니다. 함수 정의(== 함수 구현), 전역변수, 매크로 등이 들어갑니다.

### 헤더 파일

- 여러 소스코드 파일에 공통적으로 필요한 것들을 저장해 두는 파일입니다. 
- 함수 선언, 매크로, extern 변수선언 등이 들어갑니다.
- #include를 통해 다른 파일에 들어갑니다. 컴파일 과정에서 #include는 단순 텍스트 복분입니다.

### 예시

- 아래와 같은 상황을 가정합시다.

  ```c
  /* adder.c */
  int add(int a, int b){
      int res = a+b;
      return res;
  }
  ```

  ```c
  /* main.c */
  int main(void){
      const int res = add(1,2);
      return 0;
  }
  ```

  - 앞서 말했듯이 지금 같은 상황에서 main 함수는 add를 모르기 때문에 컴파일 되지 않습니다. 

- 이걸 컴파일 하기 위해서 add 함수의 원형을 알아야 합니다. 원형을 알려주는게 헤더 파일입니다. 헤더파일을 작성하고 adder.c 와 main.c에 해당 헤더 파일을 복붙 하겠다는 의미의 #include를 써줍니다.

  ```c
  /* adder.h */
  int add(int a, int b);
  ```

  ```c
  /* adder.c */
  #include "adder.h"
  int add(int a, int b){
      int res = a+b;
      return res;
  }
  ```

  ```c
  /* main.c */
  #include "adder.h"
  int main(void){
      const int res = add(1,2);
      return 0;
  }
  ```



## 65. 헤더 파일이 필요한 이유

---

- 사실, 헤더 파일이 필수적이진 않습니다. adder.c를 include 할 수도 있고 main.c에 모든 소스를 다 넣을 수도 있습니다.
- 하지만 우선 작업의 편의상 파일을 나누는건 당연합니다. 한 파일에 100만 줄을 작성할 순 없습니다.
- 그런데 파일을 나눠 놓고 보면 동일한 함수를 다른 파일에서 쓸 때 문제가 됩니다.
  - 이때 복붙으로 쓸 함수를 다른 파일로 옮겨오면... 혼나야 합니다.
- 이때 헤더파일을 사용하면 함수 선언을 여러 C 파일끼리 공유가능합니다. (다른 언어들은 더 똑똑하기 때문에 굳이 헤더파일을 작성할 필요가 없습니다. 언어쪽에서 해줍니다.)
- 그렇다면, 함수 선언 부분만 include 했는데 어떻게 프로그램이 돌까요?
  - 빌드가 여러 단계로 나뉜 이유입니다. 정의 없이 선언만으로 컴파일이 가능하고, 선언부에 정의를 옮겨 주는게 링크 단계입니다.

## 66. #include <> 와 #include ""

---

- 두 방식은 **디스크 상의 어느 위치에서 헤더 파일을 찾느냐** 차이입니다.
- #include <>
  - 시스템 경로에서만 헤더 파일을 검색합니다.
  - **컴파일러가 제공하는 시스템 헤더 파일을 인클루드 할 때** 사용합니다.
- #include ""
  - 현재 작업중인 디렉터리에서 헤더 파일을 먼저 검색합니다.
  - 없으면 시스템 경로를 검색합니다.
  - 개발자가 구현한 헤더파일을 인클루드 할 때 사용합니다.



## 67. 빌드 과정 : 전처리 단계

---

- 앞서 말했듯이 전처리 단계는 **"소스코드 👉 확장된 소스 코드(트랜스레이션 유닛)"** 과정입니다.
- 전처리기라는 별도의 프로그램이 담당합니다. 
- 전처리기는 다음과 같은 일을 합니다.
  - 주석 제거
  - 매크로를 확장 합니다.(복붙 합니다.)
  - 인클루드 파일들을 확장 합니다.(복붙 합니다.)
    - C 전처리기는 사실 #include 가 붙으면 파일 형식을 가리지 않고 붙여 넣습니다.
  - 컴파일의 기본 단위인 확장된 소스 코드(translation unit)을 돌려줍니다.



## 68. 트랜슬레이션 유닛 보는 방법

---

- 컴파일 할 때 '-E' 플래그를 주면 됩니다. 

  ```
  clang -E {filename}.c
  ```

- 위 명령어로는 콘솔 에서만 보입니다. 파일로 따로 보고 싶으면 출력 리디렉션(output redirection) 이라는 콘솔의 기능을 쓰면 됩니다.

  ```
  clang -E {filename}.c > {filename}.pre
  ```

  



## 69. 빌드 과정 : 컴파일 단계

---

- 컴파일 단계는 **"확장된 소스코드 👉 어셈블리 코드"** 과정입니다.
- 컴파일러가 담당합니다.
- 어셈블리어는 기계 코드와 거의 1:1로 대응됩니다. 하지만, 어셈블리어 조차 원래 사람들이 쓰기 쉬우라고 만들어진 프로그래밍 언어입니다. 
- 어셈블리어는 아직 정의를 모르는 심볼(함수나 변수 이름)을 사용할 수 있습니다. 때문에 헤더 파일만 이용해도 컴파일이 가능합니다.
- 컴파일러가 선언만 찾고 정의를 못찾으면 그 부분은 구멍만 남겨 둡니다.(어떤 주소가 들어갈 지 비워 둡니다.) 필요한 함수 주소를 메우는건 링크 단계입니다.



## 70. 어셈블리어 코드 보는 방법

---

- 플래그 '-S' 를 쓰면 어셈블리어 코드가 .s 파일로 저장됩니다. (출력 리디렉션 안해도 저장해줍니다.)

  ```
  clang -S {filename}.c
  ```

- 어셈블리어가 기계어랑 1:1로 대응 된다는 뜻은, 컴파일이 된다면 해당 기계에서만 돈다는 뜻입니다. 기계마다 사용하는 명령어도 다르고 대응하는 어셈블리어도 다르기 때문입니다.

  - 컴파일러 만드는 개발자들은 도대체 어떤 분들인지...



## 71. 빌드 과정 : 어셈블 단계

---

- 어셈블 단계는 **"어셈블리 코드 👉 오브젝트 코드"** 단계입니다.
- 어셈블러가 담당합니다. 어셈블리어와 기계어가 거의 1:1 대응 한다고 했는데, 바로 그 일을 합니다.
- 오브젝트 코드란
  - 기계가 이해 가능한 기계코드 입니다. 기계어라고도 합니다.
  - 오브젝트 코드에도 아직 메꿔야 하는 구멍이 있습니다.(컴파일 할 때 비워 놓은 부분)
  - 여기부턴 사람이 읽기 힘듭니다.. 



## 72. 오브젝트 코드 보는 방법

---

- -c 플래그를 넣으면 .o 파일로 저장됩니다.

  ```
  clang -c {filename}.c
  ```

- 출력된 .o 파일은 이진 파일이라 일반 텍스트 편집기로 열 순 없습니다. 16진수 편집기로 열어야 합니다.

  - 선생님이 사용하는 16진수 편집기 [HxD](https://mh-nexus.de/en/hxd/)

- main.c에서 뽑은 오브젝트 코드를 보면 뚫어 놓은 add 함수 구멍이 아직 매꿔지지 않았음을 볼 수 있습니다. 레이블을 남겨둡니다.

  {: .p_img}

  ![obj_code.png]({{ imgurl }}/obj_code.png)<small>add 부분이 레이블로 남겨져있다.</small>



## 73. 빌드 과정 : 링크 단계

---

- 링크 단계는 **"오브젝트 코드 👉 실행 파일"** 단계입니다.

- 링커가 담당합니다.

- 링커에 들어가는 입력은 모든 오브젝트 코드들입니다. 오브젝트 코드들의 구멍을 메꾸고 실행 파일을 만듭니다.

- 링커가 오브젝트 코드들을 돌면서 각 함수의 시작 주소를 기억합니다. 그리고 돌면서 레이블로 남겨진 함수를 발견 하면 레이블 부분에 해당 함수의 주소로 점프 하는 코드를 넣습니다.

  - 링커가 뚫어 놓은 구멍에 해당하는 함수를 찾으면 에러를 뱉습니다. adder.h, adder.c, main.c 중 adder.c를 지우고 컴파일 해보면 아래와 같은 에러가 뜹니다.

    ```
    main-5500ed.o : error LNK2019: add 외부 기호(참조 위치: main 함수)에서 확인하지 못했습니다.
    a.exe : fatal error LNK1120: 1개의 확인할 수 없는 외부 참조입니다.
    clang: error: linker command failed with exit code 1120 (use -v to see invocation)
    ```

  - 오류에 친절하게 main-5500ed.o 파일에서 LNK2019 에러가 났다고 뜹니다. 에러를 읽는 스킬이 늘었습니다. 후..

## 74. 링크 단계가 분리되어 있는 이유

---

- 빌드 단계를 컴파일 / 링크로 나누는 주된 이유입니다.
  - 컴파일 할 때 함수의 구멍을 남긴다고 했습니다. 이걸 컴파일 과정에서 하려면 한 파일을 컴파일 할 때마다 모든 파일, 함수를 훑어줘야 합니다.  O(n^2) 느낌인가
  - 각 파일을 컴파일 할 때 함수의 구멍을 메꾼다고 한다면, 구멍을 메꾼 후 파일들을 합칠 때 함수들이 중복되는 문제가 발생합니다.
- 물론 모든 c파일을 합쳐 컴파일 할 수도 있습니다. 실제로 컴파일 성능을 위해서 하는 경우도 있긴합니다만.. 거의 보기 힘들 겁니다. 1줄만 바꿔도 1만줄 모두 컴파일 하기 때문에..
- 결론적으로, 컴파일 / 링크를 나누는게 빠르고 관리 하기도 편합니다.
- 업계에선 .o 파일들을 따로 만들고, .o 파일을 .exe로 만드는 과정을 따로 둡니다. clang에서도 .o 파일들 가지고 링크만 할 수도 있습니다.



## 75. 라이브러리(library), 정적/동적 라이브러리와 링크

---

- 잘 알고 있는 라이브러리도 이와 같이 만들 수 있습니다.
- 라이브러리는 컴파일 했을 때 실행 파일이 아니라 나중에 실행 할 수 있는 함수들을 바이너리로 만들어 놓은 것입니다.
  - 함수를 기계어로 변환 후 파일로 저장해 놓은 것!
- 라이브러리엔 정적 라이브러리, 동적 라이브러리가 있습니다.

### 정적 라이브러리

- 링킹이 빌드 할 때 일어납니다.
- 정적 라이브러리는 함수들을 합쳐서 실행 파일을 만듭니다.
- 실행 파일이 커지고 메모리를 더 먹을 순 있으나, 일단 exe에 다 넣어 놓으니 실행 속도가 빠릅니다.

### 동적 라이브러리

- 링킹이 파일 실행시 일어납니다.
- 동적 라이브러리를 사용하는 실행 파일엔 아직 구멍이 뚫려 있습니다. 실행 파일이 실행 될 때 운영 체제가 빈 구멍을 동적 라이브러리에서 찾아 메꿔줍니다.
- 실행 파일 크기가 작아집니다.
- 여러 실행 파일이 같은 라이브러리를 공유 할 수 있습니다. 메모리를 절약 할 수 있습니다.
- 단점으론 이름이 같지만 버전이 다른 동적 라이브러리를 두 프로그램에서 사용할 때 충돌이 납니다.
  - DLL Hell 이라고도 부릅니다.
  - A은행, B은행 프로그램이 모두 같은 보안 라이브러리A를 사용하는데 버전이 다르면 충돌이 날 수 있습니다.
    - 보안 라이브러리A를 만드는 회사가 하위 버전의 호환을 염두에 두고 상위 버전을 만들면 상관 없지만.. 흠...



## 76. 분할 컴파일과 전역 변수

---

### 분할 컴파일

- 실제 소스 코드는 파일 수가 수십, 수백 개가 될 수 있습니다.
- 컴파일 할 땐 모든 파일들을 개별적으로 컴파일 해 오브젝트 파일을 만듭니다. 후에 오브젝트 파일들을 링크시켜 실행 파일을 만듭니다.
  - 여러 파일을 컴파일 할 땐 멀티 프로세서에서 따로따로 컴파일 할 수도 있습니다.
  - 링크는 혼자 해야겠죠.
- 분할 컴파일 하다가 에러나서 한 파일에 때려 넣는 사람들이 있는데... 하지 마세요



## 77. 다른 파일에 있는 전역 변수 사용시 문제점

---

- 다음과 같은 상황을 가정합시다.

  ```c
  /* monster.h */
  void add_monster(void);
  ```

  ```c
  /* monster.c */
  #include "monster.h"
  int g_mob_count = 0;
  void add_monster(void){
  	++g_mob_count;
  }
  ```

  ```c
  /* main.c */
  # include <stdio.h>
  # include "monster.h"
  int main(void){
  	add_monster();
  	printf("%d\n", g_mob_count);
  }
  ```

  - 위 코드를 빌드 하려하면 main.c 파일에서 **"use of undeclared identifier 'g_mob_count'"** 에러가 납니다. main 함수 입장에선 컴파일 할 땐 g_mob_count를 모른다는 뜻입니다. 앞서 알아봤듯이, 파일들 끼리 연결 하는건 컴파일이 끝나고 링크 과정에 일어나니까요.

- 그렇다고 main 함수에 g_mob_count를 넣고 빌드를 하면 어떻게 될까요.

  - 컴파일은 되지만 링크 과정에서 **"LNK2008 : g_mob_count already defined ~~~"** 에러가 납니다. 같은 전역변수가 겹쳤다는 얘기입니다. 
  - C에선 동일한 전역변수 이름을 여러 파일에서 못씁니다. 링커가 거절합니다.

- 이를 위해서 main 함수에 새로운 전역 변수를 만드는게 아니라 monster.c 에 있는 전역 변수를 쓸 것이라 선언을 해줘야 합니다.



## 78. extern 키워드

---

- 그것이 extern 입니다. extern 전역변수는 헤더파일에 넣으면 됩니다.

  ```c
  /* monster.h */
  extern int g_mob_count;
  void add_monster(void);
  ```

- main.c에 넣어도 되긴 합니다. (안써도 #include "monster.h" 에서 가져옵니다.)

  - 다른 언어의 접근 지시자랑 비슷합니다.

- 누구라도 쓸 수 있게 하고 싶다면 헤더파일에, 한 파일에서만 쓰게 하고 싶으면 c 파일에 사용합니다.

  - 모호합니다. C에서 전역 변수 사용을 지양하는 사람들도 있습니다.

- 다음과 같이 extern을 안쓰는 경우에 에러가 날 수 있습니다.

  ```c
  /* monster.h */
  int g_mob_count = 0;
  void add_monster(void);
  ```

  - #include 할때 extern 없는 g_mob_count를 monster.c, main.c 에 모두 복붙하니 링커에서 에러가 납니다.

- 함수 앞에도 extern 붙일 수 있으나, 함수는 안 붙여도 자동 extern 입니다.(함수 뒤에 {} 를 안열고 ; 로 끝나는 걸로 알 수 있습니다.)

## 79. 코드보기 : extern 키워드

---

- 패스



## 80. 전역 변수의 문제, static 키워드

---

- '전역 변수는 쓰지 말라' 라는 말이 있습니다.

- 우려 할 부분이 있긴 합니다.

  - extern 사용시 어떤 파일에서든 접근 할 수 있습니다. 파른 파일에서 자기 파일 안의 변수를 건드릴 수 있습니다. 파일이 많아지면 누가 자기 변수 바꾸는 지 잡기 힘듭니다.
    - 다른 파일이 자기 전역변수 못쓰게 할 수 있으면 좋겠습니다.

- 프로그램이 살아있는 동안 메모리에 있으면서도, 다른 파일에선 접근 못하게 하고 싶을 때 static 키워드를 사용 할 수 있습니다.

- 아까의 예를 다음처럼 쓸 수 있습니다.

  ```c
  /* monster.h */
  void add_monster(void);
  ```

  ```c
  /* monster.c */
  #include "monster.h"
  static int s_mob_count = 0;
  void add_monster(void){
  	++s_mob_count;
  }
  ```

  ```c
  /* main.c */
  # include <stdio.h>
  # include "monster.h"
  extern int s_mob_count;
  int main(void){
  	add_monster();
  	printf("%d\n", s_mob_count);
  }
  ```

  - 이 상태로 빌드를 하게 된다면 링커 오류가 발생합니다. main.c에선 s_mob_count 전역 변수를 사용하려고 빈칸을 남겨 뒀는데 monster.c에선 static 키워드를 사용했기 때문에 링커에서 main.c에 넣어줄 s_mob_count를 찾지 못합니다.
  - static이 어떻게 돌아가는지를 이해하긴 어렵고 일단 이 부분은 익숙해집시다.

### static

- 변수 범위가 파일로 한정됩니다.
- 정적 변수라고 합니다.
- 전역 변수이기 때문에 프로그램이 돌 때 계속 메모리를 먹고 있습니다.

### static 키워드를 지역 변수에 사용할 때

- 다음과 같이 바꿀 수 있습니다.

  ```c
  /* monster.c */
  #include "monster.h"
  # include <stdio.h>
  void add_monster(void){
      static int s_mob_count = 0;
  	++s_mob_count;
      printf("%d\n", s_mob_count);
  }
  ```

  ```c
  /* main.c */
  # include "monster.h"
  int main(void){
  	add_monster();
  	add_monster();
  	add_monster();
  }
  ```

  - 함수 안에 s_mob_count를 static으로 넣고 0으로 초기화 한다고 써 놓았지만, 실제 위 코드가 돌아가면 1, 2, 3을 찍습니다.
  - static 키워드를 함수 안에서 사용하면 **개념상 전역 변수로서 한 번만 초기화 되고 프로그램이 돌 동안 계속 메모리에 올라가있지만, 해당 함수 안에서만 접근 가능합니다.**

- 함수 역시 그 파일 안에서만 쓰고 싶으면 static 키워드를 넣으면 됩니다. private과 비슷하네요.

## 81. 코드보기 : static 키워드

---

- 패스~
- C에서도 전역 변수 static으로 만들어 놓고 getter/setter를 만들기도 합니다. 객체지향 언어에서 private 걸고 getter/setter 만들 듯이.



## 82. .c와 .h 파일 정리, 순환 헤더 인클루드와 해결법

---

### 정리

- 빌드 4단계가 돌려면 아래 기본 원칙을 따릅시다.
  - 헤더 파일엔 선언만 합시다.
    - 함수선언, 전역변수 extern 선언
  - .c 파일엔 정의가 들어갑니다.
    - 함수 정의, 전역 및 정적 변수 정의

### 순환 헤더

- 전처리기는 복-붙으로 수행 된다고 했습니다. 근데 인클루드를 순환해서 할 수 있습니다.

  ```c
  /* A.h */
  #include "B.h"
  ~~~
  ```

  ```c
  /* B.h */
  #include "C.h"
  ~~~
  ```

  ```c
  /* C.h */
  #include "A.h"
  ~~~
  ```

  - 이 경우 컴파일이 안됩니다. 에러를 내줍니다.
  - "순환 헤더 인클루드 (circular header include)" 라고 부르고 "헤더가 꼬였다" 라고도 합니다. 실무에서 자주 발생하는 문제입니다. 다른 언어에선 걱정할 필요 없는 C에서만 나오는 문제입니다.

- 해결1

  - #include는 c에서만 합시다.
  - b 헤더에서 a 헤더 전체를 인클루드 하지 말고 a에 정의된걸 전방 선언합니다.
  - 서로 인클루드를 해야만 한다면! **인클루드 가드**를 사용합니다. 순환 헤더를 막는 업계 표준입니다.

- 다음과 같이 인클루드 가드를 씁니다.

  ```c
  /* foo.h */
  #ifndef FOO_H /* if not defined */
  #define FOO_H
  /* 원래 헤더 파일 내용 */
  #endif FOO_H
  ```

  - #으로 시작하는 것들은 전처리기가 처리합니다.



## 83. 인클루드 가드 작동법

---

- 인클루드 가드는 다음과 같이 작동합니다.
  - `#ifndef FOO_H` 만약 FOO_H가 정의되지 않았다면 
  - `#define FOO_H` 지금부터 FOO_H를 정의해라.
  - `/* 헤더 파일 내용 */` 이렇게
  - `#endif` 정의 끝!
- 헤더 파일을 조건적으로 컴파일하라고 지시하는 것입니다.

## 84. 인클루드 가드 예제

---

- 패스
- 인클루드 가드는 그냥 무조건 넣는다고 생각합시다!
- 비슷한 기능으로 #pragma once 라는 키워드도 있습니다. C에서도 되고 간단한데 C 표준은 아닙니다. (그런데 대부분 컴파일러가 지원하긴 합니다.)
  - C++ 에선 표준으로 사용합니다.



## 85. C 컴파일러의 종류와 특징

---

- C는 표준위원회가 있고 컴파일러들은 다양합니다.
- GCC
  - 가장 유명한 컴파일러입니다. 
  - 많은 C 표준 대부분을 지원합니다.
- MS의 Visual C++ 
  - 유명합니다. C++ 컴파일러이긴 한데 C도 컴파일 합니다. 
  - C99표준을 지원하고 C11은 대부분 지원하지 않습니다. 
  - 윈도우에서만 놀거라면 자주 사용합니다.
- Clang
  - LLVM 컴파일러 구조를 사용하는 C계열 컴파일러입니다.
  - 애플이 먼저 개발했으나 이제 구글, MS 등 모두 같이 개발중입니다.
  - 선생님이 많이 좋아하는 컴파일러 같습니다.
  - 컴파일 속도도 빠릅니다.
- 소형기기 컴파일러
  - 소형기기들은 하드웨어 자체가 다르기 때문에 컴파일러도 다릅니다. 
  - 각 소형기기 마다 맞는 컴파일러를 사용합니다.



## 86. 정리

---

- 1강부터 지금까지 한 걸 정리해 보겠습니다.
  - Hello world
  - C언어 기본 문법
  - 스택 메모리가 어떻게 도는지 가볍게
    - 포인터를 위한 준비운동입니다.
  - 빌드
  - 분할 컴파일

