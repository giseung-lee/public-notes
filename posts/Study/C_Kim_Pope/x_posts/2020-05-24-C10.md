---
layout: post
title: C Unmanaged Programming 10 - 자료구조
---
{% assign imgurl=site.imgbase|append: page.categories[-1] %}



## 242. 자료구조 기초

---

- 사실 여기까지 했으면 C 강의 자체는 끝났습니다. 다만, 자료구조를 구현하면서 C를 사용해봅시다.

- 자료구조의 기초만 배울겁니다.

- 자료 구조란?
  - 컴퓨터에서 여러 자료들을 조직적, 체계적으로 저장하는 방법
  - 보통 동일한 자료형을 여럿 저장하는 구조를 의미
  - 자료구조에 따라 요소들 사이의 관계를 정의하는 규칙이 있음
  - 상황마다 효율적인 자료구조가 존재
    - 데이터에 접근하는 빈도
    - 데이터에 접근하는 방법(삽입, 검색, 읽기, 지우기 등)
  
- 자료구조의 효율성
  - 보통 시간 복잡도를 말합니다.
  - 공간 복잡도를 포함하는 경우도 있지만, 기본적으론 시간 복잡도라고 생각합시다.
  - 효율성을 논할 땐 보통 하드웨어 최적화를 고려하지 않고 말합니다.
    - 대용량 데이터에선 거의 맞지만 적은 용량 데이터를 다룰 땐 하드웨어 최적화가 큰 영향을 미칩니다.
  - 효율성 n^2 부턴 느린 알고리즘입니다. nlogn은 아슬아슬 하고 n은 soso, logn은 훌륭.
  
- 자료구조들의 시간 복잡도

  |  자료구조   | 검색-평 | 삽입-평 | 삭제-평 | 검색-최악 | 삽입-최악 | 삭제 - 최악 |
  | :---------: | :-----: | :-----: | :-----: | :-------: | :-------: | :---------: |
  |    배열     |  O(n)   |  O(n)   |  O(n)   |   O(n)    |   O(n)    |    O(n)     |
  |    스택     |  O(n)   |  O(1)   |  O(1)   |   O(n)    |   O(1)    |    O(1)     |
  |     큐      |  O(n)   |  O(1)   |  O(1)   |   O(n)    |   O(1)    |    O(1)     |
  | 연결 리스트 |  O(n)   |  O(1)   |  O(1)   |   O(n)    |   O(1)    |    O(1)     |
  | 해시 테이블 |  O(1)   |  O(1)   |  O(1)   |   O(n)    |   O(n)    |    O(n)     |



## 243. 배열, 배열의 삽입

---

- 가장 간단한 자료구조입니다.

- 색인(index)로 접근 가능합니다.

  - 위치 = 시작주소 + sizeof(자료형)*색인

- 배열 삽입 코드 보는중..

  ```c
  enum { MAX_NUMS = 8 };
  int s_nums[MAX_NUMS];
  size_t s_num_count = 0; /* 현재 배열 요소 갯수 */
  
  void insert_at(size_t index, int n){
      size_t i;
      
      /* 범위 확인 */
      assert(index <= s_num_count);
      assert(s_num_count < MAX_NUMS);
      
      /* 배열 앞쪽 index에 insert_at 하면 뒤로 한 칸씩 미는 for문 */
      for(i=s_num_count; i>index; --i){
          s_nums[i] = s_nums[i-1];
      }
      
      /* 다 밀고나면 index에 넣고 갯수 증가 */
      s_nums[index] = n;
      ++s_num_count;
  }
  
  int main(void){
      insert_at(0, 1);
      insert_at(0, 2);
      insert_at(0, 3);
      insert_at(0, 4);
      insert_at(0, 5);
      insert_at(0, 6);
      insert_at(0, 7);
      insert_at(7, 8);
      return 0;
  }
  ```

- 배열의 삽입엔 크게 두 가지 경우가 있습니다.

  - 맨 뒤에 삽입
    - 그냥 넣기만 하면 끝
  - 맨 뒤가 아닌 곳
    - 넣을 자리 뒤의 요소들을 뒤로 한 칸씩 밀어야 합니다. 
    - O(n) 의 연산



## 244. 배열의 삭제

---

- 삭제 코드 (위 코드에 이어서)

  ```c
  void remove_at(size_t index){
  	size_t i;
  	
  	assert(index < s_num_count);
  	
      /* 요소 갯수 줄이고 */
  	--s_num_count;
      /* index 뒤의 것들을 앞으로 한 칸씩 당김 */
  	for(i=index; i<s_num_count; ++i){
  		s_nums[i] = s_nums[i+1];
  	}
  }
  ```

- 삭제하는 index를 기준으로 뒤의 값들을 한 칸씩 앞으로 당깁니다.

  - O(n)의 연산



## 245. 배열의 검색, 배열의 접근

---

- 배열 검색 코드

  ```c
  size_t find_index(int n){
  	size_t i;
  	
  	for(i=0; i<s_num_count; ++i){
  		if(s_nums[i]==n){
              return i;
          }
  	}
  	
  	return INVALID_INDEX;
  }
  ```

- 배열의 요소를 차례로 훑으며 찾고자 하는 값이 있는지 찾고 있으면 해당 index를 반환, 없으면 -1을 반환합니다.

  - O(n)의 연산

- index로 바로 배열의 요소의 접근하는 경우엔 O(1) 입니다.

  - 빈틈 없이 줄 세워놓는 가장 간단한 자료구조이기에 가능합니다.





## 246. 코드보기 : 빠른 배열

---





## 247. 스택(Stack)

---





## 248. 스택의 삽입

---





## 249. 스택의 제거

---



## 250. 스택의 검색

---



## 251. 스택의 용도

---

