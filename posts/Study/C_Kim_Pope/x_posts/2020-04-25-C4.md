---
layout: post
title: C Unmanaged Programming 4 - 포인터
---
{% assign imgurl=site.imgbase|append: page.categories[-1] %}



- 해당 포스팅은 [Kim Pope 선생님의 C 언매니지드 프로그래밍 강의](https://www.udemy.com/course/c-unmanaged-programming-by-pocu/)를 정리하며 사견을 붙인 것입니다.

- 포스팅 내 목차는 동영상강의 기준입니다.



## 87. 포인터

---

- 앞서 스택메모리를 알려드린건 지금 이 포인터를 배우기 위함입니다.
- 포인트 뒤로 나오는 모든 것들엔 포인터가 필요하다고 보시면 됩니다.
- 선생님이 C에서 중요하다고 생각하는 세 가지는 다음과 같습니다.
  - 포인터
  - 동적 메모리 할당
  - 구조체, 공용체를 포인터, 동적 메모리와 함께 쓰는 법

### 개발자가 직접 메모리 주소를 이용해 데이터를 바꿀 수 있나요?

- 다른 언어였다면 불가능 하지만 C에선 가능합니다. 이걸 잘하면 매우 강력한 일을 할 수 있지만, 잘못 건드리면 흐흐.. 😈
- C가 위험하다, 강력하다 모두 이 포인터 때문입니다.

## 88. 주소 연산자 \&

---

- 직접 메모리 주소로 변수를 조작하려면 우선 해당 변수의 주소를 알아야 합니다.

- 아래 코드를 실행해 봅시다.

  ```c
  void print_address(void){
      int num = 10;
      printf("address of num is %p\n", (void*)&num);
  }
  int main(void){
      print_address();
      return 0;
  }
  /*
  address of num is 00000068ED6FF914
  */
  ```

- \&를 주소 연산자라고 합니다. (비트연산자 \&와 헷갈리지 맙시다. 비트연산자 \&는 피연산자가 2개입니다.)

  - \&뒤에 오는 변수의 주소를 돌려줍니다.

- 주소를 표현할 땐 16진수를 사용합니다. 

  - printf 에서 "%p" 를 사용하면 주소를 16진수로 보여줍니다.

- 실행할 때 마다 주소가 바뀝니다. (보안 강화를 위해 실행할 때마다 프로그램이 올라가는 주소가 바뀝니다. - ASLR 이라고 합니다.)



## 89. 메모리 주소 저장하기

---

- \& 연산자로 주소를 구할 수 있다는 걸 배웠습니다. 그럼 이 주소를 어떻게 변수에 저장할까요.

  - 어차피 16진수 숫자니까 int에 저장하면 되지 않을까요!! 👉 컴파일 에러 납니다.

    ```c
    void try(void){
    	int num = 10;
    	int num_addr = &num;
    }
    /*
    error: incompatible pointer to integer conversion initializing 'int' with an expression of type 'int *'; remove &
    */
    ```

- 앞으로 '주소'와 '값'이 계속 언급 될 텐데 둘을 잘 구분합시다. 주소는 값의 메모리 위치.

- 주소를 저장하기 위한 특별한 변수가 있습니다.

  - 그 변수가 바로 **포인터**입니다.
  - 포인터 is 변수



## 90. 포인터의 의미

---

- 포인터란 주소를 저장하기 위한 변수**형**입니다.
- 포인터는 변수입니다. 메모리 주소를 저장하는 변수요.
- 포인터를 다른 복잡한 정의로 이해하면 앞으로 더 복잡해집니다. 포인터는 그냥 변수에요.



## 91. 메모리 주소에 저장된 자료형

---

- 주소에 저장된 자료형은 뭘까요?
  - 하드웨어는 신경쓰지 않습니다. 비트패턴을 char로 읽으면 char고, int로 읽으면 int고, float으로 읽으면 float입니다.
- 근데, 해당 주소에서부터 몇 바이트를 읽어야 하는지(나는 이 주소에서 몇 바이트를 갈거야! 같은것)는 하드웨어에게 알려줘야 합니다.
- 포인터 변수를 선언할 때 그 주소에 어떤 형의 데이터가 있는지 명시해줘야 합니다.
  - int 포인터, float 포인터, char 포인터 이런 식입니다.
  - 어떤 변수에 주소가 있는데 그걸 int 로 읽어라, float으로 읽어라, char로 읽어라



## 92. 포인터 변수를 선언하는 방법

---

- 자료형 뒤에 \*를 붙여 포인터 변수를 선언합니다.

  ```c
  void save_address(void){
  	int num = 10;
  	int* num_addr = &num;
  }
  ```

  - int\*, char\*, float\* 모두 가능합니다.

- `int *variableName;` 으로 써도 되지만 우리는 `int* variableName;`을 씁시다.



## 93. 포인터 변수를 부르는 방법

---

- 한국에선 보통 'int 포인터' 라고 부릅니다.
- 영어로는 'pointer to an int' 라고 부릅니다.
- 포인터 읽는 법은 중요합니다. 뒤에 포인터를 어떻게 읽느냐에 따라 중요해지는 부분이 있습니다. 선생님은 영어식 표현을 선호하는 것 같습니다.
- 포인터는 메모리 주소를 저장하는 변수.
  - 그럼 포인터의 내용은 어디에 저장되죠? 👉 당연히 메모리 어딘가에
  - 다른 위치를 가리키는 변수여서 '포인터'라고 부릅니다.
- 처음 공부할 때 모눈종이 사서 메모리 그려보면서 하시길 추천합니다.
  - 눈으로만 보면서 편하게 하면 머리에 안남습니다. 걸렸네..😅



## 94. 포인터 변수의 실제 메모리 뷰

---

- 디버거와 오브젝트 코드를 까서 실제 메모리 보는 중..
- 메모리 보다보면 주소가 뒤집혀 보이는걸 볼 수 있습니다.
- 데이터가 끝나는 마지막 단위를 가장 작은 메모리 주소에 위치해 메모리 주소를 뒤집어 저장하는 방식을 '리틀 엔디언' 이라고 합니다. [참고](https://ko.wikipedia.org/wiki/엔디언)
  - 요즘 나오는 인텔, amd 리틀 엔디언 방식입니다.  빅 엔디언은 옛날 cpu들입니다.
  - POCU 학생이라면 '소프트웨어 공학용 수학' 시간에 배웠습니다.
  - 들어야 되나.. 



## 95. 포인터의 비유 : 현실 세계 예

---

- 기술적인 설명은 위에 나온 것으로 끝입니다. 현실 세계로 비유를 한 번 해보겠습니다.
- 패쓰



## 96. 다른 포인터의 예

---

- int 포인터 말고 다른 포인터도 쓸 수 있습니다.

- 각 코드들을 디버그 찍어서 값 뽑아보고, 오브젝트 코드 열어서 주소 구경해봅시다.

  ```c
  void save_address(void){
  	char num = 10;
  	char* num_addr = &num;
  }
  ```

  ```c
  void save_address(void){
  	short num = 10;
  	short* num_addr = &num;
  }
  ```

  ```c
  void save_address(void){
  	float num = 10;
  	float* num_addr = &num;
  }
  ```

  ```c
  void save_address(void){
  	double num = 10;
  	double* num_addr = &num;
  }
  ```

  

## 97. 포인터에 저장된 주소도 바꿀 수 있나요?

---

- 포인터도 변수니까 당연히 변경 가능합니다.
- 포프 선생님 강의는 하나 하나가 굉장히 짧으십니다. ~~(대신 총 동영상수 342개...)~~



## 98. 역 참조 연산자 \*

---

- 포인터도 변수이기 때문에 변수가 쓰이는 것처럼 거의 사용 가능합니다.

- 매개변수로 전달할 수도 있습니다.

  ```c
  void do_something(int* addr){
  	/* do someting */
  }
  
  int main(void){
  	int num = 100;
  	do_something(&num);
  }
  ```

- 주소를 받았다면 그 주소를 역으로 추적해서 값을 찾을 수도 있습니다. 그때 사용하는 게 역 참조 연산자 \*입니다.

  ```c
  void do_something(int* addr){
  	/* do someting */
      printf("num : %d\n",*addr)
  }
  
  int main(void){
  	int num = 100;
  	do_something(&num);
  }
  ```

- 곱하기 아니에요. 포인터 변수 앞에 달려서 그 포인터 주소에 있는 곳으로 가 값을 읽어와라!



## 99. 참조와 역 참조

---

- '참조'라는 단어는 언급하지 않았지만 포인터가 계속 하고 있던일을 '참조'라고 합니다.
  - 변수의 값을 직접 가져다 쓰는게 아니라 그게 어디 있다고 '참조'만 하는 것입니다.
- 역 참조는 반대로 직접 그 주소로 가서 값에 접근하는 것입니다.
- 이 '역 참조'를 '간접(indirect) 연산자'라고도 합니다. 값에 직접 접근하는게 아니라 주소를 타고 한 번 거쳐서 간다는 뜻으로말입니다.
- indirection은 프로그래머의 자질을 알아보는 요소중 하나로 보는 곳도 있습니다.
  - 컴퓨터 구조에서 데이터를 오래 메모리에 저장하는 방법이기도 하고.. 추상적 개념을 이해할 수 있는지 알아보는 것이기도 하고...



## 100. 역 참조를 이용한 값 변경 예

---

- 역 참조를 이용해 값을 바꿀 수 있습니다.

  ```c
  int main(void){
  	int num = 50;
  	pritnf("origin : %d", num);
  
  	int* addr = &num;
  	*addr = 100;
  	printf("modified : %d", num);
      
  	return 0;
  }
  /*
  origin : 50
  modified : 100
  */
  ```

- 포인터 변수 선언할 때랑 역 참조 걸때랑 헷갈릴 수도 있으니 포인터 변수 선언할 땐 반드시 `int *num` 하지 말고 `int* num` 합시다.

## 101. 포인터로 두 변수의 값 바꾸기

---

- 모두가 작성해 봤을 법한 swap()메서드

  ```c
  void swap(int a, int b){
  	int temp = a;
  	a = b;
  	b = temp;
  }
  
  int main(void){
  	int a = 10;
  	int b = 20;
  	printf("%d, %d\n", a, b);	
  	swap(a, b);
  	printf("%d, %d\n", a, b);
  }
  /*
  10, 20
  10, 20
  */
  ```

  - 이게 안되는 이유는 말 안해도 알죠잉 C#에선 이거할 때 매개변수에 ref 를 붙이므로써 가능 했습니다.

- C에선 이때 포인터를 쓰는 겁니다.

  ```c
  void swap(int* a, int* b){
  	int temp = *a;
  	*a = *b;
  	*b = temp;
  }
  
  int main(void){
  	int a = 10;
  	int b = 20;
  	printf("%d, %d\n", a, b);	
  	swap(&a, &b);
  	printf("%d, %d\n", a, b);
  }
  /*
  10, 20
  20, 10
  */
  ```

  

## 102. 값에 의한 전달 vs 참조에 의한 전달

---

- 이건 그냥 용어에 대한 논쟁입니다. 포인터를 매개변수로 전달할 때
1. 원본이 바뀐다 👉 '참조에 의한 전달' 이라고 부르자!
  2. 메모리 주소를 복사했다 👉 '값에 의한 전달' 이라고 부르자!
- 아주 엄밀히 말하면 C에서 함수를 호출할 땐 항상 변수를 복사합니다. 따라서 '값에 의한 전달'이란 용어가 맞습니다. 단, 포인터를 사용해 참조에 의한 전달을 흉내낼 뿐입니다.
- 근데 사실 저건 말장난입니다. 어쨌든 프로그래머 입장에선 원본이 바뀌는지 안 바뀌는지가 중요합니다. 따라서 원본이 바뀌니까 프로그래머의 의도상 '참조에 의한 전달'이라고 하는게 맞습니다.

## 103. 코드보기 : Min, Max 한 번에 구하기

---

```c
/* min_max.h */
#ifndef MIN_MAX
#define MIN_MAX
void getMinMax(const int arr[], const size_t length, int* out_min, int* out_max);
#endif
```

```c
/* min_max.c */
#include "min_max.h"
#include <assert.h>
#include <stdio.h>
/* length >= 1 때만 */
void getMinMax(const int arr[], const size_t length, int* out_min, int* out_max){
    
    size_t i;
    /* 디버그 모드에서만 검사하는 함수 */
    assert(length>=1);

    *out_min = arr[0];
    *out_max = arr[0];

    for (i=0; i<length; i++){
        if (*out_min > arr[i]){
            *out_min = arr[i];
        }
        if(*out_max < arr[i]){
            *out_max = arr[i];
        }
    }
}
```

```c
/* main.c */
#include <stdio.h>
#include "min_max.h"

int main(void){
    int arr[] = {4,2,3,15,23,12,6,8,3};
    int num_min;
    int num_max;
    getMinMax(arr, sizeof(arr)/sizeof(arr[0]), &num_min, &num_max);
    printf("min : %d, max : %d\n", num_min, num_max);
    return 0;
}
```



## 104. 포인터와 함수 반환 값

---

- 포인터도 변수니까 함수의 리턴 값으로 사용할 수도 있습니다.

- 단, 주의할 점이 있는데 지역변수의 주소를 반환하는건 매우 위험한 코드입니다. 컴파일러에 따라서 waring을 띄워주는 컴파일러도 있습니다.

  ```c
  int* add(const int a, const int b){
  	int result = a+b;
  	return &result;
  }
  
  int main(void){
  	int* result;
  	result = add(10, 20);
  	return 0;
  }
  ```

- 함수의 지역 변수는 스택메모리에 저장됩니다. 함수의 작업이 끝나면 함수의 스택 프레임은 사라지고 전에 쓰던 데이터 값은 그 자리에 남아있습니다. 그리고 그 자리 위에 다른 함수의 스택 프레임이 들어오고 다른 변수가 들어옵니다. 그렇게 다른 데이터가 덮어 씌워질 수 있습니다.

## 105. 댕글링 포인터(dangling pointer)

---

- 컴파일러가 warning을 뱉은 이유는 **유효하지 않은 주소**를 가리켜서 나는 것입니다.
- 위와 같은 코드는 절대 작성하면 안됩니다.
- 실제 가리키는 대상이 없는 포인터를 '댕글링 포인터'라고 부르고 100에 99.9는 문제를 일으킵니다.
- 단, 포인터를 안전하게 반환할 수 있는 경우가 있습니다.
  - 전역 변수 - 전역 변수의 주소는 프로그램이 도는 동안 바뀌지 않습니다.
  - 함수 내 static 변수 - 함수 안에서만 접근하지만, static 변수는 데이터 섹션에 들어가 주소가 바뀌지 않습니다.
  - 힙 메모리에 생성한 데이터
  - 즉, 스택프레임에 들어가는 데이터가 아니라 힙이나 데이터 섹션에 들어가는 메모리는 주소를 반환해도 좋습니다.



## 106. 널(NULL) 포인터

---

- 아무 것도 가리키지 않는 포인터를 '널 포인터'라고 부릅니다.

  - Null 포인터의 값은 '0'인 정수 상수 혹은 void*로 캐스팅된 표현식입니다.
  - 널 포인터를 만들려면 `int* ptr=NULL` 혹은 `int* ptr = 0` 하면 됩니다.
  - 근데 보통 전용 매크로 `#define NULL ((void*)0)`를 사용합니다.
    - 0도 대입하고 0을 void* 로 캐스팅도 하네요.

- 포인터 변수와 NULL은 비교 가능합니다.

  ```c
  int* ptr = NULL;
  
  if (ptr==NULL){~~};
  ```

- 포인터 변수 NULL 비교할 때 `ptr==0`을 써도 되긴 하는데... 그냥 `NULL`쓰도록 합시다.

## 107. NULL이 가지는 문제들

---

- 함수의 매개변수로 포인터가 쓰일 땐 해당 포인터에 NULL이 들어올 수도 있기 때문에 문제가 됩니다. 받은 변수가 NULL일 때, 아닐 때 구분해줘야 합니다.

- 기본적으로 함수를 작성할 때 NULL이 안들어 온다고 가정하고 함수를 작성하면 코드가 깔끔해집니다. (실무에서도 이렇게 내부 규약을 만들어 놓는 곳이 많습니다.) 

- 대신, NULL이 들어올 수 있는 함수는 매개변수에 알 수 있도록 표시를 해줍시다.

  ```c
  int get_score(char* student_id_or_null){
  ...
  }
  ```

- NULL이 안들어온다고 가정하고 코드 짠뒤 테스트 할 때 assert()를 사용해 검증합니다.

  ```c
  int get_score(char* student_id){
  	assert(student_id != NULL);
  }
  ```

- 매개변수로 올 때 뿐아니라, 리턴할 때도 NULL일 수 있습니다. 마찬가지로, 기본적으로 NULL을 리턴하지 않는다고 가정하고 작성합시다. 반환 할 수 있으면 함수 이름 자체에 작성합시다.

  ```c
  int get_score_or_null(char* student_id){
  	
  }
  ```

- NULL을 받거나 리턴하면 함수 내, 외부에 분기문이 많아집니다. 분기문이 많아지며 코드가 지저분해지는건 개발시에도, 유지보수시에도 안좋습니다.



## 108. 널 포인터는 언제 사용하나요?

---

- NULL 포인터는 다음과 같을 때 사용하면 좋습니다.

  - 포인터 변수를 초기화 하고 싶을 때 (선언 및 초기화는 해야 하는데 아직 참조할 주소가 없을 때)

    - 일단 아무거나 잡아놓겠다고 아무 주소나 넣을 수 있는데, 만약 그 아무 주소가 os나 프로그램에 의해 보호받고 있는 메모리면 에러가 납니다.

      ```c
      void foo(void){
      	int* ptr = NULL;
      	:
      	ptr = &g_count;
      }
      ```

  - 포인터가 유효한 주소를 참조하는 지 확인할 때

    - 아무것도 가리키지 않는 포인터(NULL 포인터)를 역참조 하는건 undefined behavior에어서 크랙이 납니다.

    - 다음과 같이 널 포인터 인지 확인 합니다.

      ```c
      void foo(void){
      	int* ptr = &g_num;
      	:
      	ptr = NULL
      	:
      	if (ptr != NULL){
      		*ptr = 100;
      	}
      }
      ```

  - 댕글링 포인터를 막기 위해

    - 동적 메모리 참조하고 있던 포인터가 있는데 해당 동적 메모리를 더 이상 사용하지 않아 메모리는 해제 했는데 포인터가 아직 동적 메모리를 보고 있으면 댕글링 포인터가 생깁니다.

      ```c
      void foo(void){
      	/* 동적메모리 할당 */
      	int* ptr = (int*)malloc(sizeof(int));
      	:
      	free(ptr); /* 동적 메모리 해제, 아직 ptr에 주소는 있음 */
      	ptr = NULL; /* 댕글링 포인터 방지 */
      }
      ```

- 존재하지 않는 메모리 주소에서 값을 읽거나 쓰려고 하면 문제가 터집니다! 컴파일 할 때 에러가 안나고, 런타임시 c 프로그램 안에서가 아니라 밖의 프로그램이나 os단에서 터질 수 있기 때문에 정말정말 위험합니다.



## 109. 포인터의 비교

---

- 포인터도 비교할 수 있습니다. 

  ```c
  void foo(int* num1, int* num2){
  	if (num1 == num2){ /* 주소 비교 */
  		:
  	}
  }
  
  void foo2(int* num1, int* num2){
  	if (*num1 == *num2){ /* 값 비교 */
  		:
  	}
  }
  ```

- ==, >, <, <=, >=, != 같은 비교들도 가능합니다.

  - 배열 같은 메모리 블록에서 사용할 수 있습니다. 



## 110. 포인터의 크기

---

- 모든 포인터는 동일한 크기를 갖습니다. 컴파일하는 시스템의 아키텍처에 따라 결정됩니다.
- 보통 cpu가 한 번에 처리할 수 있는 데이터의 크기(워드, word)와 동일합니다. 
  - 32bit cpu는 4바이트, 64bit cpu는 8바이트 (항상 그런건 아닙니다.)
  - char의 경우 값은 1바이트, char*는 4바이트(32비트의 경우)
  - int 값은 4바이트, int*는 4바이트(32비트의 경우)
  - double 값은 8바이트, double*는 4바이트(32비트의 경우)
- 저번에 매개변수로 온 배열을 sizeof() 했을 때 4바이트 나온 걸 기억 하실겁니다. [여기]({{ site.base }}/posts/study/c_kim_pope/C3/#57-배열의-요소-개수-구하는-방법)
  - 매개변수로 배열을 넘겼을 때 배열 자체를 넘긴게 아니라 배열 시작지점 주소를 전달한 것이기 때문입니다. 시작 주소. 주소는 4바이트.



## 111. 포인터와 배열의 비교

---

```c
void foo_arr(int arr[]){
	size_t size = sizeof(arr); /* 4바이트 */
}

void foo_ptr(int* ptr){
	size_t size = sizeof(ptr); /* 4바이트 */
}
```

- 둘이 매우 비슷합니다. 그럼 배열을 포인터로 대입할 수 있지 않을까요??



## 112. 배열 포인터에 대입하기

---

```c
int arr[5] = {0,1,2,3,4};
int* ptr = NULL;

ptr = arr; /* 컴파일 됨 */
```

- arr를 &arr로 넣은게 아니라 그냥 arr를 대입해도 컴파일이 됩니다.
- 디버거로 arr와 ptr의 값을 보면 값은 주소값을 가지고 있습니다.
- 단, 주의할 점이 있습니다. 배열의 시작 주소는 그럼 배열의 첫번째 요소의 주소랑 같지 않나요?
  - 위 상황에서 ptr = arr[0]는 안 될 까요? 안됩니다. int와 int* 차이로 컴파일 에러가 납니다. 
  - 대신, ptr = &arr[0] 로 하면 컴파일도 되고, 주소 값도 같습니다.



## 113. 배열 속 각 요소의 위치, 각 요소의 위치 계산하기

---

- 배열에서 각 요소 사이의 간격은 일정합니다.

- 배열들의 각 요소들의 주소는, 첫 번째 요소의 주소와 자료형의 크기만 알면 알 수 있습니다.

  - 첫 번째 요소의 주소 addr, 자료형의 크기 gap이라면
  - 두 번째 요소 주소는 addr + 1\*gap, 세 번째 요소는 addr + 2\*gap 이런 식으로...

- 단, 주의할게 있습니다. 포인터에서 연산은 단순하게 '주소 + 정수'로 계산되지 않습니다.

  ```c
  int* ptr = nums; /* ptr = 0x100 가정 */
  ptr = ptr + 3;
  ```

  - 위에서 ptr + 3은 0x100 + 0x003이 아닙니다. 
  - 해당 자료형의 크기(0x004)를 3번 더하라는 뜻입니다. 
  - 0x100 + (0x004 + 0x004 + 0x004) = 0x10C 

- 마찬가지로 short* 였다면 0x100 + (0x002 + 0x002 + 0x002) = 0x106 으로 계산 될 겁니다.

- ++, --도 마찬가지 입니다.

- 그래서 포인터로 배열 요소를 다룰 땐 index를 더하듯이 더해줘야 합니다.

  ```c
  int nums[] = {0,1,2,3,4};
  int* ptr1 = nums + 3;
  int* ptr2 = &nums[3];
  /* ptr1 == ptr2 */
  ```

  

## 114. 배열 요소에 포인터로 접근하기

---

- 그럼 아래와 같이 배열 요소를 포인터[ ] 로 접근할 수 있을까요?

  ```c
  int nums[3] = {10, 20, 30};
  int* ptr = nums;
  
  printf("%d, %d, %d\n", nums[1], ptr[1], *(ptr+1));
  ```

- 정답은 yes입니다. 배열에도 첨자 연산자 [ ]를 사용할 수 있습니다. 위 세 가지(`nums[1], ptr[1], *(ptr+1)`)는 컴파일러에게 같은 의미입니다.

- 저 세 가지가 같다면 편한 nums[1]를 계속 쓰면 되지 않나요?

  - 포인터를 쓰는 방식이 약~간 빠릅니다. 



## 115. 포인터 중간 정리, 포인터의 캐스팅

---

- 포인터에 들어가는 값은 주소다!

  - 주소연산자(&)로 가져오기
  - 배열의 이름으로 가져오기

- 포인터에 정수를 더하면 주소 이동이다!

  ```c
  int nums[] = {0,1,2,3,4};
  int* ptr = nums;
  ptr = ptr + 2
  /* ptr값(주소) + sizeof(int)*2 */
  ```

- 근데, 주소를 자료형 만큼 움직이지 말고, 딱 1 바이트만 움직이고 싶다면 어떻게 할까요?

  - char\* 로 캐스팅합니다.

    ```c
    int_ptr = (char*)int_ptr + 1
    ```

- int\* 👉 char\* 캐스팅의 의미는 무엇일까요?

  - 그 메모리 주소에 어떤 type이 들어있는지 알려주는 것입니다. 일반 자료형의 캐스팅과는 의미가 조금 다릅니다.



## 116. 딱 '한' 바이트만 옮기기

---

- 어떤 포인터형(int\*, char\*, short\*) 든 크기는 같다고 했습니다.

- 포인터형에 타입을 주는건 해당 포인터에 있는 주소로 가서 데이터를 읽을 때 어떤 타입으로 읽어야 하는지 알려주는 것입니다.

  ```c
  int arr[] = {10, 20};
  int* ptr = arr;
  
  ptr = (char*)ptr + 1;
  ```

- 이런걸 이용하면 프로그래머가 이상한 짓을 할 수 있습니다. int는 4바이트씩 몰려다녀야 하는데 그 4바이트 사이에 들어가 조작을 할  수 있습니다.

  - 능력이 된다면 불가능 한 것도 가능해지지만, 잘못 다루면 😈😈



## 117. 코드보기 : int 메모리 뷰어

---

- 잘 쓰면 이렇게 쓸 수 있다는 것의 예시 입니다. int 메모리 뷰어 프로그램입니다.

  ```c
  #include <stdio.h>
  
  int main(void){
  	const int NUM = 0x12345678; /* 주소가 아니라 정수 값 */
  	cost char* NUM_ADDRESS = (char*)&NUM; /* 해당 정수를 1바이트씩 볼것이다. */
  	size_t i;
  	
  	for (i=0; i<sizeof(NUM); ++i){
  		print("%hhx ", *(NUM_ADDRESS + i));
  		/* 78 56 34 12 (리틀 엔디언) */
  	}
  	printf("\n");
  	
  	printf("NUM in hex form : 0x%x", NUM); 
  	
  	return 0;
  }
  ```



## 118. 코드보기 : 두 배열이 겹치는가?

---

- 다른 재밌는 예시입니다.

  ```c
  /* memory.h */
  #ifndef MEMORY_H
  #define MEMORY_H
  
  #define TRUE (1)
  #define FALSE (0)
  
  #define ARRAY_LENGTH(arr) (sizeof(arr)/sizeof(arr[0]))
  
  int is_overlap(int nums1[], const size_t length1, int nums2[], const size_t length2);
  
  #endif
  ```

  ```c
  /* memory.c */
  #include "memory.h"
  
  int is_overlap(int nums1[], const size_t length1, int nums2[], const size_t length2){
  	return (nums1 <= nums2 
              ? nums1 + length1 > nums2 
              : nums2 + length2 > nums1);
  }
  
  /*
  nums1의 시작 위치가 nums2보다 작다면, nums1의 끝나는 위치(nums1+length1)가 nums2와 nums2+length2 사이에 있으면 두 배열이 겹치는 것. 
  */
  ```



## 119. 두 주소 간의 사칙연산

---

- 포인터의 연산에선 정수만 가능합니다. 2.5 이런거 더하면 안됩니다. "나는 바이트를 쪼개 비트 단위로 다루겠어!!" 이건 안됩니다.

- 두 주소 간의 사칙연산

  - 뺄셈만 가능합니다. 

  - 덧셈, 곱, 나눗셈은 의미 없습니다. 가능하지 않습니다.

  - 뺄셈은 두 주소 사이의 offset이 몇이냐 같은걸 구할 수 있습니다. 한 배열의 두 주소를 빼서 두 주소 사이에 몇 개의 요소가 있는지 등을 찾을 수 있습니다.

    ```c
    int sub = &arr[5] - &arr[1]; /* 4 */
    ```

  - 이를 이용해, 배열의 첫 번째 요소와 마지막 요소의 주소를 알면 배열의 크기를 구할 수 있습니다.



## 120. 자바와 C#에서는 모든 것이 포인터다.

---

- 자바, C#은 원시타입을 제외한 모든 자료형은 포인터입니다.
- 이걸 java에서 참조로 먼저 배우고 포인터로 돌아오다니..
- java, C#에서 이렇게 포인터로 집어오는걸 기본으로 삼았다는건, C에서도 포인터를 많이 쓸 거라는 복선인가..



## 121. 포인터를 사용한 안전하지 않은 코드

---

- 가장 많이 하는 실수는 배열에서 index에러입니다.

  ```c
  int i;
  
  int num = 1024;
  int nums[3] = {34, 135, 49 };
  
  int* ptr = nums;
  
  for (i=-1; i<=3; ++i){
  	printf("%p: %d\n", (void*)ptr+i, *(ptr+i));
  }
  /*
  i = -1을 찍는 사람은 사실 거의 없습니다.
  00000007838FF7CF: 7
  정상값
  00000007838FF7D0: 34
  00000007838FF7D1: 135
  00000007838FF7D2: 49
  nums에 없는 값. 다른 언어에선 OutOfIndex에러이지만 C에선 그냥 찍어줍니다.
  00000007838FF7D3: 1024
  */
  ```

- 위험하다고 안쓰기엔 너무 강력합니다.

- C/C++ 잘 쓰는 사람은 정말 많은 존경을 받습니다.



## 122. 포인터와 배열의 차이

---

- 지금까지 봤으면 '포인터랑 배열 완전 같네!'라고 생각할 수 있는데 다른 점도 있으니 짚고가겠습니다.

- 배열 변수에 sizeof 하면 배열 사이즈가 나옵니다. 포인터 사이즈 안나옵니다.

- 문자열 초기화

  - C엔 문자열(string) 자료형이 없습니다. char 배열로 표현합니다. 예를들어, "Friday"를 표현할 때 총 6(+1)개 char 배열을 만듭니다. +1은 문자열이 끝나는 지점이란걸 알려주기 위한 null character 입니다. '\0'를 씁니다. 

  - F r i d a y \0

  - 근데 이를 초기화하는 방법이 두 가지입니다. 

    - `char day1[] = "Monday"` 마지막에 '\0'가 알아서 들어갑니다. 함수 안에서 사용하면 스택 메모리에 저장되고, 밖에서 사용되면 데이터섹션에 들어가게 됩니다.

    - `char* day2 = "Monday";`  포인터 변수 day2 자체는 스택에 저장되고 "Monday" 자체는 데이터 섹션에 저장됩니다. day2 포인터가 데이터 섹션을 가리키게 됩니다. 실제 문자열이 스택에 들어오는 게 아닙니다.

    - 스택에 들어온 문자열은 바꿔도 되지만, 데이터 섹션에 저장된 문자열을 수정할 경우는 'undefined behavior' 입니다. 기기에 따라 크래쉬 날 수도 있습니다.(데이터 섹션은 변경되면 안 되는 값들이 들어갑니다.)

      ```
      char day1[] = "Monday"; /* 스택에 저장 */
      char* day2 = "Monday"; /* 데이터 섹션에 저장 */
      
      day1[0] = 'P' /* ok */
      day2[0] = 'P' /* undefined behavior */
      ```

- 포인터 변수에 값을 대입할 수 있으나 배열 변수에는 대입할 수 없습니다.

  ```c
  int* ptr1;
  int* ptr2;
  int arr1[5];
  int arr2[5];
  int x = 5;
  
  ptr1 = arr1; 
  arr1 = ptr1; /* 컴파일 에러 */
  
  ptr1 = &x; 
  arr1 = &x; /* 컴파일 에러 */
  
  ptr1 = ptr2;
  arr1 = arr2; /* 컴파일 에러 */
  ```

- 포인터는 산술 연산 가능, 배열은 불가능

  ```c
  ptr++;
  arr++; /* 컴파일 에러 */
  ```

  



## 123. 다시 만나는 연산자 결합 법칙

---

- 연산자 결합 법칙은 익숙한건 그냥 쓰고 잘 모르겠으면 괄호를 치면 됩니다. 사실 별로 고민할 필요가 없습니다.

- 주의할 건 연산자 결합 법칙이 동일한 연산자들끼리 있을 때 👉 방향인지, 👈 방향인지 입니다. 대부분 👉 방향이고 흔히 생각하는 👈는 대입 연산자입니다. `a=b=c=d` 

- 그런데 다른 언어에 없는 \*, \& 들과 같이 연산자들이 사용되기 시작하면 복잡해집니다.

- 퀴즈

  ```c
  int nums[] = {134, 68, 47856}; /* nums 주소는 0x104 */
  int* p = nums;
  /* 아래 각 라인을 따로 실행한다고 했을 때 num과 p는? */
  int num = *p++;
  int num = *++p;
  int num = ++*p;
  int num = (*p)++;
  ```

  

## 124. 포인터와 연산자 우선순위 및 결합 법칙

---

- 우선순위, 결합법칙 [참조]({{ site.base }}/posts/study/c_kim_pope/C2/#29-연산자)하면서 불었습니다..

  ```c
  int nums[] = {134, 68, 47856}; /* nums 주소는 0x104 */
  int* p = nums;
  /* 아래 각 라인을 따로 실행한다고 했을 때 num과 p는? */
  int num = *p++; /* num:134, p:0x108 */
  int num = *++p; /* num:68 , p:0x108 */
  int num = ++*p; /* num:135 , p:0x104 */
  int num = (*p)++; /* num:134 , p:0x104 *
  ```


- 헷갈리면 괄호를 써줍시다.



## 125. 동일한 우선순위를 갖는 연산자들

---

- 동일 우선순위 연산자들은 결합 방향이 같습니다.
- C를 자주 쓰는/쓸 사람이면 암기하고 아니라면 괄호를 씁시다!



## 126. 조금 더 빠른 배열의 요소 더하기 함수

---

- 앞서 포인터로 배열 접근하는 게 조금 더 빠르다고 했습니다.

  ```c
  int sum(int* start, int* end){
  	int result = 0;
  	int* p = start;
  	
  	while(p<end){
  		result += *p++;
  	}
  	
  	return result;
  }
  
  int main(void){
  	int nums[] = {10, 20, 30, 40, 50};
  	int result = sum(nums, nums + 5);
      
  	printf("result : %d\n", result);
  	return 0;
  }
  ```

- 위와 같이 포인터로 접근하는게 아래와 같이 배열 주소와 요소 갯수를 넘겨서 for문 도는것 보다 아주 조금 빠릅니다.

  ```c
  int sum(const int nums[], const int length){
  	size_t i;
      int result = 0;
  	
      for(i=0; i<length; ++i){
          result += nums[i];
      }
  	
  	return result;
  }
  
  int main(void){
  	int nums[] = {10, 20, 30, 40, 50};
  	int result = sum(nums, sizeof(nums)/sizeof(nums[0]));
      
  	printf("result : %d\n", result);
  	return 0;
  }
  ```

  

## 127. 왜 \*p++이 더 빠르죠?

---

- 왜 아주 조금 빠른지 시각적인 설명
- 요즘 컴파일러는 성능이 좋아서 포인터 두개를 넘기는 방식이나, 배열과 크기를 넘기는 방식이나 거의 비슷하고, 어셈블리어는 같게 나올 수도 있습니다. 
- 그러나 포팅을 고려해 포인터를 사용하는 경향도 있습니다.



## 128. 포인터와 const

---

- 포인터에서 const를 쓸 때 헷갈리는 부분이 있습니다. 보호해야 할 게 가리키는 주소, 가리키는 주소의 값 두 가지가 있기 때문입니다.



## 129. 주소를 보호하는 const 포인터

---

- 기본 자료형에 const를 붙이면 저장 값을 바꿀 수 있습니다.
  - 근데, 이게 반드시 필요하진 않습니다. 실수의 가능성도 적고 함수 안에서 끝나기 때문입니다.
- const를 포인터에 쓰면 포인터의 값. 즉, 포인터가 가리키는 주소를 보호합니다. 해당 변수가 갖는 값을 보호한다는 맥락에서 다른 변수의 const와 같습니다.
- 그럼 `const int* ptr;` 이라고 쓰면 되겠죠?
- 아닙니다. 위 의미를 표현하기 위해서, 포인터 변수는 오른쪽에서 왼쪽으로 읽기 때문에 `int* const ptr;` 이라고 해야 합니다.😲😲 
  - 영어로 "p is a const pointer to int" 라고 합니다. 'ptr은 const인데 자료형은 int\*야' 라고 이해하면 편할 것 같습니다.
- 근데 이걸 유의해야 하는 이유는 `const int* ptr;`이 가리키는건 따로 있기 때문입니다.



## 130. 값을 보호하는 const를 가리키는 포인터

---

- const 변수는 

  - 생성과 동시에 초기화해야 합니다.
  - 초기화 이후 다른 값으로 변경이 불가합니다.
  - const가 아닌 변수에 const변수를 대입할 수는 있습니다.
  - (포인터 전용) const 포인터가 가리키는 대상의 값은 변경 가능합니다.

- `const int* ptr;`은 포인터가 가리키는 주소의 값을 보호하는 것입니다.

  - **이걸 잘못 쓰면 함수 내부 뿐만 아니라 전역적으로 문제가 발생합니다.**
    - `int* const ptr;`의 경우 실수를 해도 해당 포인터가 사용된 함수 내부에서 끝나지만 `const int* ptr;`은 함수 밖에 있는 주소를 잠그기 때문에 사용한 함수 밖에서도 문제가 발생할 수 있습니다.

- 그런데 `const int* ptr;`를 표현하는 다른 방법도 있습니다.

  ```c
  const int* ptr;  /* 방법 1 */
  int const* ptr; /* 방법 2 */
  ```

  - 방법 1은 영어로 "p is a pointer to int, which is const"
  - 방법 2는 영어로 "p is a pointer to const int" 입니다.
  - 논리적으로 읽을 때 'p는 포인터인데 const int다'에서 방법 2가 더 맞는거 같지만(개인적으론 공감 x) 흔히 방법 1로 씁니다. (포인터로 가리켜진 int가 아닌 일반 int를 가리킬 때 const int를 많이 써서)
  - POCU에서도 방법 1을 표준으로 합니다.

## 131. 두 const의 정리와 예

---

- `int* const p;`
  - 메모리 주소 변경을 금지
- `const int* p;`
  - 메모리 주소가 가리키는 값 변경을 금지



## 132. 주소와 값 모두 지키는 const

---

- 둘을 합체할 수도 있습니다. 

  ```c
  const int* const p;
  ```

- 그런데 이건 생각보다 쓸 일은 없습니다. 전역변수, 구조체 멤버 변수중 절대 바뀌지 말아야 할 것들에서만 좀 쓰입니다.



## 133. const 포인터 읽는 방법 정리

---

```c
const int* p; /* 주소에 저장된 값 변경 불가 */
int const* p; /* 주소에 저장된 값 변경 불가 */
int* const p; /* p가 가리키는 주소 변경 불가 */
const int* const p; /* 둘다 불가 */
```

- 헷갈리면 오른쪽에서 왼쪽으로 읽읍시다.



## 134. const는 절대 제거하지 말자

---

- C에선 한 번 붙은 const도 제거할 수 있습니다. 캐스팅만 하면 가능합니다.

  ```c
  void foo(const int* data, const int length){
  	*((int*)data) = 10;
  }
  ```

- 하지만 **절. 대. 하. 지. 마. 세. 요.**

- 저렇게 할 일이 생겼다는 건 애초에 설계가 잘못된 것입니다.

- const 의 좋은 활용
  - const는 최대한 다 붙이되, const가 없어야 하는 상황에서 만 떼라
  - const 캐스팅은 하지 말것.



## 135. 코드보기 : 벡터 덧셈

---

- 패스



## 136. 포인터의 용도

---

- 용도 1 : 큰 데이터를 매개변수로 전달해줍니다. 매번 복사하면 데이터 낭비..
- 용도 2 : 반환 값이 둘 이상일 때 포인터로 반환 값들을 넘겨주고 포인터로 변경해줍니다.
- 용도 3 : 동적 메모리 할당
  - 함수 범위에 상관 없이 한동안 사용하고자 하는 데이터들을 힙 메모리에 동적 할당합니다.
  - 스택 메모리로 가능하면 스택을 쓰는데 좋습니다. 빠르기 때문에
- 용도 4 : 그외 - 데이터 구조를 구현할 때(연결 리스트, 트리 등), 임베디드 프로그래밍에서 하드웨어 메모리에 직접 접근해야 할 때



## 137. 포인터 배열

---

- 포인터도 변수이니까 배열 가능할까요? 일단 가능합니다.

- `int* ptr_arr[3];` 이런식으로 사용 가능합니다. 그런데 재밌는 점은, 포인터 배열은 일반 2중 배열과 유사하게 사용할 수 있습니다. 아래와 같이 말입니다.

  ```c
  int nums1[3] = {1, 2, 3};
  int nums2[2] = {10, 20};
  int nums3[4] = {3, 4, 5, 6};
  
  int* arr_ptr[3];
  arr_ptr[0] = nums1;
  arr_ptr[1] = nums2;
  arr_ptr[2] = nums3;
  ```

  



## 138. 2차원 포인터 배열

---

- 위 처럼 포인터 배열로 2중 배열을 다루기 위해선 각 내부 배열의 길이를 알려주는 size_t 배열도 필요합니다.

  ```c
  void foo(int* const data[], const size_t size, const size_t lengths[]);
  ```

- 2중 배열을 포인터로 넘길 땐 주의를 해야 합니다.  아래 코드는 컴파일 에러가 납니다.

  ```c
  void foo(int* matrix[5]){
      :
  }
  int main(void){
      int matrix[5][3] = {
          {1, 2, 3},
          {4, 5, 6},
          {7, 8, 9},
          {1, 2, 3},
          {4, 5, 6}
      }
      foo(matrix)
  }
  ```

  - 아래와 같이 알려줘야 합니다.

  ```c
  void foo(int matrix[][3], size_t m){
  	:
  }
  int main(void){
    int matrix[5][3] = {
          {1, 2, 3},
          {4, 5, 6},
          {7, 8, 9},
          {1, 2, 3},
          {4, 5, 6}
      }
      foo(matrix)
  }
  ```
  
  - 컴파일러가 매개변수가 2차원 배열이라는걸 알고, matrix[1]\[ \],matrix[2]\[ \] 같은거 할 때 한번에 건너 뛰어야 할 갯수를 알 수 있습니다.



## 139. 코드보기 : 2D 배열을 배열의 배열로 바꾸기

---

```c
int main(void){
	const int nums[3][5] = {
        {10, 20, 30, 40, 50},
        {60, 70, 80, 90, 10},
        {11, 22, 33, 44, 55}
    };
    const int* nums2[3];
    
    nums2[0] = nums[0];
    nums2[1] = nums[1];
    nums2[2] = nums[2];
    
    printf("nums[0] address : %p\n",(void*)nums[0]);
    printf("nums[1] address : %p\n",(void*)nums[1]);
    printf("nums[2] address : %p\n",(void*)nums[2]);
    
    printf("nums[2]'s offser from nums[0]' : %d\n", nums[2]-nums[0]); /* 10 */
    printf("nums[1]'s offser from nums[0]' : %d\n", nums[1]-nums[0]); /* 5 */
    
    printf("nums2[0] address : %p\n",(void*)&nums2[0]);
    printf("nums2[1] address : %p\n",(void*)&nums2[1]);
    printf("nums2[2] address : %p\n",(void*)&nums2[2]);    

    printf("nums2[0] value : %p\n",(void*)nums2[0]);
    printf("nums2[1] value : %p\n",(void*)nums2[1]);
    printf("nums2[2] value : %p\n",(void*)nums2[2]);  	
    
    printf("nums2[2]'s offser from nums2[0]' : %d\n", &nums2[2]-&nums2[0]); /* 2 */
    printf("nums2[1]'s offser from nums2[0]' : %d\n", &nums2[1]-&nums2[0]); /* 1 */
}
```



## 140. 정리

---

- 포인터에 대해 다음과 같은 것들을 배웠습니다.
  - 포인터
  - 주소 연산자, 역 참조 연산자
  - 널 포인터
  - 포인터와 const
  - 포인터 산술 연산
  - 포인터와 배열
  - 포인터 배열
- 포인터에 대해 전부 배운 것은 아닙니다. 더 복잡한건 추후에 더 알려드리겠습니다.

