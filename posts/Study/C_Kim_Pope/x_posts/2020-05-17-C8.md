---
layout: post
title: C Unmanaged Programming 8 - 가변 인자 함수, 올바른 오류 처리 방법
---
{% assign imgurl=site.imgbase|append: page.categories[-1] %}



## 214. 가변 인자 함수

---

- 가변인자함수는 말 그대로 매개변수가 변할 수 있는 함수입니다. 예를들어 printf 함수!!

- 가변 인자 함수는 아래와 같이 선언합니다.

  - <반환형> <함수명> (<자료형이 정해진 매개변수 목록>, ...)
  - 최소 한 개의 정해진 자료형의 매개변수는 필요합니다.
  - 가변 인자는 '...'으로 표현합니다.

- 자주 사용되진 않지만 유용한 경우가 있습니다.

  - 메모리에 블록을 크게 잡아 두고 거기에 여러 자료형을 저장하는 함수에서 사용합니다.
  - printf / scanf 가 대표적입니다.

- 사용 예시입니다.

  ```c
  #include <stdarg.h>
  
  int add_ints(const size_t count, ...){
      /* va_list 타입*/
  	va_list ap;
      int sum;
      size_t i;
      
      sum = 0;
      /* va_start 매크로 함수 */
      va_start(ap, count);
      {/* 가독성을 위한 의미 없는 중괄호. 없어도 됩니다. */
          for (i=0; i<count; i++){
              /* va_arg 매크로 함수 */
              sum += va_arg(ap, int);
          }
      }
      /* va_end 매크로 함수 */
      va_end(ap);
      
      return sum
  }
  
  int main(void){
      int result;
      
      result = add_ints(1, 16);
      printf("result: %d\n", result);
      /* result: 16 */
      
      result = add_ints(4, 1, 2, 3, 4);
      printf("result: %d\n", result);
      /* result: 10 */
      
      return 0;
  }
  ```

  

  ## 215. va_로 시작하는 매크로 함수들

  ---

- va_list 타입
  
  - 가변 인자 목록
  - va_start, va_arg, va_end **매크로 함수**를 사용할 때 필요한 정보가 포함됩니다.
  - 표준에서 언급은 됐지만 정확히 정의하진 않았습니다. 즉, 컴파일러마다 다르게 해석할 수 있습니다.
  
- va_start(<가변인자목록>, <가변 인자 시작하기 직전 매개변수>);
  - 매크로 함수입니다.
  - 가변 인자들에 접근하기 전에 반드시 호출해야 합니다.
  - va_list에 필요한 초기화를 수행합니다.
    - 가변 인자가 스택 메모리의 어디서부터 시작하는 지 등..

- va_end(<가변 인자 목록>);
  - 매크로 함수입니다.
  - 사용했던 가변 인자 목록을 정리합니다.
  - 가변 인자 접근이 끝나면 반드시 호출해야 합니다.

- va_arg(<가변 인자 목록>, <얻어올 가변 인자의 자료형>);
  - 매크로 함수입니다.
  - 가변 인자 목록에서 다음 가변 인자를 가져옵니다.
  - 표준상 문제로 가변 인자 목록의 기본 자료형은 아래와 같이 승격(promotion) 됩니다.
    - 모든 정수형은 int 형이 됩니다.
    - 모든 부동소수점은 double이 됩니다.
  - 즉, 두번째 매개변수에는 int나 double이 오게 됩니다.
  - 기본 자료형 말고도 구조체도 가변 인자로 넣을 수 있습니다.

- 하드웨어가 가변 인자 목록에서 자료를 읽을 때 어떤 형으로 읽을 지 알아야 합니다. 컴파일러가 이를 알려줘야 합니다. 어떤 자료형으로 읽을지.  근데 방금 전에 위 예시 코드에선 그런걸 한 적이 없습니다. 그걸 전처리기가 해줍니다.

- 개발자는 va_arg라는 매크로 함수를 썼고, 이를 보고 전처리기가 va_arg를 바꿔줍니다. 바꾼 코드를 컴파일러가 컴파일해 줍니다.

  ```c
  val = va_arg(ap, int);
  ```

  - 위와 같은 개발자의 코드를 아래와 같이 바꿔줍니다.

  ```c
  val = *(int*)ap.data;
  ((int*)ap.data)++;
  ```

  

## 216. 가변 인자 함수가 인자를 읽어오는 방법

---

- 매개 변수가 다른데 어떻게 매번 스택에 맞게 넣을까요?
- 가변 인자 함수를 호출하는 함수는 몇개의 매개변수가 필요한 지 알고 있습니다. 해당 갯수만큼 넣어주면 됩니다.
- 근데 그럼 그 가변 인자 함수는 자기가 몇개의 매개변수를 받았는지 어떻게 알까요? 호출된 가변 인자 함수의 스택 프레임에서도 매개 변수 갯수를 알아야 연산을 할텐데요.
- 그때 사용되는게 `va_start(ap, count)`입니다. 가변인자 시작 직전 매개변수(처음 매개변수)의 타입에 기초해 메모리를 계산해줍니다. 위 예시에서 `va_start(ap, count)`를 하게 되면 `ap.data = (char*)&count + sizeof(count);` 가 수행 됩니다.
- 이후 `va_arg(ap, int);`가 호출될 때마다 int 크기만큼 주소를 옮겨가며 데이터를 읽습니다. 즉, `val = *(int*)ap.data; `와 `((int*)ap.data)++;`가 수행됩니다.
- 이 모든 건 va_list 타입이 스택 메모리를 가리키는 포인터 같은 것을 가지고 있어서 가능한 일입니다.
- 음.. 사실 잘 이해가 안됩니다..



## 217. 함수에서 매개변수로 가변 인자만 받을 수 있을까?

---

- 위에서 살펴본 가변 인자 함수를 사용할 땐 맨 처음으로 자료형이 특정된 매개 변수가 있어야 합니다.

  ```c
  void do_something(..., int); /* 컴파일 에러 */
  void do_something(int, ..., int); /* 컴파일 에러 */
  void do_something(int, int, ...); /* 성공 */
  ```

- 가변 인자 아닌 것을 읽고, 가변 인자 직전의 인자를 가지고 포인터를 옮길 offset을 정하고, 해당 주소를 어떤 타입으로 읽어야 하는지 알려줘야 합니다.

- 가변인자의 갯수도 반드시 넘겨주고, 가변인자의 타입을 알려줄 인자도 넘겨줍시다.

- 그런데 printf 함수를 생각해봅시다. `printf("%s %d\n", msg, count);`와 같이 가변 인자가 몇개인지도 안알려주고 타입도 다릅니다.

  - 하지만, printf 함수 안에서 첫 번째 인자를 가지고 가변인자 몇 개가 들어오는지, 어떤 타입들이 들어오는지 알아내는 로직을 구현해 놓은 것입니다.



## 218. 코드보기 : 초간단 서식 지정자

---

```c
/* main.c */

#include "simpleio.h"

int main(void){
	printf_simple("c\n", 'A');
    printf_simple("d\n", 10);
    printf_simple("s\n", "hello");
    
    printf_simple("\n");
    printf_simple("c d s\n", 'B', 20, "Hi");
    
    return 0;
}
```

```c
/* simpleio.c */

#include <stdarg.h>
#include <stdio.h>
#include <string.h>

#include "simpleio.h"

/* static을 붙인건 이 파일 안에서만 쓸 함수이기 때문 */
static void print_int_recursive(unsigned int val){
    if (val == 0){
        return;
    }
    
	print_int_recursive(val/10);
    /* ASCII 코드 문자 '0'에 해당하는 숫자 30을 더해도 되지만 가독성을 위해 '0'을 더해줍니다. */
    /* '0'을 써도 컴파일할때 30으로 바꿔줍니다. */
    putchar('0' + val % 10);
}

void printf_simple(const char* format, ...){
    va_list ap;
    
    va_start(ap, format);
    {
        while (*format != '\0'){
            unsigned val;
            const char* str;
            
            switch (*format){
                case 's':
                    str = va_arg(ap, const char*);
                    while (*str!='\0'){
                        putchar(*str++);
                    }
                    break;
                case 'c':
                    val = va_arg(ap, unsigned int);
                    putchar(val);
                    break;
                case 'd':
                    val = va_arg(ap, unsigned int);
                    print_int_recursive(val);
                    break;
                default:
                    putchar(*format);
                    break;
            }
        }
    }
}

```



## 219. 오류 처리

---

- C엔 기본적으로 예외 처리가 없습니다. 그런데 운영체제도 C로 만들었고.. C로 만든 훌륭한 소프트웨어들이 많습니다. 사실, 예외 처리가 프로그래밍 언어의 필수 요소는 아닙니다. 개발자가 오류 처리만 잘 해준다면 말이죠.
- 다른 언어에선 try ~ exception으로 가볍게 처리하면 되지만, C에선 발생할 수 있는 오류들을 세심히 다뤄줘야 합니다.
- 보통 설계할 때 happy path만 고려하고 설계합니다. 그리고 개발중 예외가 발생해도 제대로 안고치가 유야무야 덮어두고 넘어가기도 합니다. 또, 테스트 중에 예외를 발견해도 잘 발생하지 않으면 모른척 하고 넘어가기도 합니다. 
- 크래시(아예 프로그램이 뻑나는 상황)가 나면 답이 없습니다.
  - 하지만, 크래시가 미리 날 수록 프로그램 품질이 올라갑니다
- 예외를 대충 고치면 나중에 더더더 힘들어집니다.



## 220. 안 좋은 오류 처리의 예

---

- 안좋은 오류 처리의 예를 보여드리겠습니다.

  ```c
  void swap(int* a, int* b){
  	int temp;
  	
  	temp = *a;
  	*a = *b;
  	*b = temp;
  }
  ```

- 위 코드에서 null 포인터 에러가 난다는 항의가 들어오면 아무 생각 없이 이렇게 고치곤 합니다.

  ```c
  void swap(int* a, int* b){
  	int temp;
  	
      if(a==NULL || b==NULL){
          return;
      }
      
  	temp = *a;
  	*a = *b;
  	*b = temp;
  }
  ```

- 위 예외처리의 문제는 swap 함수를 호출한 사람이 swap이 제대로 됐는지, 중간에 예외처리가 됐는지 알 수 없습니다. 

- 그리고, 이렇게 함수 마다 예외처리를 두는건 바람직하지 않습니다. 예를들어, 프로그래밍보다 더 오랜 역사를 가지고 있는 전기 회로를 생각해봅시다. 집에 누전차단기는 1개만 있습니다. 위 처럼 끝의 함수마다 예외처리를 모두 하는 건 콘센트 마다 누전차단기 두는 거랑 비슷합니다.

- 문제는 한 군데에서만 찾는게 효율적입니다.

- 오류처리에도 원칙이 있어야 합니다. 어떤 원칙이 올바른 오류처리의 원칙인지 알아봅시다.



## 221. 버그와 오류의 차이, 올바른 오류 처리 전략

---

- 버그와 오류는 다릅니다. 

- 버그

  - 예외적인 상황에서도 존재하면 안됩니다. 개발자가 의도하지 않은, 일어날 수 없다고 가정한 상황입니다.
  - 선조건 및 후조건이 성립하지 않고 assert에 실패하는 경우
    - 선조건, 후조건은 함수 이름이나 변수 이름으로 유추할 수 있어야 합니다. 그렇게 설정할 수 없다면 주석이라도 달아야 합니다.
    - 선조건, 후조건이 참인지 검사하는 assert를 넣어줍시다. 
  - 더 이상 발생하지 않도록 프로그램을 수정해야 합니다.

- 오류

  - 실제 실행 중 일어날 수 있는 예측 가능한 예외 상황들
  - 실행 중에 발생해도 프로그램이 대처하게 해줘야 합니다.

- 버그는 잡았다고 가정하고 코드를 작성합니다. 즉, 내 함수에 들어오는 데이터는 모두 유효하다고 가정합니다. 유효하지 않은 데이터를 걸러주는 곳이 필요합니다. 이를 '경계(boundary)' 라고 부릅니다.

  - 매 함수마다 입력 받은 데이터를 검증하는 과정을 거치는 건 비효율적입니다.

- 널 포인터를 받을 수 있는 함수들은 함수명, 변수명에 알 수 있게 해줍시다.

  ```c
  moster_t* spawn_monstart_or_null(const moster_t* special_monster_or_null){
  	/* 코드 */
  }
  ```

- 오류를 처리해주는 함수/코드에선 오류가 있음을 알려줘야 합니다. 가장 좋은 방법은 함수에서 오류 코드를 반환하도록 하는 것입니다.

  ```c
  libabc_error_t try_get_student(int id, student_info_t* out_student){
  	size_t idx;
  	
  	/* 코드 생략 */
  	
  	if(idx== -1){
  		/* 오류 코드 반환 */
  		return ERROR_STUDENT_NOTFOUND; 
  	}
  	
  	/* 코드 생략 */
  	
  	/* 오류 없음 코드 */
  	return ERROR_NONE;
  }
  ```

- C에선 모든 오류 코드를 하나의 enum으로 만드는 게 좋습니다. 

  - C에선 enum끼리 막 대입이 돼서 오류 코드를 구분해서 여러 enum으로 했다가 실수할 수 있습니다.
    - 다른 enum끼리 == 비교를 했는데 값이 같아서 같다고 나오는 경우
  - 구조체로 해도 되긴 하는데 보통 열거형을 많이 씁니다.

  ```c
  typedef enum{
  	ERROR_ONE;
  	ERROR_TWO;
  	:
  	ERROR_TEN;
  } libabc_error_t;
  ```

- 함수에서 errno 에 에러코드를 저장하는 방법도 있으나 좋은 방법은 아닙니다. errno을 잘 안쓰기 때문에 해당 함수에서 errno을 쓰는걸 알아야 하는데 문서를 잘 안봅니다.

- 정리

  - 기본적으로 내가 작성하는 모든 함수에 들어오는 데이터는 유효하다고 가정하고 assert를 많이 쓸 것
  - 그렇지 않은 함수는 매개변수나 함수 이름에서 그렇지 않다는 사실을 명백히 표시할 것
  - 오류 상황을 처리하는 장소는 최소한으로 할 것
  - 어떤 함수가 오류 처리를 한다는 사실을 반환형 등을 통해 확실히 보여줄 것



## 222. 오류 처리 후에도 발생하는 예외 상황

---

- 오류 처리했는데도 발생하는 예외들은 버그입니다. 코드를 다시 써야 합니다.
- 소프트웨어 품질은 테스트/QA 프로세스의 문제입니다.
- C에는 try/catch가 없지만 운영체제에서 비슷한걸 해주긴 합니다.
  - 윈도우 - SEH(구조적 예외 처리)
  - 리눅스 - POSIX 신호, Faluts, Traps, Aborts



## 223. 정리

---

- 이번 섹션에서 배운 가변 인자 함수, 올바른 오류처리 방법은 지금 당장 막 활용하고 이런건 아니지만, C를 계속하다보면 언젠가는 만나는, 나중에 쓸 때 기억나면 찾아볼만한 내용들입니다.





