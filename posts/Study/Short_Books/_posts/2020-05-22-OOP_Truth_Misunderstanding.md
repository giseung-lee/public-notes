---
layout: post
title: 객체지향의 사실과 오해(작성중)
---
{% assign imgurl=site.imgbase|append: page.categories[-1] %}

{: .p_img }
![OOP_Truth_Misunderstanding.png]({{ site.imgbase }}Short_Books/OOP_Truth_Misunderstanding.png){: .center}{: width="50%" }

## 0. 후기

---

### 후기

- 책의 전반적인 느낌은 '아는 만큼 더 보이고, 더 얻어가는 책'인 것 같습니다.
  - 저자는 객체 지향에 대한 이해를 10까지 가지고 있습니다. 그리고 책에선 '이 정도 설명해줬으면 제발 10까지 이해해주세요!!!'라는 느낌으로 자세히 설명합니다.
  - 하지만 저는 책을 읽기 전에 3만큼의 이해를 가지고 있었고, 3을 통해 책을 읽으니 5까지만 알아듣고 '아~ 이 책 뭐 말하려는 지 알겠어!' 라고 생각하는 것 같습니다.
  - 책 중간중간에 '왜 이렇게까지 설명하지?'라는 느낌이 드는걸 보니, 제가 지금 이해한 것 이상이 있는 책인 것 같습니다. 몇 년 더 경험을 쌓고 다시 읽으면 이번엔 7~8정도까지 얻어갈 수 있지 않을까 생각됩니다.
- 책에서 말하고자 하는 핵심 내용은 1장에서 다 나옵니다. 나머지 장에선 1장에서 나온 개념들을 자세히 풀어 설명해줍니다. 그런데 자세한 설명이 프로그래밍의 내용을 추상화해 객체 지향 철학 같은 느낌이라 사실 약간 말장난처럼 느껴지는 부분도 많습니다.(ex - 타입에 속하는 객체 역시 타입의 인스턴스라고 한다.) 그래도 모든 장에서 이상한 나라의 앨리스를 예로 들어가며 설명해서 이해가 어렵진 않습니다.

### 내가 정의하는 객체 지향 프로그래밍

- 한 어플리케이션을 이루는 구성요소들을 효과적으로 구성하고 관리하기 위한 프로그래밍 방법론이다.
- 효과적으로 구성하고 관리하기 위한 방법으로 객체들의 행동을 **추상화** 하고 추상화 한 행동들을 **캡슐화**한다.
- 추상화한 객체를 **구현**하고 **상속**해 사용 가능한 객체를 만든다. 구현과 상속은 1:1로 대응하는 게 아니라 1:다로 대응할 수 있는데 이런 특징을 **다형성**이라고 한다.



## 1. 협력하는 객체들의 공동체

---

### 1.1. 실세계의 비유

- 흔히 사용하는 기존의 객체 지향 설명
  - "객체지향이란 실세계를 직접적이고 직관적으로 모델링할 수 있는 패러다임"
  - 위와 같은 실세계의 비유로 객체 지향 전부를 설명하려면 맞지 않는 부분이 많습니다. 하지만 그럼에도 불구하고 아직까지도 실세계의 비유를 객체 지향 프로그래밍에 사용하는 이유는 실세계의 비유로 쉽게 설명할 수 있는 특징들도 많기 때문입니다.
- 실세계의 비유를 하나 보겠습니다.
  - 손님이 커피를 주문합니다. 
  - 캐셔는 주문을 받고 계산을 합니다. 
  - 캐셔는 손님에겐 벨을 주고, 바리스타에겐 주문 쪽지를 넘겨줍니다. 
  - 바리스타는 쪽지에 있는 대록 제조를 한 뒤 캐셔에게 넘겨줍니다. 
  - 캐셔는 제조된 커피를 받고 손님의 호출벨을 울립니다. 
  - 손님을 커피를 받고 벨을 반납합니다.
- 위와 같은 과정이 일어나기 위해선 손님, 캐셔, 바리스타가 **협력**해야 합니다. 협력을 하기위한 각자의 **역할**이 있고, 각 역할엔 역할에 맞는 **책임**이 따릅니다.
- 위의 예시를 비유로 객체 지향 프로그래밍을 설명한다면, 각 사람은 **객체**가 됩니다. 서로 주고 받는 요청과 응답은 **메세지**로 처리될 것이고, 손님이 어떤말로 주문을 할지, 캐셔가 어떻게 계산을 해줄지, 바리스타가 어떻게 커피를 만들지 각 방법들은 **메소드**가 됩니다.
- 객체들은 **협력적**이어야 합니다. 다른 객체와의 협력 없이 홀로 작동하는 객체는 없습니다.
  - "어떤 객체도 섬이 아니다" - Kent Beck 1989 
  - 협력을 위해 명확한 역할이 필요하고 역할엔 책임이 따릅니다.
- 객체는 **자율적**이어야 합니다. 바리스타가 어떻게 제조를 하는 지 캐셔는 몰라도 되는 것 처럼, 객체들은 다른 객체들에게 자신이 어떻게 작동하는지 등을 노출할 필요가 없습니다.
  - 자율적인 객체는 각자의 **상태**와 **행위**를 갖습니다.
  - 주고 받는 메세지와 메세지를 처리하는 메서드를 분리하는 것 역시 자율성의 하나입니다.

### 1.2. 객체를 지향하라

- 객체 지향에서 흔히 통용되는 잘못된 생각중 하나는 "클래스"를 객체 지향의 핵심 개념으로 보는 것입니다. 객체 지향이 무엇인지 설명하라고 하면 클래스가 갖고 있는 추상화, 상속 등의 특징에 대해 설명하는 사람들이 많습니다.
- 클래스는 많은 객체 지향 프로그래밍의 중요 요소긴 하지만, 그 자체가 핵심은 아닙니다. 클래스가 존재하지 않는 객체 지향 언어도 있습니다.(Javascript와 같은 Prototype 기반의 언어들)
- 클래스는 객체 지향 프로그래밍의 구현 메커니즘 중 하나일 뿐입니다.



## 2. 이상한 나라의 객체

---

- 이 장에선 객체의 **상태**와 **행동**, **식별자**를 중점으로 알아봅니다.

- 상태는 행동이 결정하지만, 행동의 결과를 결정하는 것은 상태 입니다.

  - 상태1 --[행동1]--> 상태2 --[행동2]--> 상태2 --[행동3]--> 상태3 

  

### 2.1. 상태

> 상태란 특정 시점에 객체가 가지고 있는 정보의 집합으로, 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.

- 상태
  - 정적 프로퍼티
  - 동적 프로퍼티
- 프로퍼티
  - 값
  - 링크
- 설명을 위해 이상한 나라의 사람 객체와 체중 증가 포션, 체중 감소 포션을 가정해봅시다.
  - 사람
    - 이름 : 민수
    - 체중 : 60kg
    - 왼쪽 주머니 : 체중 증가 포션
    - 오른쪽 주머니 : 체중 감소 포션
    - 행동
      - 포션 먹기
      - 체중 변화
  - 체중 증가 포션
    - 용량 : 10 회분
    - 행동 :
      - 용량 변화
  - 체중 감소 포션
    - 용량 : 10회분
    - 행동 :
      - 용량 변화
- 이름인 '민수'는 바뀔 수 없는 정적 프로퍼티 입니다. 체중인 '60kg'은 동적 값 프로퍼티입니다. 왼쪽 주머니와 오른쪽 주머니는 동적 링크 프로퍼티입니다. 체중 증가 포션과 체중 감소 포션에 링크되어 있습니다.
- 민수가 왼쪽 주머니의 포션을 3번 마시고 오른족 주머니의 포션을 2번 마셨다면 체중은 60 -> 61 -> 62 -> 63 -> 62 -> 61 순으로 변합니다.
  - 상태는 행동의 결과들이 쌓인 결과입니다.
  - 상태를 이용하면 과거 모든 행동을 설명하지 않고도 모든 행동의 결과를 말해줄 수 있습니다.
- 현실 세계에선 포션을 마신다면 포션의 용량이 마신 사람에 의해 줄어들 것입니다. 하지만, 객체 지향의 세계의 객체들은 자율적이기 때문에 자신의 상태를 다른 객체가 바꾸는걸 용납하지 않습니다. 다만 다른 객체가 자신의 상태를 변화시킬 수 있도록 요청할 수 있는 창구를 만들어 놓습니다. **행동**으로 넘어갑시다.



### 2.2. 행동

> 행동이란 외부의 요청 또는 수신된 메세지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 자신의 상태를 변경하거나 다른 객체에 메세지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.

- 객체의 상태를 변경하는 것은 행동입니다.
  - 행동은 객체 스스로 수행할 수도 있고, 다른 객체가 행동을 하도록 요청할 수도 있습니다.
- 앞서 말했듯이, 객체지향의 세계의 객체들은 자율적이어야 하기 때문에 다른 객체가 자신의 상태에 직접 접근하도록 허락하지 않습니다. 객체가 다른 객체의 상태를 변경할 수 있는건 다른 객체에게 상태를 변경하는 행동을 해달라고 요청하는 것 뿐입니다. 마찬가지로, 상태를 조회하는 것 역시 직접 접근하지 못하고 요청을 할 뿐입니다.
  - 이렇게 자신의 상태와 상태를 조작하는 행동을 묶는 방법을 캡슐화라고 합니다. 또한, 외부에서 자신의 상태에 직접 접근하지 못하도록 하는 것을 정보은닉이라고 합니다.
  - java에서 properties를 private로 두고(정보은닉) getter/setter(혹은 다른 메서드)로 properties로 다룹니다.(캡슐화)
- 캡슐화는 객체의 자율성을 높여 협력을 단순하고 유연하게 만듭니다.(즉, 객체간의 결합도를 떨어뜨립니다.)



### 2.3. 식별자

> 식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.

- 식별자는 말 그대로 객체들 간에 구별을 하는 기준이 되는 프로퍼티입니다. 
- 어느 두 객체가 있을때, 두 객체의 상태가 모두 같더라도 두 객체의 식별자가 다르다면 다른 객체입니다. 반대로, 어느 두 객체가 있을때, 두 객체의 상태가 다르더라도 객체의 식별자가 같으면 같은 객체입니다.(같은 객체이지만 시점이 다르다던지 등..)
- 한편, 상태가 같음으로서 식별을 완료하는 것들을 값이라고 부릅니다.(키, 몸무게 등..) 
- 값 vs 객체
  - 값과 객체를 혼란스러워 하는 이유는 두 개념 모두 클래스를 이용해 구현되기 때문입니다.
    - 책엔 그냥 '값'과 '객체'라고 나오지만 사견으론 '값 객체'와 '값이 아닌 객체'? 혹은 아래 처럼 '참조 객체'라고 표현하는게 낫지 않을까 생각합니다. '값'이라고 하니 primitive 자료형만 말하는 것 같은 느낌이 듭니다. 아래 value object가 언급된 걸 보면 primitive 자료형이 아니어도 '=='에서 객체 주소 비교가 아니라 값 비교로 비교되는 모든 객체들을 일컫는 것 같은데..
  - 일부 서적에선 오해를 없애기 위해 객체는 reference object 나 entity라는 이름을 쓰고 값은 value object 라는 이름을 쓰기도 합니다.



### 2.4. 행동이 상태를 결정한다.

- 객체 지향 입문자들이 흔히 하는 실수는 객체를 상태 중심으로 바라보는 것입니다. 설계할 때도 객체에 필요한 상태가 무엇인지 먼저 결정하고 상태에 필요한 행동을 결정합니다.
- 하지만 이와 같이 상태를 먼저 고려하는건 다음과 같은 문제들을 야기할 수 있습니다.
  - 첫째, 캡슐화가 저해됩니다.상태가 객체 내부로 깔끔하게 캡슐화 되지 못하고 밖으로 노출될 수 있습니다.
    - 사견) properties에 private 같은 접근 지시자를 깜빡하는 경우를 말하는 것이라면 그렇게 큰 우려거리는 아닐것 같습니다만..
  - 둘째, 객체를 협력자가 아닌 고립된 섬으로 만듭니다. 객체의 존재 이유는 다른 객체와의 협력을 위해서입니다. 상태를 먼저 고려한다면 객체를 고립된 섬으로 만들 수 있습니다.
  - 셋째, 객체의 재사용성이 저하됩니다. 둘째이유에서 파생되는 결과입니다.
- 객체의 행동은 객체의 역할과 책임을 나타냅니다.
- 사견) 개인적으로 이 문제는 닭이 먼저냐 달걀이 먼저냐의 논리 같긴 합니다. 오히려 '역할'을 먼저 생각하라고 했다면 더 말이 되었을 것 같습니다.



### 2.5. 현실 세계의 비유

- 사견) 아직까진 현실 세계의 비유가 맞지 않는 이유가 '현실 세계와 다르게 객체는 자율적이어서 자신의 상태를 능동적으로 조절한다.' 밖에 없는데... 이게 끝이라면 저도 다른 데서 객체지향을 설명하는데 현실 세계의 비유를 사용할 것 같습니다.



## 3. 타입과 추상화

---

### 3.1. 추상

> 추상화란 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
>
> 복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다[Kramer 2007]
>
> 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
>
> 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.
>
> 모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억하라.

- '추상'이라는 개념은 어디서 많이 들어보지만 이를 명확히 알고 있는 사람은 드뭅니다. 저는 추상의 개념을 미술에서 배웠습니다. 미술에서의 추상은 그리고자 하는 대상의 본질을 뽑아내는 일입니다. 
- 책에서 설명하는 추상 역시 그와 같습니다. 여러 객체를 다룰 때 복잡성을 줄이기 위해 공통점을 뽑고 차이점을 버리는 것, 불필요한 세부사항을 버리고 중요한 부분만 뽑는 것이 책에서 말하는 추상입니다.
- 프로그래밍을 배웠다면 여러 클래스들의 공통점들을 뽑아 요약한 인터페이스 같은 개념을 말하려는걸 눈치 챌 수 있습니다.



### 3.2. 개념

- 객체들을 추상화해서 묶는 그릇을 '개념'이라고 소개하고 있습니다.
- 개념은 심볼, 내연, 외연으로 구성됩니다.
  - 심볼(symbol) : 개념을 가리키는 간략한 이름이나 명칭
    - ex) 음료
  - 내연(intension) : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 속하는지 여부를 확인 (개념의 특징)
    - ex) 액체, 식용 ...
  - 외연(extension) : 개념에 속하는 모든 객체의 집합 (개념의 구성원)
    - ex) 사이다, 콜라, 주스 ...
- 추상화는 개념을 만듦으로서 구현되며, 프로그래밍에선 이 개념을 타입이라고 부릅니다.



### 3.3. 타입

- '개념'을 프로그래밍의 영역으로 끌고 오면 '타입'이 됩니다. (객체지향에서 말하는 클래스, 인터페이스 등..)

> 타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.

- 책에선 타입의 세부 개념으로 '데이터 타입'을 얘기하는데, 음... 제 이해가 부족한 탓에 이 '데이터 타입'에 관한 부분의 설명이 이해가지 않아 생략합니다. 
- 객체가 어떤 타입에 속하는 지 결정하는 것은 객체가 수행하는 행동입니다. 2장에서 객체에 상태와 행동이 있다고 했는데, 타입을 결정하는건 행동입니다. 타입이 행동에 의해 결정 된다는건 다음의 것들의 의미합니다.
  - 동일한 행동이란 동일한 책임을 의미합니다.
  - 동일한 책임이란 동일한 메세지 수신을 의미합니다.
  - 즉, 같은 타입이라면 동일한 메세지를 처리할 수 있어야 합니다. 어떻게 처리할 지는 타입의 구성원에 따라 다를 수 있지만, 같은 메세지를 처리하며 같은 역할, 책임을 갖습니다.
- 이렇게, 객체를 분류하기 위해선 객체가 외부에 제공하는 행동을 먼저 생각해야 합니다. 행동을 생각하기 위해선 그 객체의 책임을 고려해야 합니다. 이를 책임 주도 설계(Responsible Driven Design)이라고 합니다. (데이터 주도 설계의 대안으로 제시된 설계입니다.)
- 타입을 계층화 할 수 있습니다.
  - 일반화 / 특수화로 계층화 합니다. 일반화 해서 얻어진 상위 타입을 슈퍼타입이라고 하고, 특수화해 얻어진 하위 타입을 서브타입이라고 합니다.
  - 일반화 된 타입은 특수화 된 타입보다 외연의 크기(구성원의 수)는 커지지만 행동의 수는 적어집니다.

### 3.4. 정적 모델

> 타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기가 너무 어렵기 때문이다.

- 우리가 사용하는 객체는 프로그램이 실행됨에 따라 마음껏 변할 수 있습니다.(한 객체를 디버그 해보면 properties들이 계속 바뀌듯이) 이렇게 시간에따라 변하는 것의 상태나 행동을 포착하는 것을 **동적 모델**이라고 합니다.
- 한편, 객체들을 추상화한 타입 자체는 모든 상태와 행동이 시간에 독립적입니다. 이런 모델을 **타입 모델**이라고 하는데, 타입의 정적인 모습을 표현하기 때문에 **정적 모델**이라고도 합니다. 
- 많은 객체지향 프로그래밍 언어에서 정적 모델은 우리에게 익숙한 **클래스**를 통해 구현됩니다. 클래스는 타입을 구현하는 여러 구현 메커니즘 중 하나입니다.



## 4. 역할, 책임, 협력

---



## 5. 책임과 메시지

---



## 6. 객체 지도

---



## 7. 함께 모으기

---



