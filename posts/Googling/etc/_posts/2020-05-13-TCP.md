---
layout: post
title: TCP/IP 동작원리, UDP와 차이, handshake
---

{% assign imgurl=site.imgbase|append: page.categories[-1] %}

## TCP/IP 동작 원리

---

- TCP : Transmission Control Protocol, OSI 전송 계층

- IP : Internet Protocol, OSI 네트워크 계층

- HTTP는 데이터가 손실 되지 않은 안전한 통신인데 이 안정성을 TCP/IP가 보장해줍니다.  

- TCP 프로토콜에선 HTTP 메세지를 통째로 전달하지 않습니다. IP 패킷(IP 데이터그램)이라는 작은 조각으로 나눠 전송합니다. (패킷 통신은 서킷 통신의 단점을 보완하고자 나왔습니다.)

- IP 패킷은 아래와 같이 이루어져 있습니다.

  {: .p_img}

  ![ip_packet.png]({{ imgurl }}/ip_packet.png)<small>출처 : https://learning.oreilly.com/library/view/http-the-definitive/1565925092/ch04s01.html</small>

- IP 패킷 헤더
  - 발신지에서 목적지로 이동하는 데에 필요한 정보를 가지고 있습니다.
  - 그런데, 여러 조각으로 나뉜 HTTP의 조각들이 순서대로, 손실 없이 목적지에 도착하리란 보장은 없습니다.
- TCP Segment 헤더
  - IP 패킷들의 순서를 맞춰주고 손실이 없는걸 보장해주기 위한 것이 TCP 세그먼트 헤더입니다.
  - TCP Checksum을 통해 메세지가 손실 됐는지 판별합니다. 손실 됐다면 해당 패킷을 다시 요청합니다.
  - TCP Sequence Number를 통해 IP패킷들의 순서를 맞춥니다.

## 통신 과정( + 3 way handshake, 4 way handshake )

---

- 클라이언트와 서버가 TCP 커넥션을 맺습니다.
  - TCP 커넥션은 3 way handshake로 맺어지며 쉽게 요약하면, "연결해달라 오바" - "연결했다 오바" - "알았다 오바" 입니다.
  - **3 way handshake**
    - 클라이언트 👉 서버, 'SYN' 플래그를 가진 40~60 Byte의 TCP 패킷을 보냅니다. 커넥션 생성 요청입니다.
    - 서버 👉 클라이언트, 서버가 커넥션을 생성 후 'SYN + ACK' 플래그를 가진 TCP 패킷을 클라이언트에게 보냅니다.  요청 승낙을 뜻합니다.
    - 클라이언트 👉 서버, 커넥션 연결을 확인했다, 이제 메세지를 보내겠다는 'ACK' 플래그를 가진 확인 응답 신호를 보냅니다. 요즘 TCP는 이 확인응답 신호를 보낼 데이터와 함께 보냅니다.
- 분할 된 IP 패킷들을 보냅니다.
- IP 패킷을 받은 쪽에선 각 IP 패킷의 TCP checksum을 검사해 손실된 패킷은 다시 요청하고 손실되지 않은 패킷들은 순서를 맞춥니다.
- 클라이언트가 HTTP 요청을 보내고, 서버의 HTTP 응답을 받았다면 커넥션을 끊게 됩니다.
  - 커넥션을 끊는 과정은 4 way handshake로 이루어집니다. 
  - **4 way handshake**
    - 클라이언트 👉 서버, 연결을 종료하겠다는 'FIN'플래그 전송
    - 서버 👉 클라이언트, 확인 플래그인 'ACK' 플래그를 전송 하고 서버의 통신이 끝나길 기다립니다. 이때 TIME_WAIT 상태가 됩니다.
      - TIME_WAIT은 통신을 끊기 전, 클라이언트가 이전에 보냈지만 도착하지 않은 잉여 패킷이 있는 지 기다립니다.
    - 서버 👉 클라이언트, 통신이 끝났으면 연결을 끊겠다는 'FIN' 플래그를 전송합니다.
    - 클라이언트 👉 서버, 확인 했다는 'ACK' 플래그를 보내고 연결을 끊습니다.
      - 연결을 끊기 전에 서버가 'FIN'플래그를 보내기전에 보냈으나 'FIN'플래그보다 늦게 도착한 메세지를 기다리기 위해 일정 시간 세션을 남겨 잉여 패킷을 기다립니다. 이 과정을 TIME_WAIT이라고 합니다.



## TCP와 UDP의 차이

---

- 2000년대 이전 생 대한민국 남성이라면 스타크래프트를 안해봤을리 없고, PC방에서 친구들과 스타크래프트를 할 때 UDP로 연결한 경험이 있을 것입니다.

{: .p_img}

![starcraft_udp.jpg]({{ imgurl }}/starcraft_udp.jpg){: width=70%, height=70%}

- 어렸을 땐 그냥 옆자리 친구와 하고 싶을 땐 UDP! 이렇게 알고 있었지만, 이제 UDP가 무엇이었는지 알아야 합니다.

- TCP와 UDP의 차이는 [https://mangkyu.tistory.com/15](https://mangkyu.tistory.com/15)를 참고하였습니다.

- 데이터의 교환 방식을 아래와 같이 나눌 수 있습니다.

  ```
  교환방식
    └ 회선교환
    └ 축적후 교환
        └ 메세지 교환
        └ 패킷 교환
            └ 가상회선 방식 -> TCP
            └ 데이터그램 방식 -> UDP
  ```

- TCP와 UDP의 핵심 차이는 신뢰성을 중시하느냐, 연속성을 중시하느냐 입니다.

### TCP

- 위에서 언급하지 않은 가상회선 방식이란, 발신지와 수신지 사이의 논리적인 경로를 정한다는 것입니다. 이런 특징 때문에 연결형 프로토콜이라고도 불립니다.
- TCP는 신뢰성 있는 통신을 보장하는게 목적입니다. 
  - TCP연결을 맺어야 하며 맺는 과정도 3 way handshake를 사용합니다.
  - Checksum을 검사해 손실된 데이터를 확인하고, 재전송을 요구합니다. 
  - Sequence를 확인해 순서를 보장합니다.
  - 위에선 언급되지 않았지만 흐름제어, 혼잡제어와 같은 기능도 있습니다.
    - 흐름제어 : 수신자의 버퍼 오버플로 방지를 위해 송, 수신지의 데이터 처리 속도를 조절하는 것
    - 혼잡제어 : 네트워크 내 패킷수가 넘치지 않기 위해 조절하는 것.
- 신뢰성 있는 데이터를 주고받아야 하는 통신에 TCP를 사용합니다. (UDP가 아닌 대부분이 TCP라고 보면 됩니다.)
- 서버와 클라이언트가 1:1로 연결됩니다.

### UDP (User Datagram Protocol)

- 데이터그램 방식이란 보내지는 패킷들이 서로 독립적인 관계를 지니는 것을 뜻합니다. TCP에서 가상회선이 정해지면 패킷들이 해당 회선으로 전송됐다면, UDP에서의 패킷들은 각자 독립적인 경로를 선택합니다. 이를 비연결형 프로토콜이라고 부릅니다.
- UDP는 연속성을 지향합니다.
  - 커넥션을 맺고 끊는 과정이 없습니다. 
  - checksum을 계산하거나 sequence를 맞추지도 않습니다. 패킷들의 순서는 RTP(Real-Time Protocol)같은 기술을 통해 맞추거나 어플리케이션 수준에서 맞춥니다.
  - 흐름제어, 혼잡제어 이런 것도 없습니다.
- UDP는 연속성이 중요한 스트리밍 서비스나 한 서버가 여러 클라이언트를 상대하는 Multicast 서비스에 사용됩니다.