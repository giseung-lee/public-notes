---
layout: post
title: 1장 HTTP 개관
---

 **본 포스팅의 첫번째 목적은 제가 학습한 것을 스스로 정리해보며 정리하는 것**입니다. 따라서 책의 내용을 오해하고 정리했을 소지가 있으니 **제 포스팅에 너무 의존하진 말아주세요.**(훗날 자신있게 제 포스팅에 의존해 달라고 할 수 있는 날이 왔으면 좋겠습니다!) 내용에 대한 지적은 언제나 환영입니다. 

---
### 들어가며

 본 장에선 아래와 같은  HTTP와 연관된 대략적인 개념들을 살펴봅니다. **각 개념들은 이후 장들에서 더 자세히 알아볼 것입니다.**
1. HTTP: 인터넷의 멀티미디어 배달부
2. 웹 클라이언트와 서버
3. 리소스
4. 트랜잭션
5. 메시지
6. TCP 커넥션
7. 프로토콜 버전
8. 웹의 구성요소

---
### 1.1. HTTP : 인터넷의 멀티미디어 배달부
 본 책은 HTTP에 대한 여정을 시작하는 첫 장, 첫 절에서 HTTP를 **인터넷의 멀티미디어 배달부**'라고 표현하고 있습니다. 
- 인터넷 : 기기와 운영체제를 가리지 않는다.
- 멀티미디어 : 텍스트, 이미지, 영상 등 다양한 형식의 데이터를 다룬다.
- 배달부 : 클라이언트에서 서버로, 서버에서 서버로, 서버에서 클라이언트로 데이터를 전송해준다.

 위와 같은 의미로 HTTP를 압축적으로 표현한 것 같습니다.


 HTTP는 신뢰성 있는 데이터 전송 프로토콜(뒤에서 살펴볼 TCP/IP)을 사용하기 때문에 전송중에 데이터가 꼬이거나 손상될 걱정이 없습니다. 개발자의 입장에선 네트워크에 관한 문제는 제쳐두고 어플리케이션 개발에 집중할 수 있습니다. 

---
### 1.2. 웹 클라이언트와 서버
웹 서버 : 데이터를 저장하며, HTTP 클라이언트가 요청한 데이터를 제공한다. HTTP서버 라고도 부른다.

웹 클라이언트 : 사용자를 대신해 HTTP 요청을 보내줌준다. 매일 사용하는 웹 브라우저들이 웹 클라이언트 중 하나라고 부를 수 있다. 

> 웹 브라우저에서 https://www.naver.com/index.html 를 입력하면 브라우저는 HTTP 요청 객체를 www.naver.com 로 보낸다. 요청을 받은 서버는 서버에서 /index.html에 해당하는 **컨텐츠**를 찾고 성공했다면 웹 브라우저로 응답 HTTP 객체를 보낸다. 응답을 받은 웹 브라우저는 응답 컨텐츠를 웹 브라우저에 띄워준다. 

<그림요망>

---

### 1.3. 리소스
본 책에서 데이터, 리소스, 컨텐츠와 같이 유사한 개념이 나옵니다. 책에서 따로 각각을 비교하며 명확히 정의하진 않았지만 데이터와 리소스의 관계는 '데이터⊂리소스' 인것 같고 컨텐츠는 리소스를 가공해 얻어지고 사용자가 접하게 되는 것이라고 이해하고 있습니다.('웹 리소스는 웹 콘텐츠의 원천이다.')


웹에서의 가장 간단한 리소스는 정적 파일입니다. 웹 서버에 저장된 텍스트파일, 사진, 동영상, html 파일등이 될 수 있습니다.

리소스는 항상 정적인 것은 아닙니다. 리소스는 동적으로 컨텐츠를 만드는 프로그램을 뜻할 수도 있습니다. 

#### 1.3.1. 미디어 타입
본 포스팅의 제일 처음에서 HTTP는 '인터넷의 **멀티미디어** 배달부'라고 했습니다. 인터넷은 multi 미디어라는 말 처럼 수천 가지 데이터 타입을 다룹니다.

그리고 HTTP 프로토콜에선 이 수천 가지 데이터 타입을 다루기 위해 **HTTP가 전송하는 데이터에 MIME(Multipurpose Internet Mail Extension) 타입이라는 데이터 포맷 라벨을 붙입니다.**  지금 HTTP객체가 전송중인 데이터가 '어떤 타입의 데이터다' 라는 것을 말해주는 것이죠.

(MIME 타입은 전자메일 시스템에서 처음 사용한 데이터 타입 분류인데 메일에서 잘 작동하여 HTTP에서도 채택해 사용 중입니다.)

MIME 타입은 '주타입/부타입' 으로 이루어진 문자열 라벨입니다. html의 <form>태그에서 봤을법한 text/html, text/plain, image/jpeg, image/gif 같은 것들입니다.

수천 가지의 데이터 타입을 다루는 만큼 MIME 타입을 상세히 열거하면 엄청나게 많습니다. 아래 링크에서 MIME 타입의 모든 목록을 볼 수 있습니다.
https://www.iana.org/assignments/media-types/media-types.xhtml

#### 1.3.2. URI(Uniform Resource Identifier)
#### 1.3.3. URL(Uniform Resource Locator)
#### 1.3.4. URN(Uniform Resource Name)
위 세개의 절은 한 번에 설명을 해야할 것 같습니다. 우선 세 개념의 관계는 아래 그림과 같습니다.
<그림 요망>
앞 절에서 웹 서버는 데이터(리소스)를 저장하고 있다고 했습니다. 리소스들엔 각자의 이름(파일명)이 있겠죠. URI는 말 그대로 Resource를 Identify하는 역할을 합니다. http://www.naver.com/index.html 에서 본다면 www.naver.com 서버에서 index.html을 식별하도록 지정하는 것이죠. 

이 지정하는 방식이 URL과 URN으로 나뉩니다. 

URL은 우리가 쉽게 접한 형태입니다. 방금전 예시의  http://www.naver.com/index.html 도 쉽게 접할 수 있는 URL 형태의 URI였습니다. 

URL은 '스킴+ 서버 주소+ 리소스' 로 나타내며 리소스의 위치를 지정해 리소스를 식별합니다.

스킴 : 리소스에 접근하기 위해 사용되는 프로토콜(ex) http://, ftp://, mailto://)
서버주소 : 서버의 주소. IP+port(127.0.0.1:4000) 혹은 Domain ( www.naver.com )
리소스 : /index.html, /image/error.png ..

URN은 리소스의 위치가 아닌 이름으로 리소스를 지정합니다. 아래는 인터넷 표준문서 'RFC 2141'을 지정하는 URN입니다.

urn:ietf:rfc:2141

URN은 URL의 단점을 보완하기 위해 나왔으나 아직 실험 단계에 있습니다.

---

### 1.4. 트랜잭션

트랜잭션이란?
> Transaction processing : information processing that is divided into individual, indivisible operations
>Database transaction : a unit of work performed within a database management system
> Atomic transaction : a series of database operations such that either all occur, or nothing occurs
> Financial transaction : an agreement, communication, or movement carried out between a buyer and a seller to exchange an asset for payment 
> https://en.wikipedia.org/wiki/Transaction

위키에서 찾아본 다양한 트랜잭션에 대한 정의입니다. 공통적으로 보면 '분리할 수 없는 하나의 업무 단위' 라고 볼 수 있습니다. 

HTTP에서 트랜잭션은 '요청명령+응답결과' 입니다. 요청이 있으면 요청에 맞는 데이터를 돌려주든, 에러를 뱉든 응답결과가 있어야 HTTP 통신이 이루어졌다고 할 수 있습니다.

#### 1.4.1. 메서드 
모든 HTTP 요청은 하나의 메서드를 갖습니다. 메서드는 클라이언트가 서버에게 '어떤 동작이 취해져야 하는지' 말해줍니다. 아래는 웹에서 많이 사용되는 5개의 메서드입니다.
| HTTP메서드 | 설명 |
|:---:|:---:|
|GET|서버에서 클라이언트로 지정한 리소스를 보내라.|
|PUT|클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라|
|DELETE|지정한 리소스를 서버에서 삭제하라.|
|POST|클라이언트 데이터를 서버 게이트웨이 어플리케이션으로 보내라.|
|HEAD|지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라.|

#### 1.4.2. 상태 코드
모든 HTTP 응답은 하나의 상태코드를 갖습니다. 상태코드는 요청의 성공/실패 여부 등을 알려주는 코드입니다. 아래는 웹에서 많이 볼 수 있는 몇 가지 상태코드 입니다.
|HTTP 상태코드|설명|
|:---:|:---:|
|200|응답 성공. 문서가 올바르게 반환됨.|
|302|다시 보내라. 다른 곳에서 리소스를 가져가라.|
|404|리소스를 찾을 수 없다.|

#### 1.4.3. 웹페이지는 여러 객체로 이루어질 수 있다.
http://www.naver.com/index.html 를 웹 브라우저 주소창에 쳐보자. 하나의 화면이 나타난다. 그렇다면 한 웹 페이지는 하나의 HTTP 요청, 객체로 이루어지는 것일까? 아니다.

하나의 웹페이지를 만들기 위해선 여러 HTTP 객체가 이용될 수 있다. 우리가 웹 브라우저를 통해 하나의 URL을 요청하면 웹 브라우저는 기본적으로 html 뼈대를 받아온다. 브라우저가 받아온 html을 읽으면서 html을 보여주기 위한 이미지, 자바 애플릿 등을 다시 요청해 가져온다. 

이 요청들은 처음 요청한 URL과 다른 서버에서 가져올 수도 있다. 

---

### 1.5. 메시지
HTTP 메시지는 HTTP 요청과 응답을 표현해주는 단순한 문자열이다. 요청메세지와 응답메세지 모두 3부분(start line, header, body)로 구분됩니다. header는 빈 문자열로 끝납니다.

아래는 요청 메세지의 예시입니다. 
>
>GET / test/hi-there.txt HTTP/1.0
>
>---
>Accept: text/*
>Accept-Language: en, fr
>　   
>
>---
>

아래는 응답 메세지의 예시입니다.
>
>HTTP/1.0 200 OK
>
>---
>Content-type: text/plain
>Content-length: 19
>　
>
>---
>Hi! I'm a message!
>
>---
>

자세한 사항은 2장에서 이어집니다.

---

### 1.6. TCP 커넥션
앞선 1.1. 에서 HTTP는 신뢰성 있는 데이터 전송 프로토콜을 사용한다고 했습니다. TCP(Transmission Control Protocol) 커넥션이 바로 그 프로토콜입니다. TCP 커넥션에 관해선 4장에서 더 자세히 배울 예정입니다.

#### 1.6.1. TCP/IP
이제 개발을 막 시작했을 무렵 정보처리기사 자격증을 공부했습니다. 그때 OSI 7계층이란 걸 배웠습니다. 아래와 같은 것이죠. 아래 사진 출처 포스트에 OSI 7계층에 대해 알기 쉽게 나와 있으니 참고하셔도 좋을 것 같습니다. (참고 - https://brunch.co.kr/@wangho/6  서킷통신 vs 패킷통신)

![Alt text](/image/iso7layer.png)

출처 : https://medium.com/harrythegreat/osi%EA%B3%84%EC%B8%B5-tcp-ip-%EB%AA%A8%EB%8D%B8-%EC%89%BD%EA%B2%8C-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-f308b1115359


출처의 포스트에서 
> 각 계층은 다른 계층에 대해 알 필요가 없이 자신의 계층에서 캡슐화와 은닉(숨기기)가 가능

라고 표현했습니다. 책에서 "HTTP는 신뢰성있는 데이터 전송 프로토콜을 사용하기 때문에 데이터가 전송중에 꼬이거나 손상될 걱정 할 필요 없다."라고 한 것과 일치합니다. 데이터의 신뢰성문제는 TCP 프로토콜이 보장한다는 것이죠.

HTTP는 OSI 7계층에서 어플리케이션 계층에 속합니다. 어플리케이션 안에서 일어나는 일에만 관여하고 어플리케이션에서 어플리케이션으로(클라이언트 <-> 서버) 데이터가 전달되는 과정엔 HTTP는 손을 떼고 TCP/IP 프로토콜이 담당하는 것이죠.

TCP/IP에 대한 세부 사항은 4장에서 자세히 다룰 예정입니다. 1장에서의 TCP/IP는 HTTP통신을 도와 데이터를 전송해주는 프로토콜이라고 생각하면 좋을것 같습니다.

#### 1.6.2. 접속, IP주소, 포트번호
 클라이언트와 서버가 데이터를 주고 받기 위해선 TCP/IP 커넥션을 맺어야 합니다. 대화를 전달하기 위해 전화를 거는 것과 비슷한 개념이라고 생각할 수 있습니다.

 전화를 걸기 위해선 전화번호를 알아야 합니다. 마찬가지로  TCP/IP 커넥션을 맺기 위해 알아야 할 것들이 있는데 그게 바로 IP 주소와 포트번호입니다. IP주소가 컴퓨터를 찾는다면 포트번호는 그 컴퓨터 내에 어떤 프로그램인지를 찾아간다고 보면 좋습니다.

> http://207.200.83.29:80/index.html
> http://www.netscape.com:80/index.html
> http://www.netscape.com/index.html

 세 가지 URL이 나와있는데 이중 첫 번째 URL에서 '207.200.83.29'가 IP, '80'이 포트번호 입니다.
 두 번째 URL에선 숫자로 된 IP가 없고 'www.netsacpe.com'이라는 우리에게 친숙한 알파벳의 주소가 있습니다. 이를 도메인 네임, 호스트 명 이라고 부릅니다. 숫자로 이루어진 IP를 직관적으로 기억하기 위해 사용되는 별명과 같은 것인데 DNS(Domain Name Service)라는 장치를 통해 IP로 변환됩니다.
 세 번째 URL은 포트번호가 없습니다. 포트번호가 없다면 기본 포트번호인 80이 사용되었다고 볼 수 있습니다. 

 다음은 클라이언트와 서버가 데이터를 주고받는 간단한 개요입니다.
> 1. 사용자가 입력한 URL에서 웹 브라우저가 호스트 명을 추출한다.
> 2. 웹 브라우저가 네임서버(앞서말한 DNS를 제공하는 서버)를 통해 호스트명을 IP로 변환한다.
> 3. 웹 브라우저가 URL에 포트번호가 있다면 추출한다.
> 4. 웹 브라우저와 웹 서버가 TCP 커넥션을 맺는다.
> 5. 웹 브라우저가 웹 서버에게 HTTP 요청을 보낸다.
> 6. 웹 서버가 웹 브라우저에게 HTTP 응답을 보낸다.
> 7. TCP 커넥션이 닫히면 웹 브라우저는 받은 데이터를 파싱해 사용자에게 보여준다.

우리가 편하게 사용하는 브라우저가 엄청난 일을 해주고 있음을 다시 한 번 느낍니다.

---

### 1.7. 프로토콜 버전

> HTTP 0.9 : 1991년 개발. 초기 버전이며 굉장히 한정적인 기능을 갖고 있음.
> HTTP 1.0 : 1996년 개발. 인터넷이 급성장 하던 시기에 만들어 졌기 때문에 급하게 여러 기능들을 붙여 깔끔하게 정의되지 않음.
> HTTP 1.0 + : 1996년 개발. 1.0 버전에 좀 더 기능들을 추가, 확장 한 것.
> HTTP 1.1 : 1997년 개발. 기능적인 확장보단 그동안 급하게 발전한 온 HTTP의 설계 구조적 결함 교정, 성능 최적화, 잘못된 기능 제거에 집중함. **현재 대중적으로 쓰이는 HTTP 버전 **
> HTTP 2.0 : 1.1 버전의 성능을 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행중.


 쉽게 만날수 있는 버전은 1.1 버전이고 개발을 진행하다가 기존의 HTTP 지식으로 이해가 안되는 현상을 만날때 HTTP 버전을 한 번 확인해보면 좋을 것 같습니다.


 상세한 사항은 https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP 를 참고하시면 좋을 것 같습니다.

---

### 1.8. 웹의 구성요소

웹이 작동하는데엔 많은 애플리케이션들이 관여합니다. 이번 절에선 프록시, 캐시, 게이트웨이, 터널, 에이전트에 대해 간략히 알아볼 것입니다. 물론 각 어플리케이션들은 각각의 장에서 자세히 알아볼 것입니다.

#### 1.8.1. 프록시
> 프록시 : 클라이언트와 서버 사이에 위치한 HTTP 중개사

 개인적으로 '프록시'라는 개념은 매번 들어도 친숙해지지 않았습니다. CS에서 사용되는 여러 개념들은 인터넷을 하다보면 어깨너머로 듣기 때문에 대략적인 개념을 유추할 수 있었는데 말이죠. 

 프록시의 어원은 라틴어 procuratia라고 합니다.(https://www.hankookilbo.com/News/Read/201610111434651573)
 >procuratia = 대신, 앞에서(pro) + 관여하다, 조심하다, 배려하다(curare)

 분쟁이 있을때 당사자가 직접 싸우는게 아니라 제 삼자를 내세워 싸우는걸 proxy war 라고  합니다.  비만도를 체질량 지수로 대신하고, 삶의 질을 GDP로 대신하는 것 같이 한 지수를 다른 지수로 표현하는 걸 통계학에서 proxy variable 이라고 합니다. 

 이와 같은 맥락으로 CS에서 프록시는 클라이언트와 서버 사이에서 요청과 응답을 대신해서 주고 받는 역할을 합니다.

 주로 보안을 위해 많이 사용됩니다. 다운로드시 바이러스 검사를 한다던가, 성인 콘텐츠를 차단한다던가 하는 식입니다.


#### 1.8.2. 캐시
> 캐시 : 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고

 cache는 원래 '은닉처'라는 뜻을 가지고 있습니다. 책에서도 HTTP '창고'라고 표현을 해두었네요.

 웹 캐시는 위에서 말한 프록시 서버중 하나입니다. 요청 사항을 보고 이미 일전에 여러번 수행했던 요청이라면 굳이 멀리 있는 요청 서버를 통해 결과를 가져오는게 아니라 가까이 있는 웹 캐시에서 결과를 받아 옵니다. 

#### 1.8.3. 게이트웨이
> 게이트웨이 : 다른 애플리케이션과 연결된 특별한 웹 서버

 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용됩니다. 게이트웨이는 자신이 리소스를 가지고 있는 진짜 서버처럼 행동하기 때문에 클라이언트의 입장에선 본인이 게이트웨이와 통신하는지, 게이트웨이를 통한 서버와 통신하는지 모릅니다.

 예를들어 파일전송만 담당하는 FTP(File Transfer Protocol) 서버가 있다면 HTTP 클라이언트와 직접 통신할 수 없습니다. 그래서 이를 중개하고 변환해 주는게 HTTP/FTP 게이트웨이 입니다.


#### 1.8.4. 터널
> 터널 : 단순히 HTTP 통신을 전달하기만 하는 특별한 프록시

 터널은 두 커넥션 사이에서 raw 데이터를 열어보지 않고 그대로 전달해주는 프록시라고 합니다. 

 대표적인 예로 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송해 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것을 예로 들 수 있다는데... 사실 이 책을 보며 이해가 안되는 첫 부분입니다. 나중에 보강 하도록 하겠습니다.

#### 1.8.5. 에이전트
> 에이전트 : 자동화된 HTTP 요청을 만드는 준지능적(semi-inteligent) 웹 클라이언트

 앞서 HTTP의 구성요소들에 대해 간략히 알아봤습니다. start-line, header, body, 호스트명, IP주소, 포트번호 등... 하지만 우리가 실 생활에서 HTTP 통신을 할 땐 정말 간단하다. 웹 브라우저를 열고 www.naver.com 만 입력하면 됩니다.

 이렇게 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램을 통틀어 HTTP 에이전트라고 한다.

 웹 브라우저가 가장 대표적인 HTTP 에이전트이고, 개발할때 테스트 용으로 자주쓰는 postman 이라는 프로그램 역시 HTTP 에이전트라고 볼 수 있습니다.
 이렇게 사용자가 직접 URL을 입력하는 에이전트도 있고 웹 크롤러와 같이 완전 자동화 되어 지정된 HTTP 요청을 수행하는 것 역시 HTTP 에이전트입니다. 

---

 ### 마치며
 이 포스팅이 첫 포스팅인데 만만하게만 봤던 포스팅이 생각보다 많이 어렵다는걸 느꼈습니다. 알고있다고 생각한 개념들을 다른 사람이 모두 볼 수 있는 곳에 올려놓기 위해 정리하다보니 내가 제대로 알고 있던게 아니구나라는걸 느끼게 됐습니다.

 시간도 생각보다 굉장히 많이 걸렸습니다.

 하지만 첫 포스팅이니 그럴 거라고 생각합니다. 앞으로 하나씩 새로 배우는 개념들, 알고 있었지만 다시 정리하는 개념들을 다른 사람에게 보여줄 수 있을 정도로 다듬으면 포스팅도 술술 되는 날이 오겠죠?

 이만 마칩니다.

---

