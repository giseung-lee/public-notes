---
layout: post
title: 웹 서버
---

### 들어가며
---

### 5.1. 다채로운 웹 서버

 이번 장에선 웹 서버에 관해 간단하게 알아볼 것입니다. 

 웹 서버는 기능, 형태, 크기가 정말 다양합니다. 열 줄 짜리 스크립트가 될 수도 있고 50mb짜리 상용 엔진도 있으며, 전자기기 작은 기판에 설치된 서버도 있습니다. 이런 다양한 웹 서버들이 있지만 공통적으로 클라이언트의 HTTP 요청을 받고 처리해 리소스를 돌려주는 일을 합니다.

#### 5.1.1. 웹 서버 구현

 웹 서버는 HTTP 프로토콜을 구현해 클라이언트와 통신하며, 웹 리소스를 관리하고 서버 스스로를 관리합니다. 운영체제와 함께 TCP 커넥션 관리에 참여하기도 합니다.

 운영체제는 웹 서버가 올라가있는 하드웨어를 관리하고, TCP/IP 네트워크를 지원해주며, 웹 리소스를 관리하기 위한 파일 시스템, 연산활동을 위한 프로세스 관리를 제공합니다.

#### 5.1.2. 다목적 소프트웨어 웹 서버

 세상엔 수 만개의 웹 서버들이 존재합니다. 하지만 그중 주로 사용되는건 몇 가지에 꼽힙니다. 아래 netcraft에서 조사한 웹 서버 시장 점유율을 보시죠.

 그림 요망

 출처 : https://news.netcraft.com/archives/2019/09/27/september-2019-web-server-survey.html

 2019년 8월 까지의 데이터가 담겼는데 아파치 웹 서버의 장기집권이 끝나고 웹 서버의 춘추전국시대가 벌어지는 중인것 같습니다. 하지만 수 만개의 웹 서버중 nginx(32.7%), Apache(29.0%), Microsoft(14.7%)가 전체중 75%가량 차지합니다.

#### 5.1.3. 임베디드 웹 서버

 임베디드 웹 서버는 전자기기에 내장될 목적으로 만들어진 작원 웹 서버입니다. 공유기를 구입하고 비밀번호 등을 설정하기 위해 공유기 관리자 페이지에 들어가게 되는데 이때 들어가는 웹 페이지는 공유기의 임베디드 웹 서버에서 운영중인 페이지입니다.

---

### 5.2. 간단한 펄 웹 서버

 가장 많이 알려진 아파치 웹 서버의 코어는 50,000줄이 넘는 코드로 이루어져 있습니다. HTTP/1.1의 기능들을 모두 지원하려면 방대한 양의 코드들이 들어갈 수 밖에 없습니다. 하지만 정말 최소한의 기능만 갖는 웹 서버는 30줄로도 가능합니다. 아래 코드가 Perl 언어로 작성한 30줄 짜리 웹 서버 코드입니다.

```perl
#!/usr/bin/perl

use Socket;
use Carp;
use FileHandle;

# (1) 명령줄에서 덮어쓰지 않는 이상 8080 포트를 기본으로 사용한다.
$port = (@ARGV ? $ARGV[0] : 8080); 

# (2) 로컬 TCP소켓을 생성하고 커넥션을 기다리도록(listen) 설정한다.
$proto = getprotobyname('tcp');
socket(S, PF_INET, SOCK_STREAM, $proto) || die;
setsockopt(S, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) || die;
bind(S, sockaddr_in($port, INADDR_ANY)) || die;
listen(S, SOMAXCONN) || die;

# (3) 시작 메세지를 출력한다.
printf(" <<<Type-O-Serve Accepting on Port %d>>>\n\n",$port);
while (1)
{
 # (4) 커넥션 C를 기다린다.
 $cport_caddr = accept(C, S);
 ($cport,$caddr) = sockaddr_in($cport_caddr);
 C->autoflush(1);

 # (5) 누구로부터의 커넥션인지 출력한다.
 $cname = gethostbyaddr($caddr,AF_INET);
 printf(" <<<Request From '%s'>>>\n",$cname);

 # (6) 빈 줄이 나올 때까지 요청 메세지를 읽어서 화면에 출력한다.
screen
 while ($line = <C>)
 {
     print $line;
     if ($line =~ /^\r/) { last; }
 }

 # (7) 응답 메세지를 위한 프롬프트를 만들고, 응답줄을 입력 받는다.
 # "." 하나만으로 되어 있는 줄이 입력되기 전까지, 입력된 줄을 클라이언트에게 보낸다.
 printf(" <<<Type Response Followed by '.'>>>\n");

 while ($line = <STDIN>)
 {
     $line =~ s/\r//;
     $line =~ s/\n//;
     if ($line =~ /^\./) { last; }
     print C $line . "\r\n";
 }
 close(C);
} 
```

 이 펄 서버는 'type-o-serve'라고 이름 붙인 펄 프로그램 입니다. HTTP 요청이 오면 콘솔창에 받은 요청이 출력되고, 콘솔에 타이핑한 텍스트가 HTTP 응답으로 전송되는 간단한 서버입니다. 코드가 간단하고 책에서 단계별로 주석도 잘 적어주셨기 때문에 쉽게 이해할 수 있을 것입니다.

---

### 5.3. 진짜 웹 서버가 하는 일

 상용 웹 서버는 위의 펄 서버와 비교할 수 없을 만큼 다양한 일을 합니다. 하지만 모든 웹 서버가 하는 일은 아래와 같은 과정을 따른다고 할 수 있습니다.

1. 커넥션을 맺는다 : 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.
2. 요청을 받는다 : HTTP 요청 메세지를 네트워크로부터 읽어 들인다.
3. 요청을 처리한다 : 요청 메세지를 해석하고 행동을 취한다.
4. 리소스에 접근한다 : 메세지에서 지정한 리소스에 접근한다.
5. 응답을 만든다 : 올바른 헤더를 포함한 HTTP 응답 메세지를 생성한다.
6. 응답을 보낸다 : 응답을 클라이언트에게 돌려준다.
7. 트랜잭션을 로그로 남긴다 : 로그 파일에 트랜잭션 완료에 대한 기록을 남긴다.

 뒤로는 각 단계들에 대해 살펴보겠습니다.

---

### 5.4. 단계1 : 클라이언트 커넥션 수락

 한 클라이언트에 대해 이미 커넥션이 열려있다면 그 커넥션을 계속 사용할 수 있지만, 새로운 클라이언트가 연결을 요청한다면 새 커넥션을 열 필요가 있습니다.

#### 5.4.1. 새 커넥션 다루기

 클라이언트가 TCP 커넥션 요청을 보내오면 서버는 커넥션을 수락하고 커넥션에서 IP를 추출해 상대방이 어떤 클라이언트인지 확인합니다.(이런 TCP 커넥션들을 소켓이라고 부릅니다.) 새 커넥션이 생성되고 받아들여지면 서버는 새 커넥션을 커넥션 목록에 추가하고 데이터를 받을 준비를 합니다.

 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 닫을 수 있습니다. 금지할 IP 주소나 호스트명을 미리 정해두면 여기서 오는 모든 커넥션을 거절할 수 있습니다.

#### 5.4.2. 클라이언트 호스트 명 식별

 서버가 특정 호스트명의 접근을 막거나 로그를 남길때 어디서 온 로그인지 보기쉽게 남겨야할 필요가 있습니다. 이때 서버는 reverse DNS 를 이용해 클라이언트의 IP를 호스트명으로 변환할 수 있습니다. 이 작업을 Hostname Lookup 이라고 합니다.

 하지만 이 작업은 시간이 꽤 걸리는 작업이라 트랜잭션을 지연시킬 수 있습니다. 따라서 이 작업은 서버에 따라 꺼두기도 하고 특정 리소스에 대해서만 켜기도 합니다. 

```Apache
HostnameLookups off
<File ~ "\.(html|htm|cgi)$">
	HostnameLookups on
</File>
```

 위 코드는 아파치에서 html, htm, cgi 리소스들만 Hostname Lookup을 실시하고 나머지는 하지 않는다는 설정 코드입니다.

#### 5.4.3. ident를 통해 클라이언트 사용자 알아내기

 클라이언트를 식별하는 방법엔 ident 프로토콜을 사용하는 방법도 있습니다. 간단히 설명하자면 클라이언트 식별을 위한 전용 커넥션을 생성하고 요청, 응답해 클라이언트를 식별하는 방법입니다. 과정은 다음과 같습니다.

 그림 요망

1. 클라이언트가 HTTP 커넥션을 요청합니다.
2. 서버는 클라이언트의 커넥션 요청을 받아들입니다.
3. 서버는 클라이언트의 ident 서버 포트(113번으로 정해져있으며 처음 클라이언트가 요청할때 사용한 포트와 다른 포트입니다.)로 커넥션을 요청합니다.
4. 클라이언트가 커넥션을 받아들이면 서버가 사용자를 식별할 요청을 보냅니다.

 사내 망에선 종종 사용되지만 공공 인터넷에선 다음과 같은 이유로 사용이 되지 않습니다. 

1. 클라이언트가 ident 프로토콜을 지원해야 합니다.
2. HTTP 트랜잭션을 지연시킵니다.
3. 방화벽에서 서버의 ident 커넥션 요청이 막힐 수도 있습니다. 
4. ident 프로토콜은 가상 IP 주소를 잘 지원하지 않습니다.
5. 프라이버시 침해의 우려도 있습니다. 

---

### 5.5. 단계2 : 요청 메세지 수신

 커넥션을 맺은 뒤에 서버는 데이터가 오길 기다립니다. 커넥션에 데이터가 들어오면 앞 장에서 살펴본 HTTP 메세지의 구성을 고려해 데이터를 HTTP 메세지로 파싱합니다. 

- 요청 메서드, URI, 버전번호를 파싱합니다. 각 값은 공백으로 분리되어 있고 요청줄의 끝은 CRLF로 끝납니다.
- 헤더들을 파싱합니다. 각 헤더는 CRLF로 끝납니다.
- 헤더의 끝을 의미하는 CRLF 끝나는 빈줄을 찾아 헤더 파싱을 끝냅니다.
- 이후 엔터티 본문이 있다면 읽어 들입니다.(이때, 헤더에 Content-Length가 있다면 그만큼 읽어냅니다.)

 IP패킷들은 순서와 상관없이 불규칙하게 전달됩니다. 따라서 웹 서버는 파싱 가능할때까지 IP패킷의 데이터들을 메모리에 임시 저장해 놓을 수 있어야 합니다.

#### 5.5.1. 메세지의 내부 표현

 웹 서버에 따라 요청 메세지를 다루기 쉽게 따로 자료 구조를 만들어 저장합니다. 

#### 5.5.2. 커넥션 입력/출력 처리 아키텍처

 포털 사이트 같이 사용자가 많은 웹 서버들은 그 많은 사용자와 하나 이상의 커넥션을 맺고 있습니다. 어떤 사용자는 10초에 한 번씩 요청을 보내고 어떤 사용자는 1초에 한 번씩 보냅니다. 그리고 어떤 사용자는 웹 크롤러를 사용해 1초에 10번씩 요청을 보냅니다.

 이렇게 많은 사용자들의 커넥션들을 효율적으로 처리하기 위해 커넥션 입/출력 처리 기술도 발전해 왔습니다.

 **단일 스레드 웹 서버**

 처음은 단일 스레드 웹 서버였을 것입니다. 한 번에 하나의 커넥션만 처리하는 단일 스레드 웹 서버는 당연히 성능이 형편 없어 테스트 및 교육용이나 임베디드 서버 같은 극히 일부의 서버에서만 사용됩니다.

 **멀티프로세스와 멀티스레드 웹 서버**

 여러 요청을 동시에 처리하기 위해 멀티프로세스/스레드 서버가 사용됩니다. 프로세스/스레드는 필요할때마다 생성할 수도 있고 미리 만들어 놓고 기다릴 수도 있습니다. 

 각각 커넥션 마다 프로세스/스레드를 할당 할 수 있지만 이렇게 된다면 너무 많은 메모리를 낭비하게 될 것입니다. 멀티프로세스/스레드를 사용하는 웹 서버들은 프로세스/스레드 수에 제한을 걸어 놓습니다.

**다중 I/O 서버**

 방금 설명한 멀티프로세스/스레드 서버는 단일 스레드보단 좋지만 한계가 있습니다. 하나의 커넥션이 생성되었지만 실제로 그 커넥션에 들어오는 요청이 없더라도 프로세스/스레드는 그 커넥션을 보면서 데이터가 오길 기다려야하기 때문입니다. 이를 해결하기 위한 방법이 입출력 다중화(multiplexing)입니다.

 하나의 커넥션은 '입력 -> 처리 -> 출력' 으로 동작한다고 볼 수 있습니다. 그런데 처리중엔 입력, 출력에서 쓰이는 함수가 봉쇄(block) 됩니다. #@$#@$@#$ 추가 설명 필요

**다중 멀티스레드 웹 서버**

 

---

### 5.6. 단계3 : 요청 처리

 요청을 처리하는 과정은 뒷 장들에서 나올 주제중 대부분이기 때문에 이번 장에선 생략하겠습니다. 

---

### 5.7. 단계4 : 리소스의 매핑과 접근

 웹 서버는 리소스를 주고 받게 해주는 서버입니다. 이 리소스에는 이미지 파일, html 페이지 같은 고정된 리소스도 있지만 php, jsp, asp와 같이 리소스 생성 어플리케이션을 통해 만들어지는 동적인 리소스도 있습니다.

 웹 서버가 리소스를 알맞게 제공하기 위해선 클라이언트의 요청 URI에서 그에 맞는 리소스나 리소스 생성기를 찾아야 합니다. 이런 과정을 리소스 맵핑이라고 합니다.

#### 5.7.1. Docroot

#### 5.7.2. 디렉터리 목록

#### 5.7.3. 동적 콘텐츠 리소스 매핑

#### 5.7.4. 서버사이드 인클루드(Server-Side Includes, SSI)

#### 5.7.5. 접근 제어

---

### 5.8. 단계5 : 응답 만들기

#### 5.8.1. 응답 엔터티

#### 5.8.2. MIME 타입 결정하기

#### 5.8.3. 리다이렉션

---

### 5.9. 단계6 : 응답 보내기

---

### 5.10. 단계7 : 로깅

 트랜잭션이 완료되면 트랜잭션의 수행 결과를 로그 파일에 기록합니다. 대부분의 웹 서버는 기본적으로 제공하는 로깅 방식과 설정들이 있습니다.

---

### 마치며